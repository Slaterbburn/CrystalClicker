TurboDebug Class
A set of tools for debugging and testing Turbo implementations.
Signature
export declare class TurboDebug
Remarks
To use Turbo debugging, you must enable it by setting the ITurboSettings.debug property to true.
Properties
events
static
An event subscription that delivers enriched analytics payloads to event listeners.

Signature
static events: {
        onDebugTurboPlayerEvent: hz.LocalEvent<{
            player: hz.Player;
            eventData: EventData;
            action: Action;
        }>;
    };

Action Enum
The Turbo actions that trigger Turbo events. Turbo actions are contexts for Turbo events, and represent the trigger or player action for an associated event.
Signature
export declare enum Action
Enumeration Members
Member
Value
Description
ABILITY_DEQUIP
1
Triggered when a player unequips an ability.
The ITurboSettings.useAbilities property enables ability analytics.
ABILITY_EQUIP
2
Triggered when a player equips an ability.
The ITurboSettings.useAbilities property enables ability analytics.
ABILITY_USED
3
Triggered when a player uses an ability.
The ITurboSettings.useAbilities property enables ability analytics.
ACHIEVEMENT_UNLOCKED
4
Triggered when a player unlocks an achievement.
The ITurboSettings.useQuests property enables achievement analytics.
AFK_ENTER
5
Triggered when a player enters the AFK (away from keyboard) state.
The ITurboSettings.useAFK property enables AFK analytics.
AFK_EXIT
6
Triggered when a player exits the AFK (away from keyboard) state.
The ITurboSettings.useAFK property enables AFK analytics.
AREA_CHANGE
7
Triggered when a player transitions from one specific area to another.
AREA_ENTER
8
Triggered when a player enters an area.
AREA_EXIT
9
Triggered when a player exits an area.
ARMOR_DEQUIP
11
Triggered when a player unequips an armor item.
The ITurboSettings.useArmor property enables armor analytics.
ARMOR_EQUIP
10
Triggered when a player equips and armor item.
The ITurboSettings.useArmor property enables armor analytics.
CAMERA_CLOSE
13
Triggered when a player closes their camera.
CAMERA_OPEN
12
Triggered when a player opens their camera.
CAMERA_PHOTO_TAKEN
14
Triggered when a player captures image in the game.
CUSTOM_ACTION
15
Triggered for a custom action.
DAMAGE_ENEMY
16
Triggered when an enemy takes damage.
The ITurboSettings.useDamage property enables damage analytics.
DAMAGE_PLAYER
17
Triggered when a player takes damage.
The ITurboSettings.useDamage property enables damage analytics.
DEATH
18
Triggered when a player character dies.
DISCOVERY_MADE
19
Triggered when a player activates a discovery event.
The ITurboSettings.useDiscovery property enables discovery analytics.
FRICTION_CAUSED
20
Triggered when a player causes a friction event.
The ITurboSettings.useFriction property enables friction analytics.
FRICTION_HIT
21
Triggered when an event that causes friction occurs.
KILL
22
Triggered when a player kills an enemy controlled by the game or a player character.
KILL_ENEMY
23
Triggered when a player kills an enemy controlled by the game.
KILL_PLAYER
24
Triggered when a player kills another player character.
LEVEL_UP
25
Triggered when a player levels up.
LOBBY_PROGRESS
26
Triggered when a player in a lobby area pogresses through a matchmaking queue.
LOBBY_SECTION_ENTER
27
Triggered when a player enters a lobby area.
LOBBY_SECTION_EXIT
28
Triggered when a player exits a lobby area.
MINI_GAME_END
30
Triggered when a mini game ends.
MINI_GAME_START
29
Triggered when a mini game starts.
MINI_GAME_STATS
31
Triggered when the stats of a mini game are updated.
PLAYER_READY_ENTER
32
Triggered when a player enters an area that implies their intent to play.
PLAYER_READY_EXIT
33
Triggered when a player exits an area that implies their intent to play.
REJOINED_INSTANCE
34
Triggered when a player rejoins the instance.
REVIVE
35
Triggered when a player is revived.
REVIVED_BY_PLAYER
36
Triggered when the player is revived by another player.
REWARDS_EARNED
37
Triggered when a player earns rewards.
ROUND_ABANDONED
39
Triggered when a player abandons a round.
ROUND_END
38
Triggered for all players that were participating when the round ends (one event per player).
ROUND_LOST
41
Triggered when a player loses a round.
ROUND_REJOINED
40
Triggered when a player rejoins a round.
ROUND_START
42
Triggered for all participating players when the round starts, or for players that join during an existing round.
ROUND_STATS
43
Triggered when the stats for a round are updated.
ROUND_WIN
44
Triggered when a player wins the round.
SECTION_ABANDONED
45
Triggered when a player quits a section.
SECTION_END
46
Triggered when the section ends.
SECTION_RESTART
47
Triggered when a player restarts a section.
SECTION_START
48
Triggered when a player starts playing a section.
SECTION_STATS
49
Triggered when the stats for a section are updated.
STAGE_ABANDONED
50
Triggered when a player quits a stage.
STAGE_END
51
Triggered when a stage ends.
STAGE_PROGRESS
52
Triggered when a player progresses through a stage.
STAGE_RESTART
53
Triggered when a player restarts a stage.
STAGE_START
54
Triggered when a player begins a stage.
STAGE_STATS
55
Triggered when stats are collected for a stage.
TASK_ABANDONED
56
Triggered when a task is abondoned.
TASK_END
57
Triggered when a tesk ends.
TASK_FAIL
58
Triggered when task fails.
TASK_START
59
Triggered when begins.
TASK_STEP_END
60
Triggered when a task step ends.
TASK_STEP_FAIL
61
Triggered when a task step fails.
TASK_STEP_START
62
Triggered when task step begins.
TASK_STEP_SUCCESS
63
Triggered when the step of a task succeeds.
TASK_SUCCESS
64
Triggered when a task succeeds.
TURBO_GAME_STATE_SNAPSHOT
65
Triggered when an intermittent snapshot is taken of the game state.
TURBO_HEARTBEAT
67
Triggered every interval defined by the ITurboSettings.heartbeatFrequencySeconds property.
TURBO_PLAYER_STATE_SNAPSHOT
66
Triggered when an intermittent snapshot is taken of the player state.
UNKNOWN
-1
Triggered for an unknown action.
WEAPON_EQUIP
68
Triggered when a player equips a weapon.
WEAPON_FIRED
69
Triggered when a player fires a weapon.
WEAPON_GRAB
70
Triggered when a player grabs a weapon.
WEAPON_HELD
71
Triggered while a player is holding a weapon.
WEAPON_RELEASE
72
Triggered when a player unequips a weapon.
WEARABLE_EQUIP
73
Triggered when a player equips a wearable item.
WEARABLE_RELEASE
74
Triggered when a player removes a wearable item.
WORLD_ENTER
75
Triggered when a player enters the world.
WORLD_EXIT
76
Triggered when a player exits the world.

Remarks


The ITurboSettings interface defines properties that enable and disable analytics tracking for each Turbo action.
AnalyticsSectionGameMode Enum
The game modes for analytics sections.
Signature
export declare enum AnalyticsSectionGameMode
Enumeration Members
Member
Value
Description
GAMEPLAY
0
The default game mode for gameplay.
LOADING
1
The game mode for loading sections.
LOBBY
2
The game mode for lobby sections.

Remarks


To enable sections analytics, see the ITurboSettings.useSections property.
GameStateEnum Enum
The shared game states for a world instance. This is not player-specific.
Signature
export declare enum GameStateEnum
Enumeration Members
Member
Value
Description
ACTIVE
"ACTIVE"
The game is active.
BETWEEN_ROUNDS
"BETWEEN_ROUNDS"
The game is in between rounds.
BETWEEN_STAGES
"BETWEEN_STAGES"
The game is in between stages.
NEVER_STARTED
"NEVER_STARTED"
The game has not started.
NONE
"NONE"
No game state.

ParticipationEnum Enum
The participation state of a player in a world instance.
Signature
export declare enum ParticipationEnum
Enumeration Members
Member
Value
Description
AFK
"AFK"
The player is AFK (away from the keyboard).
BETWEEN_ROUNDS
"IN_BETWEEN_ROUNDS"
The player is in between game rounds.
IN_BETWEEN_STAGES
"IN_BETWEEN_STAGES"
The player is in between game stages.
IN_LOBBY
"IN_LOBBY"
The player is in the game lobby.
IN_ROUND
"IN_ROUND"
The player is participating in a game round.
NONE
"NONE"
No player state.

TurboSettings Interface
The available settings for a Turbo implementation including the ability to enable and disable specific types of analytics tracking. Many of these settings configure a corresponding set of Turbo actions.
Signature
export interface ITurboSettings
Remarks
The TurboDefaultSettings variable defines the default settings.
Properties
debug
true to enable Turbo debugging functionality, such as logs and tools; false to disable it.

Signature
debug: boolean;
eventsForWeaponGrabAndRelease
true to enable logging for weapon equip and release events on the backend server; false to disable it.

Signature
eventsForWeaponGrabAndRelease: boolean;
Remarks
To use this setting, you must enable the property.
Player state updates can still reflect current the weapon and timers without logging the actual events.
eventsForWearableEquipAndRelease
true to enable logging for wearable equip and release events on the backend server; false to disable it.

Signature
eventsForWearableEquipAndRelease: boolean;
Remarks
To use this setting, you must enable the ITurboSettings.useWearableEquipAndRelease property.
Player state updates can still reflect current the wearables and timers without logging the actual events.
experiments
A method that enables a set of experiments for the player.

Signature
experiments: Set<string>;
frictionNoKOsTimerSeconds
A timer that creates a friction event whenever no player kills occur within the specified duration during gameplay. The timer specified in seconds.

Signature
frictionNoKOsTimerSeconds: number;
Remarks
The property must be true; otherwise, this timer is ignored.
gameMode
The name of a custom game mode, such as arena, or adventure.

Signature
gameMode: string;
Remarks
The property must be enabled to track game mode events and data.
heartbeatFrequencySeconds
The frequency, in seconds, for capturing a heartbeat event for each active player.

Signature
heartbeatFrequencySeconds: number;
Remarks
The setting must be enabled to track heartbeat events.
maxAFKSecondsBeforeRemove
The number of seconds before deleting an AFK player.

Signature
maxAFKSecondsBeforeRemove: number;
Remarks
Deleting AFK players after the specified duration can help avoid memory leak issues.
maxFrictionNoKOEvents
The maximum number of times to send friction events due to no player kills occuring within the timer.

Signature
maxFrictionNoKOEvents: number;
Remarks
The setting must be enabled in order to track this event type.
playerInitialArea
The name of the initial area where a player first enters a world.

Signature
playerInitialArea: string;
playerInitialState
The player's initial participation state when a player first enters a world.

Signature
playerInitialState: ParticipationEnum;
turboUpdateSeconds
The frequency, in seconds, for Turbo Manger to update the game state.

Signature
turboUpdateSeconds: number;
Remarks
Setting this proprety lower affects performance; higher impacts accuracy.
useAFK
true to track AFK enter and AFK exit events and data; false otherwise.

Signature
useAFK: boolean;
Remarks
This setting enables the AFK_ENTER and AFK_EXIT actions.
useAbilities
true to track abilities events and data; false otherwise.

Signature
useAbilities: boolean;
useArmor
true to track armor events and data; false otherwise.

Signature
useArmor: boolean;
Remarks
This setting enables the ARMOR_EQUIP and ARMOR_DEQUIP actions.
useDamage
true to track damage events and data; false otherwise.

Signature
useDamage: boolean;
Remarks
This setting enables the DAMAGE_ENEMY and DAMAGE_PLAYER actions.
useDiscovery
true to track events and data for player discoveries; false otherwise.

Signature
useDiscovery: boolean;
Remarks
This setting enables the DISCOVERY_MADE action.
useForward
true to log forward vectors with each player action; false otherwise.

Signature
useForward: boolean;
useFriction
true to track friction events and data; false otherwise.

Signature
useFriction: boolean;
Remarks
This setting enables the FRICTION_HIT and FRICTION_CAUSED actions.
Friction events can be derived or deliberate, and slow player pogression.
useFrictionNoKOs
true to track friction events and data caused when no player kills occur within a specified duration; false otherwise.

Signature
useFrictionNoKOs: boolean;
Remarks
This setting enables events and data tracking based on the the ITurboSettings.frictionNoKOsTimerSeconds property.
useGameMode
true to track custom game mode events and data; false otherwise.

Signature
useGameMode: boolean;
Remarks
This setting enables the ITurboSettings.gameMode property.
Game modes are custom variations of the game, such as arena and guild wars.
useHeartbeats
true to track track heartbeat events and data at the specified duration; false otherwise.

Signature
useHeartbeats: boolean;
Remarks
The ITurboSettings.heartbeatFrequencySeconds property specifies the tracking duration.
useLevelUp
true to track player level and level up events and data; false otherwise.

Signature
useLevelUp: boolean;
Remarks
This setting enables the LEVEL_UP action.
useQuests
true to enable quest and achievement analytics; false otherwise.

Signature
useQuests: boolean;
useRewards
true to track rewards events and data; false otherwise.

Signature
useRewards: boolean;
Remarks
This setting can track data such as collectibles, XP, points, and bonuses. Reward tracking ensures rewards are being received and provide insight into how, when, and why those rewards are earned or missed.
useRotation
true to log rotation using Eurler angles with each player action; false otherwise.

Signature
useRotation: boolean;
useRounds
true to track events and data for rounds; false otherwise.

Signature
useRounds: boolean;
Remarks
A round is a full completion of a game and represent the overall loop of funnel progression analytics, which consists of rounds, stages, and sections.
This setting enables the ROUND_ABANDONED, ROUND_END, ROUND_LOST, ROUND_REJOINED, ROUND_START, ROUND_STATS, and ROUND_WIN actions.
useSections
true to track events and data for sections; false otherwise.

Signature
useSections: boolean;
Remarks
Sections are subdivisions of in funnel progression analytics. Sections track progression when a player starts, completes, or enters a subsection of a stage, wave, or level. The purpose of this setting is to track more granular portions of the areas where an event occurs or a player is navigating.
This setting enables the SECTION_ABANDONED, SECTION_END, SECTION_RESTART, SECTION_START, and SECTION_STATS actions.
useStages
true to track events and data for stages; false otherwise.

Signature
useStages: boolean;
Remarks
Stages are subdivisions of in funnel progression analytics.
This setting enables the STAGE_ABANDONED, STAGE_END, STAGE_PROGRESS, STAGE_RESTART, STAGE_START, and STAGE_STATS actions.
useTasks
true to track events and data for tasks and task steps, such as activities, challenges, and puzzles. Otherwise, false.

Signature
useTasks: boolean;
Remarks
Tasks and task steps were designed to measure specific activities where a player has a series of steps to follow. In comparison to rounds, stages, and sections, tasks are more discrete units that can occur within those items.
This setting enables the TASK_ABANDONED, TASK_END, TASK_FAIL, TASK_START, TASK_STEP_END, TASK_STEP_FAIL, TASK_STEP_START, TASK_STEP_SUCCESS, and TASK_SUCCESS actions.
useTeamAndRole
true to track team and role based data using the player state; false otherwise.

Signature
useTeamAndRole: boolean;
useTransforms
true to continuously track player position, rotation, distances, and other player transforms. false to only calculate player transforms for each action.

Signature
useTransforms: boolean;
useWeaponEquip
true to track when a player equips a weapon; false otherwise.

Signature
useWeaponEquip: boolean;
Remarks
This setting enables the WEARABLE_EQUIP action.
Weapon grab and release analytics are enabled with the ITurboSettings.useWeaponGrabAndRelease property.
Weapon usr analytics are enabled with the ITurboSettings.useWeapons property.
useWeaponGrabAndRelease
true to enable tracking for weapon grab and release events and data. false to disable it.

Signature
useWeaponGrabAndRelease: boolean;
Remarks
This setting enables the WEAPON_GRAB and WEAPON_RELEASE actions.
When players grab and release weapons, it updates weapon utilization timers and the current weapons data.
The property enables logging the individual grab and release events to the backend server.
useWeapons
true to track weapon use events and data; false otherwise.

Signature
useWeapons: boolean;
Remarks
This settings enables the WEAPON_FIRED action.
Weapon grab and release analytics are enabled with the ITurboSettings.useWeaponGrabAndRelease property.
Weapon equip analytics are enabled with the ITurboSettings.useWeaponEquip property.
useWearableEquipAndRelease
true to track equip and release events and data for wearables; false otherwise.

Signature
useWearableEquipAndRelease: boolean;
Remarks
This setting enables the WEARABLE_EQUIP and WEARABLE_RELEASE actions.
The ITurboSettings.eventsForWearableEquipAndRelease property enables logging the individual grab and release events to the backend server.
useWearables
true to track events and data for a wearables that are currently eqquiped by a player. false to disable it.

Signature
useWearables: boolean;
Remarks
The ITurboSettings.useWearableEquipAndRelease property enables tracking of equip and release events for wearables.

AbilityDequipPayload type
A payload sent by the OnAbilityDequip event.
Signature
export declare type AbilityDequipPayload = FullTurboEventPayload<typeof OnAbilityDequip>;
AbilityEquipPayload type
A payload sent by the OnAbilityEquip event.
Signature
export declare type AbilityEquipPayload = FullTurboEventPayload<typeof OnAbilityEquip>;
AbilityEquipPayload type
A payload sent by the OnAbilityEquip event.
Signature
export declare type AbilityEquipPayload = FullTurboEventPayload<typeof OnAbilityEquip>;
AbilityUsedPayload type
A payload sent by the OnAbilityUsed event.
Signature
export declare type AbilityUsedPayload = FullTurboEventPayload<typeof OnAbilityUsed>;
AreaEnterPayload type
A payload sent by the OnAreaEnter event.
Signature
export declare type AreaEnterPayload = FullTurboEventPayload<typeof OnAreaEnter>;
AreaExitPayload type
A payload sent by the OnAreaExit event.
Signature
export declare type AreaExitPayload = FullTurboEventPayload<typeof OnAreaExit>;
ArmorDequipPayload type
A payload sent by the OnArmorDequip event.
Signature
export declare type ArmorDequipPayload = FullTurboEventPayload<typeof OnArmorDequip>;
ArmorEquipPayload type
A payload sent by the OnArmorEquip event.
Signature
export declare type ArmorEquipPayload = FullTurboEventPayload<typeof OnArmorEquip>;
CustomActionData type
The superset of optional data fields recognized by the Turbo engine.
Signature
export declare type CustomActionData = {
    actionCustom?: string;
    team?: string;
    role?: string;
    gameMode?: string;
    gameRoundName?: string;
    gameRoundId?: string;
    gameRoundActivePlayers?: Array<string>;
    gameState?: GameStateEnum;
} & Optionalize<AbilityEquipPayload> & Optionalize<AbilityDequipPayload> & Optionalize<AbilityUsedPayload> & Optionalize<AFKEnterPayload> & Optionalize<AFKExitPayload> & Optionalize<AreaEnterPayload> & Optionalize<AreaExitPayload> & Optionalize<ArmorEquipPayload> & Optionalize<ArmorDequipPayload> & Optionalize<DamageEnemyPayload> & Optionalize<DamagePlayerPayload> & Optionalize<DeathPayload> & Optionalize<DeathByPlayerPayload> & Optionalize<DeathByEnemyPayload> & Optionalize<DiscoveryMadePayload> & Optionalize<FrictionCausedPayload> & Optionalize<FrictionHitPayload> & Optionalize<KOPlayerPayload> & Optionalize<KOEnemyPayload> & Optionalize<LevelUpPayload> & Optionalize<PlayerReadyEnterPayload> & Optionalize<PlayerReadyExitPayload> & Optionalize<QuestCompletedPayload> & Optionalize<RewardsEarnedPayload> & Optionalize<RoundStartPayload> & Optionalize<RoundEndPayload> & Optionalize<SectionStartPayload> & Optionalize<SectionEndPayload> & Optionalize<StageStartPayload> & Optionalize<StageEndPayload> & Optionalize<TaskStartPayload> & Optionalize<TaskEndPayload> & Optionalize<TaskStepStartPayload> & Optionalize<TaskStepEndPayload> & Optionalize<WeaponGrabPayload> & Optionalize<WeaponEquipPayload> & Optionalize<WeaponReleasePayload> & Optionalize<WearableEquipPayload> & Optionalize<WearableReleasePayload>;
References
GameStateEnum, AbilityEquipPayload, AbilityDequipPayload, AbilityUsedPayload, AreaEnterPayload, AreaExitPayload, ArmorEquipPayload, ArmorDequipPayload, DamageEnemyPayload, DamagePlayerPayload, DeathPayload, DeathByPlayerPayload, DeathByEnemyPayload, DiscoveryMadePayload, FrictionCausedPayload, FrictionHitPayload, KOPlayerPayload, KOEnemyPayload, LevelUpPayload, PlayerReadyEnterPayload, PlayerReadyExitPayload, QuestCompletedPayload, RewardsEarnedPayload, RoundStartPayload, RoundEndPayload, SectionStartPayload, SectionEndPayload, StageStartPayload, StageEndPayload, TaskStartPayload, TaskEndPayload, TaskStepStartPayload, TaskStepEndPayload, WeaponGrabPayload, WeaponEquipPayload, WeaponReleasePayload, WearableEquipPayload, WearableReleasePayload
Remarks
This type is exported for easier visibility of the fields recognized by the Turbo engine.
CustomEventPayload type
A payload sent by the OnCustomAction event.
Signature
export declare type CustomEventPayload = FullTurboEventPayload<typeof OnCustomAction>;
DamageEnemyPayload type
A payload sent by the OnDamageEnemy event.
Signature
export declare type DamageEnemyPayload = FullTurboEventPayload<typeof OnDamageEnemy>;
DamagePlayerPayload type
A payload sent by the OnDamagePlayer event.
Signature
export declare type DamagePlayerPayload = FullTurboEventPayload<typeof OnDamagePlayer>;
DeathByEnemyPayload type
A payload sent by the OnDeathByEnemy event.
Signature
export declare type DeathByEnemyPayload = FullTurboEventPayload<typeof OnDeathByEnemy>;
DiscoveryMadePayload type
A payload sent by the OnDiscoveryMade event.
Signature
export declare type DiscoveryMadePayload = FullTurboEventPayload<typeof OnDiscoveryMade>;
EventData type
A set of key-value pairs that represent data for an analytics event.
Signature
export declare type EventData = {
    [key: string]: EventValueType;
};
References
EventValueType
Remarks
See EventValueType for the available value types.
EventValueType type
A valid value type for an EventData object.
Signature
export declare type EventValueType = string | number | boolean | hz.Vec3 | Array<string>;
FrictionCausedPayload type
A payload sent by the OnFrictionCaused event.
Signature
export declare type FrictionCausedPayload = FullTurboEventPayload<typeof OnFrictionCaused>;
FrictionHitPayload type
A payload sent by the OnFrictionHit event.
Signature
export declare type FrictionHitPayload = FullTurboEventPayload<typeof OnFrictionHit>;
GameRoundEndForPlayersPayload type
A payload sent by the OnGameRoundEndForPlayers multi-player event.
Signature
export declare type GameRoundEndForPlayersPayload = FullTurboEventPayload<typeof OnGameRoundEndForPlayers>;
GameRoundStartForPlayersPayload type
A payload sent by the OnGameRoundStartForPlayers multi-player event.
Signature
export declare type GameRoundStartForPlayersPayload = FullTurboEventPayload<typeof OnGameRoundStartForPlayers>;
KOEnemyPayload type
A payload sent by the OnKOEnemy event.
Signature
export declare type KOEnemyPayload = FullTurboEventPayload<typeof OnKOEnemy>;
KOPlayerPayload type
A payload sent by the OnKOPlayer event.
Signature
export declare type KOPlayerPayload = FullTurboEventPayload<typeof OnKOPlayer>;
LevelUpPayload type
A payload sent by the OnLevelUp event.
Signature
export declare type LevelUpPayload = FullTurboEventPayload<typeof OnLevelUp>;
PlayerReadyEnterPayload type
A payload sent by the OnPlayerReadyEnter event.
Signature
export declare type PlayerReadyEnterPayload = FullTurboEventPayload<typeof OnPlayerReadyEnter>;
PlayerReadyExitPayload type
A payload sent by the OnPlayerReadyExit event.
Signature
export declare type PlayerReadyExitPayload = FullTurboEventPayload<typeof OnPlayerReadyExit>;
QuestCompletedPayload type
A payload sent by the OnQuestCompleted event.
Signature
export declare type QuestCompletedPayload = FullTurboEventPayload<typeof OnQuestCompleted>;
RewardsEarnedPayload type
A payload sent by the OnRewardsEarned event.
Signature
export declare type RewardsEarnedPayload = FullTurboEventPayload<typeof OnRewardsEarned>;
RoundEndPayload type
A payload sent by the OnRoundEnd event.
Signature
export declare type RoundEndPayload = FullTurboEventPayload<typeof OnRoundEnd>;
RoundStartPayload type
A payload sent by the OnRoundStart event.
Signature
export declare type RoundStartPayload = FullTurboEventPayload<typeof OnRoundStart>;
SectionEndPayload type
A payload sent by the OnSectionEnd event.
Signature
export declare type SectionEndPayload = FullTurboEventPayload<typeof OnSectionEnd>;
SectionStartPayload type
A payload sent by the OnSectionStart event.
Signature
export declare type SectionStartPayload = FullTurboEventPayload<typeof OnSectionStart>;
StageEndPayload type
A payload sent by the OnStageEnd event.
Signature
export declare type StageEndPayload = FullTurboEventPayload<typeof OnStageEnd>;
StageStartPayload type
A payload sent by the OnStageStart event.
Signature
export declare type StageStartPayload = FullTurboEventPayload<typeof OnStageStart>;
TaskEndPayload type
A payload sent by the OnTaskEnd event.
Signature
export declare type TaskEndPayload = FullTurboEventPayload<typeof OnTaskEnd>;
TaskStartPayload type
A payload sent by the OnTaskStart event.
Signature
export declare type TaskStartPayload = FullTurboEventPayload<typeof OnTaskStart>;
TaskStepEndPayload type
A payload sent by the OnTaskStepEnd event.
Signature
export declare type TaskStepEndPayload = FullTurboEventPayload<typeof OnTaskStepEnd>;
askStepStartPayload type
A payload sent by the OnTaskStepStart event.
Signature
export declare type TaskStepStartPayload = FullTurboEventPayload<typeof OnTaskStepStart>;
WeaponEquipPayload type
A payload sent by the OnWeaponEquip event.
Signature
export declare type WeaponEquipPayload = FullTurboEventPayload<typeof OnWeaponEquip>;
WeaponGrabPayload type
A payload sent by the OnWeaponGrab event.
Signature
export declare type WeaponGrabPayload = FullTurboEventPayload<typeof OnWeaponGrab>;
WeaponReleasePayload type
A payload sent by the OnWeaponRelease event.
Signature
export declare type WeaponReleasePayload = FullTurboEventPayload<typeof OnWeaponRelease>;
WearableEquipPayload type
A payload sent by the OnWearableEquip event.
Signature
export declare type WearableEquipPayload = FullTurboEventPayload<typeof OnWearableEquip>;
WearableReleasePayload type
A payload sent by the OnWearableRelease event.
Signature
export declare type WearableReleasePayload = FullTurboEventPayload<typeof OnWearableRelease>;
Turbo Variable
The main interface for managing In-World Analytics events in Horizon Worlds, including registering the API for use in your world, and capturing analytics events.
Signature
Turbo: TurboManager
Remarks
The Turbo variable is an interface used to create a custom analytics manager in TypeScript that captures Turbo Analytics events.
Before using the Turbo interface, you must complete these steps:
1. In Desktop Editor, enable the horizon/analytics setting in Script Settings.
2. In Desktop Editor, enable TurboAnalytics in the Asset Library.
3. Optionally, if you aren't using the default Turbo settings, configure the ananlytics categories you want to capture in the ITurboSettings interface.
4. In a script, register your world with the Analytics API.
To register your world with the Analytics API, complete these steps:
1. Add an entity to your world that you can attach to the the Analytics API in your script. This can be an empty entity.
4. Create an AnalyticsManger script and attach it the entity.
5. Register the entity with the Turbo interface by calling Turbo.register and then pass the script and turboSettings to the register method. For information about using the register method, see Component.register().
For more information on using In-World Analytics, see the In-World Analytics guide.
Examples
Example 1
This example demonstrates how to register a world with the Analytics API. In the example, an AnalyticsManager script is attached to an entity in the world, and then the entity is registered with the Turbo interface.
export class AnalyticsManager extends hz.Component {
 static propsDefinition = {
   overrideDebug: { type: hz.PropTypes.Boolean, default: false },
 };
 static s_instance: AnalyticsManager;
 serverPlayer!: hz.Player;
 serverPlayerID!: number;
 overrideDebug!: boolean;

 start() {
   Turbo.register(this, turboSettings);
   AnalyticsManager.s_instance = this;
   this.subscribeToEvents();
  }
Example 2
To capture Analytics events using the Turbo interface, call the Turbo.send method. Here's an example.
Turbo.send(TurboEvents.OnAreaEnter, player, payload);
TurboDataService Variable
A service that retrieves live Turbo analytics data for maintaining statistics and performing debugging.
Signature
TurboDataService: TurboDataServiceClass
Remarks
Default settings:
debug false
experiments new Set<string>()
frictionNoKOsTimerSeconds 120.0
gameMode - game mode is empty
heartbeatFrequencySeconds 120
maxAFKSecondsBeforeRemove 180
maxFrictionNoKOEvents 30
playerInitialArea lobby_world_enter
playerInitialState ParticipationEnum.IN_LOBBY
turboUpdateSeconds 1.0
These settings are set to true by default, which enables the associated Turbo actions:
useAFK
useDiscovery
useFriction
useGameMode
useHeartbeats
useLevelUp
useQuests
useRewards
These settings are set to false by default, which disables the associated Turbo actions:
eventsForWearableEquipAndRelease
useAbilities
useArmor
useDamage
useForward
useFrictionNoKOs
useRotation
useRounds
useSections
useStages
useTasks
useTeamAndRole
useTransforms
useWeaponEquip
useWeaponGrabAndRelease
useWeapons
useWearableEquipAndRelease
useWearables
TurboEvents Variable
The events used by the Turbo interface to capture analytics data from a world.
Signature
TurboEvents: {
    OnCustomAction: SinglePlayerTurboEvent<CustomActionData>;
    OnAbilityEquip: SinglePlayerTurboEvent<{
        abilityKey: string;
        abilityId?: number | undefined;
        abilitySeconds?: number | undefined;
        abilityCooldownSeconds?: number | undefined;
    }>;
    OnAbilityDequip: SinglePlayerTurboEvent<{
        abilityKey: string;
    }>;
    OnAbilityUsed: SinglePlayerTurboEvent<{
        abilityKey: string;
    }>;
    OnAreaEnter: SinglePlayerTurboEvent<{
        actionArea: string;
        actionAreaIsLobbySection: boolean;
        actionAreaIsPlayerReadyZone: boolean;
        turboState?: ParticipationEnum | undefined;
        nextArea?: {
            actionArea: string;
            actionAreaIsLobbySection: boolean;
            actionAreaIsPlayerReadyZone: boolean;
        } | undefined;
    }>;
    OnAreaExit: SinglePlayerTurboEvent<{
        actionArea: string;
        actionAreaIsLobbySection: boolean;
        actionAreaIsPlayerReadyZone: boolean;
        turboState?: ParticipationEnum | undefined;
        nextArea?: {
            actionArea: string;
            actionAreaIsLobbySection: boolean;
            actionAreaIsPlayerReadyZone: boolean;
        } | undefined;
    }>;
    OnArmorEquip: SinglePlayerTurboEvent<{
        armorBody?: string | undefined;
        armorHelm?: string | undefined;
    }>;
    OnArmorDequip: SinglePlayerTurboEvent<{
        armorBody?: string | undefined;
        armorHelm?: string | undefined;
    }>;
    OnDamagePlayer: SinglePlayerTurboEvent<{
        otherPlayerDamaged: string;
        damageAmount: number;
        damageIsFriendlyFire?: boolean | undefined;
        weaponKey?: string | undefined;
    }>;
    OnDamageEnemy: SinglePlayerTurboEvent<{
        enemyDamaged: string;
        damageAmount: number;
        damageIsFriendlyFire?: boolean | undefined;
        weaponKey?: string | undefined;
    }>;
    OnDeath: SinglePlayerTurboEvent<{
        killedByPlayer: string;
        killedByWeaponKey?: string | undefined;
        killedByEnemy?: boolean | undefined;
    }>;
    OnDeathByPlayer: SinglePlayerTurboEvent<{
        killedByPlayer: string;
        killedByWeaponKey?: string | undefined;
    }>;
    OnDeathByEnemy: SinglePlayerTurboEvent<{
        killedByEnemy: string;
        killedByWeaponKey?: string | undefined;
    }>;
    OnDiscoveryMade: SinglePlayerTurboEvent<{
        discoveryItemKey: string;
        discoveryAmount?: number | undefined;
        discoveryIsImplied?: boolean | undefined;
        discoveryNumTimes?: number | undefined;
        rewardsType?: string | undefined;
        rewardsEarned?: number | undefined;
        weaponKey?: string | undefined;
    }>;
    OnFrictionCaused: SinglePlayerTurboEvent<{
        frictionItemKey: string;
        frictionAmount?: number | undefined;
        frictionIsImplied?: boolean | undefined;
        frictionNumTimes?: number | undefined;
    }>;
    OnFrictionHit: SinglePlayerTurboEvent<{
        frictionItemKey: string;
        frictionAmount?: number | undefined;
        frictionIsImplied?: boolean | undefined;
        frictionNumTimes?: number | undefined;
        affectedPlayerNames?: string[] | undefined;
        afkRoundSeconds?: number | undefined;
        roundNoKillSeconds?: number | undefined;
    }>;
    OnKOPlayer: SinglePlayerTurboEvent<{
        otherPlayerKilled: string;
        killedByWeaponKey: string;
    }>;
    OnKOEnemy: SinglePlayerTurboEvent<{
        enemyKilled: string;
        killedByWeaponKey: string;
    }>;
    OnLevelUp: SinglePlayerTurboEvent<{
        playerLevel: number;
        playerTitle: string;
    }>;
    OnPlayerReadyEnter: SinglePlayerTurboEvent<{
        actionArea: string;
        actionAreaIsLobbySection: boolean;
        actionAreaIsPlayerReadyZone: boolean;
        turboState?: ParticipationEnum | undefined;
        nextArea?: {
            actionArea: string;
            actionAreaIsLobbySection: boolean;
            actionAreaIsPlayerReadyZone: boolean;
        } | undefined;
    }>;
    OnPlayerReadyExit: SinglePlayerTurboEvent<{
        actionArea: string;
        actionAreaIsLobbySection: boolean;
        actionAreaIsPlayerReadyZone: boolean;
        turboState?: ParticipationEnum | undefined;
        nextArea?: {
            actionArea: string;
            actionAreaIsLobbySection: boolean;
            actionAreaIsPlayerReadyZone: boolean;
        } | undefined;
    }>;
    OnQuestCompleted: SinglePlayerTurboEvent<{
        achievementKey: string;
    }>;
    OnRewardsEarned: SinglePlayerTurboEvent<{
        rewardsType: string;
        rewardsEarned: number;
    }>;
    OnRoundStart: SinglePlayerTurboEvent<{
        gameMode?: string | undefined;
        role?: string | undefined;
        roundId?: number | undefined;
        roundName?: string | undefined;
        team?: string | undefined;
    }>;
    OnRoundEnd: SinglePlayerTurboEvent<{
        turboState: ParticipationEnum;
    }>;
    OnSectionStart: SinglePlayerTurboEvent<{
        gameMode?: string | undefined;
        role?: string | undefined;
        sectionId?: number | undefined;
        sectionName?: string | undefined;
        team?: string | undefined;
    }>;
    OnSectionEnd: SinglePlayerTurboEvent<{
        turboState: ParticipationEnum;
    }>;
    OnStageStart: SinglePlayerTurboEvent<{
        gameMode?: string | undefined;
        role?: string | undefined;
        stageId?: number | undefined;
        stageName?: string | undefined;
        team?: string | undefined;
    }>;
    OnStageEnd: SinglePlayerTurboEvent<{
        turboState: ParticipationEnum;
    }>;
    OnTaskStart: SinglePlayerTurboEvent<{
        taskKey: string;
        taskType?: string | undefined;
    }>;
    OnTaskEnd: SinglePlayerTurboEvent<{
        taskKey: string;
        taskType?: string | undefined;
    }>;
    OnTaskStepStart: SinglePlayerTurboEvent<{
        taskKey: string;
        taskStepKey: string;
    }>;
    OnTaskStepEnd: SinglePlayerTurboEvent<{
        taskKey: string;
        taskStepKey: string;
    }>;
    OnWeaponGrab: SinglePlayerTurboEvent<{
        weaponKey: string;
        weaponType?: string | undefined;
        isRightHand?: boolean | undefined;
    }>;
    OnWeaponEquip: SinglePlayerTurboEvent<{
        weaponKey: string;
        weaponType?: string | undefined;
        isRightHand?: boolean | undefined;
    }>;
    OnWeaponRelease: SinglePlayerTurboEvent<{
        weaponKey: string;
        weaponType?: string | undefined;
        isRightHand?: boolean | undefined;
        weaponUsedNumTimes?: number | undefined;
    }>;
    OnWearableEquip: SinglePlayerTurboEvent<{
        wearableKey: string;
        wearableType?: string | undefined;
    }>;
    OnWearableRelease: SinglePlayerTurboEvent<{
        wearableKey: string;
        wearableType?: string | undefined;
    }>;
    OnGameRoundStartForPlayers: MultiPlayerTurboEvent<{
        sendPlayerRoundStart: boolean;
        gameStartData?: {
            gameMode?: string | undefined;
            roundName?: string | undefined;
            teamByPlayer?: Map<hz.Player, string> | undefined;
            roleByPlayer?: Map<hz.Player, string> | undefined;
        } | undefined;
    }>;
    OnGameRoundEndForPlayers: MultiPlayerTurboEvent<{
        sendPlayerRoundEnd: boolean;
    }>;
}
Remarks
Most Turbo events have a corresponding Turbo action that is the context for the event. For example, the context of the OnAbilityEquip event is the ABILITY_EQUIP action that is triggered when a player equips an ability.
Before you use Turbo events and actions to capture analytics data, you must ensure the corresponding settings are enabled in the ITurboSettings interface.
To capture a Turbo event, you can pass the event and event payload to the Turbo.send method. Event payloads are listed in the Type Alias section of the analytics package topic. For example, the payload for the OnAbilityDequip event, is the type.
Examples
This script captures the OnAreaEnter event, which is triggered by the AREA_ENTER action when the player enters an area. The payload type for the event is AreaEnterPayload.
Turbo.send(TurboEvents.OnAreaEnter, player, payload);
analytics Variable
Logs analytics events to the Creator Analytics dashboard and Creator Analytics table.
Signature
analytics: {
    logEvent(player: hz.Player, eventName: string, data: EventData): void;
    markPlaySection(sectionName: string, gameMode: AnalyticsSectionGameMode): void;
}
AgentGrabbableInteraction Class
The grabbing features of an agent.
Signature
export declare class AgentGrabbableInteraction
Properties
entity
The entity that is attached to the agent.

Signature
entity: Entity;

Methods
drop(handedness)
Commands an agent to drop a held item.

Signature
drop(handedness: Handedness): void;
Parameters
handedness: HandednessThe hand to drop the item from.
Returns
void
getGrabbedEntity(handedness)
Gets the entity currently held by the specified hand.

Signature
getGrabbedEntity(handedness: Handedness): Entity | undefined;
Parameters
handedness: HandednessThe hand to query.
Returns
Entity | undefined- The held entity or undefined if not holding anything.
grab(handedness, entity)
Commands the agent to pick up an entity.

Signature
grab(handedness: Handedness, entity: Entity): Promise<AgentGrabActionResult>;
Parameters
handedness: HandednessThe hand to pick up the entity with.
entity: EntityThe entity to grab. The entity must be grabbable.
Returns
Promise<AgentGrabActionResult>- A promise describing how the grabbing action ended.

AgentLocomotion Class
Exposes the locomotion features of an AI agent.
Signature
export declare class AgentLocomotion
Remarks
To use agent locomotion, you must enable Navigation Locomotion in Desktop Editor. For more information, see the Nav Mesh Agents guide.
Properties
entity
The entity that is attached to the agent.

Signature
entity: Entity;
isGrounded
Indicates whether the agent is on the ground. true if the agent is on the ground, false if the agent is above, below, or otherwise away from the ground.

Signature
isGrounded: ReadableHorizonProperty<boolean>;
isJumping
Indicates whether the agent is performing a jump.

Signature
isJumping: ReadableHorizonProperty<boolean>;
isMoving
Indicates whether the agent is moving.

Signature
isMoving: ReadableHorizonProperty<boolean>;
targetDirection
The current target direction of the agent. Undefined if the agent isn't currently rotating to a specific target direction.

Signature
targetDirection: ReadableHorizonProperty<Vec3 | undefined>;
targetPosition
The current locomotion target of the agent. Undefined if the agent isn't currently moving.

Signature
targetPosition: ReadableHorizonProperty<Vec3 | undefined>;

Methods
jump()
Issues a jump command.

Signature
jump(): Promise<AgentLocomotionResult>;
Returns
Promise<AgentLocomotionResult>A promise describing how the jump ended.
moveToPosition(position, options)
Issues a movement command to the agent. Issuing a new move, rotate, follow, or jump command cancels any previous move command.

Signature
moveToPosition(position: Vec3, options?: AgentLocomotionOptions): Promise<AgentLocomotionResult>;
Parameters
position: Vec3The desired destination.
options: AgentLocomotionOptions(Optional) Optional parameters.
Returns
Promise<AgentLocomotionResult>- A promise describing how the locomotion ended.
moveToPositions(path, options)
Issues a movement command along a path. Issuing a new move, rotate, follow, or jump command cancels any previous move command.

Signature
moveToPositions(path: Array<Vec3>, options?: AgentLocomotionOptions): Promise<AgentLocomotionResult>;
Parameters
path: Array<Vec3>An array of points to follow, in order.
options: AgentLocomotionOptions(Optional) Optional parameters
Returns
Promise<AgentLocomotionResult>- A promise describing how the locomotion ended.
rotateTo(direction, options)
Issues a rotation command to change the direction the agent faces. Issuing a new move, rotate, follow, or jump command cancels any previous move command.

Signature
rotateTo(direction: Vec3, options?: AgentRotationOptions): Promise<AgentLocomotionResult>;
Parameters
direction: Vec3The desired facing direction.
options: AgentRotationOptions(Optional) Optional parameters.
Returns
Promise<AgentLocomotionResult>- A promise describing how the rotation ended.
stopMovement()
Stops any movement in progress.

Signature
stopMovement(): void;
Returns
void

AvatarAIAgent Class
Extends AIAgentGizmo
A gizmo used to place AI Agents in a world, such NPCs.
Signature
export declare class AvatarAIAgent extends AIAgentGizmo
Remarks
An AI agent autonomously navigates a world using navigation Meshes, which define the walkable areas of the environment.
To set up a navigation mesh, see the Navigation Mesh Generation guide.
To set up an AI agent in Desktop Editor, see the Nav Mesh Agents guide.
Properties
agentPlayer
The player this agent is associated with.

Signature
agentPlayer: ReadableHorizonProperty<Player | undefined>;
grabbableInteraction
[readonly]
The grabbable interaction capabilities of the agent.

Signature
readonly grabbableInteraction: AgentGrabbableInteraction;
locomotion
[readonly]
The Locomotion capabilities of the agent.

Signature
readonly locomotion: AgentLocomotion;

Methods
despawnAgentPlayer()
Removes the player embodied by this agent from the world.

Signature
despawnAgentPlayer(): void;
Returns
void
getGizmoFromPlayer(player) static
Returns the AIAgentGizmo that is associated with the provided player.

Signature
static getGizmoFromPlayer(player: Player): Entity | undefined;
Parameters
player: PlayerThe player.
Returns
Entity | undefinedThe gizmo, or undefined if no gizmo is associated with the player.
spawnAgentPlayer()
Spawns a player to be embodied by this agent from the world.

Signature
spawnAgentPlayer(): Promise<AgentSpawnResult>;
Returns
Promise<AgentSpawnResult>A promise describing how the respawn ended.
toString()
The ID of the AvatarAIAgent object.

Signature
toString(): string;
Returns
stringA string representation of the ID.

AgentGrabActionResult Enum
The result of a request for an agent to pick up an entity.
Signature
export declare enum AgentGrabActionResult
Enumeration Members
Member
Value
Description
AlreadyHolding
1
The request failed because another entity is already being held.
InvalidEntity
3
The entity is not grabbable.
NotAllowed
2
The agent is not allowed to hold the entity.
Success
0
The entity was successfully picked up.

AgentLocomotionResult Enum
The result of a move action for an agent.
Signature
export declare enum AgentLocomotionResult
Enumeration Members
Member
Value
Description
Canceled
1
The action is canceled.
Complete
0
The action is complete.
Error
2
An error occured when attempting the action.

AgentSpawnResult Enum
The result of a player spawn request
Signature
export declare enum AgentSpawnResult
Enumeration Members
Member
Value
Description
AlreadySpawned
1
This agent already has a player.
Error
3
An error has occured.
Success
0
The player was successfully spawned
WorldAtCapacity
2
There is no room in the world for an additional player.

AgentLocomotionOptions type
The options used when a movement command is issued to the agent.
Signature
export declare type AgentLocomotionOptions = {
    movementSpeed?: number;
    travelTime?: number;
    acceleration?: number;
    deceleration?: number;
};
AgentRotationOptions type
The options that can be specified when issuing a rotation command to an agent.
Signature
export declare type AgentRotationOptions = {
    rotationSpeed?: number;
    rotationTime?: number;
};
ApiName Variable
The name of the API.
Signature
ApiName = "avatar_ai_agent"
AttachCameraMode Class
Extends ICameraMode
Manipulates runtime properties of cameras in attach mode. When attach mode is enabled for a camera, it follows a target entity's position and rotation.
Signature
export declare class AttachCameraMode implements ICameraMode
Remarks
The Camera.setCameraModeAttach() method enables attach mode for a camera.
Properties
positionOffset
Local offset from the target position. Target's frame of reference.

Signature
positionOffset: HorizonProperty<Vec3>;
rotationOffset
Local rotation from the target rotation. Target's frame of reference.

Signature
rotationOffset: HorizonProperty<Quaternion>;
rotationSpeed
Controls how quickly the camera rotates to keep the target in view. If not set, the camera always points in the same direction the target is facing.

Signature
rotationSpeed: HorizonProperty<number | null>;
translationSpeed
Controls how quickly the camera moves with the target it's attached to. If not set, the camera is always snapped to the position offset from the target.

Signature
translationSpeed: HorizonProperty<number | null>;

Camera Class
Manages the view, position, and features of the in-game camera.
Signature
export declare class Camera
Properties
cameraRoll
The camera roll angle.

Signature
cameraRoll: HorizonProperty<number>;
Remarks
You can change this value over time using .
collisionEnabled
Indicates whether camera collision is enabled.

Signature
collisionEnabled: HorizonProperty<boolean>;
currentMode
The type of camera that is active.

Signature
currentMode: ReadableHorizonProperty<CameraMode>;
Remarks
For native cameras, this propety indicates whether the camera is in first or third person mode.
forward
Gets the forward direction of the camera.

Signature
forward: ReadableHorizonProperty<Vec3>;
Examples
if (LocalCamera !== null) {
  LocalCamera.forward.get()
}
lookAtPosition
Gets the world space position that first intersects the center of the camera view, ignoring the avatar of the local player.

Signature
lookAtPosition: ReadableHorizonProperty<Vec3>;
Examples
if (LocalCamera !== null) {
  var lookAtPosition = LocalCamera.lookAtPosition.get();
}
perspectiveSwitchingEnabled
Indicates whether the player is allowed to toggle between first and third person modes.

Signature
perspectiveSwitchingEnabled: HorizonProperty<boolean>;
Examples
if (LocalCamera !== null) {
  LocalCamera.position.get()
}
Remarks
This property does not affect a script's ability to forcibly enable 1st or 3rd person mode with or . This property has as no effect in VR, where first person is always enabled.
position
Gets the position of the camera.

Signature
position: ReadableHorizonProperty<Vec3>;
Examples
if (LocalCamera !== null) {
  LocalCamera.position.get()
}
rotation
Gets the rotation of the camera.

Signature
rotation: ReadableHorizonProperty<Quaternion>;
Examples
if (LocalCamera !== null) {
  LocalCamera.rotation.get()
}
up
Gets the up direction of the camera.

Signature
up: ReadableHorizonProperty<Vec3>;
Examples
if (LocalCamera !== null) {
  LocalCamera.up.get()
}

Methods
convertWorldToScreenPoint(worldPos)
Converts a world position to a screen position on mobile and desktop. X: 0.0, Y: 0.0 represents the top left of the screen X: 0.5, Y: 0.5 represents the center of the screen X: 1.0, Y: 1.0 represents the bottom right of the screen Z represents the distance to the object, negative will be behind the camera

Signature
convertWorldToScreenPoint(worldPos: Vec3): Vec3;
Parameters
worldPos: Vec3the world position to convert
Returns
Vec3A Vec3 representing the screen position
getCameraModeObjectAs(classType)
Get the current camera mode object as a specific type.

Signature
getCameraModeObjectAs<TRuntimeCameraMode extends ICameraMode>(classType: new () => TRuntimeCameraMode): TRuntimeCameraMode | null;
Parameters
classType: new () => TRuntimeCameraModeThe type of camera mode object to get, must extend ICameraMode.
Returns
TRuntimeCameraMode | nullThe camera mode object as the specified type, or null if the camera mode object is not of the specified type.
Examples
Get the current camera mode object as OrbitCameraMode:
LocalCamera.getCameraModeObjectAs(OrbitCameraMode);
overrideCameraFOV(fov, options)
Set the field of view of the camera.

Signature
overrideCameraFOV(fov: number, options?: CameraTransitionOptions): Promise<CameraTransitionEndReason>;
Parameters
fov: numberThe new field of view value to transition towards.
options: CameraTransitionOptions(Optional) Optional properties that define how the previous field of view should transition to the new one. If not set, the transition is instant.
Returns
Promise<CameraTransitionEndReason>
Examples
Adjust the camera field of view to 50 over a period of 1 second.
localCamera.overrideCameraFOV(50.0, {duration: 1.0);
Remarks
Prevents the native camera from adjusting the field of view automatically, until Camera.resetCameraFOV() is called. For example, the third person camera zooms in a little while you sprint.
resetCameraFOV(options)
Clears any field of view override, resetting it to the default native camera value.

Signature
resetCameraFOV(options?: CameraTransitionOptions): Promise<CameraTransitionEndReason>;
Parameters
options: CameraTransitionOptions(Optional) Optional properties that define how the previous field of view should transition to the new field of view. If not set, the transition is instant.
Returns
Promise<CameraTransitionEndReason>
Examples
Reset the field of view over a period of 1 second.
localCamera.resetCameraFOV({duration: 1.0);
Remarks
Prevents the native camera from adjusting the field of view automatically until Camera.resetCameraFOV() is called. For example, the third person camera zooms in a little while the player sprints.
setCameraModeAttach(target, options)
Enables attach mode for a camera, which automatically follows a target entity's position and rotation.

Signature
setCameraModeAttach(target: CameraTarget, options?: AttachCameraOptions & CameraTransitionOptions): Promise<CameraTransitionEndReason>;
Parameters
target: CameraTargetThe entity for the tracking camera to follow.
options: AttachCameraOptions & CameraTransitionOptions(Optional) If not set, the camera instantly matches the target's position and rotation.
Returns
Promise<CameraTransitionEndReason>
Examples
Place the camera at a fixed position relative to the player, over a period of 1 second.
localCamera.setCameraModeAttach(player, {positionOffset = position, duration: 1.0});
Remarks
If the target entity is destroyed, camera tracking stops with the camera remaining where it was before losing the target. This method has no effect in VR, where only first person cameras are permitted.
setCameraModeFirstPerson(options)
Enables the standard first-person game camera, which uses a camera view from the eyes of the player avatar.

Signature
setCameraModeFirstPerson(options?: CameraTransitionOptions): Promise<CameraTransitionEndReason>;
Parameters
options: CameraTransitionOptions(Optional) Optional properties that define how the previous camera should transition to this new camera. If not set, the transition is instant.
Returns
Promise<CameraTransitionEndReason>
Examples
Enable the first person camera after a delay of 1 second.
localCamera.setCameraModeFirstPerson({delay: 1.0});
Remarks
Disables any previously set camera. Ignores the current value of Camera.perspectiveSwitchingEnabled. Has no effect in VR, where first person is always enabled.
setCameraModeFixed(options)
Sets the current camera to a fixed world position and rotation.

Signature
setCameraModeFixed(options?: FixedCameraOptions & CameraTransitionOptions): Promise<CameraTransitionEndReason>;
Parameters
options: FixedCameraOptions & CameraTransitionOptions(Optional) If not set, the camera remains fixed in place from it's current position and orientation.
Returns
Promise<CameraTransitionEndReason>
Examples
Example 1
Move the camera to a new position over a period of 1 second, maintaining its current orientation.
localCamera.setFixedCameraPosition({position: pos}, {duration: 1.0});
Example 2
Keep the camera where it currently is, but point it straight downwards instantly.
localCamera.setFixedCameraPosition({lookAt: getCameraPos() + new Vec3(0,-1,0)});
setCameraModeOrbit(options)
Enables the orbit camera, which follows the local player avatar.

Signature
setCameraModeOrbit(options?: OrbitCameraOptions & CameraTransitionOptions): Promise<CameraTransitionEndReason>;
Parameters
options: OrbitCameraOptions & CameraTransitionOptions(Optional) Optional properties that define how the previous camera should transition to this new camera. If not set, the transition is instant.
Returns
Promise<CameraTransitionEndReason>
Examples
Enable the orbit camera after a delay of 1 second.
localCamera.setCameraModeOrbit({delay: 1.0});
Remarks
Disables any previously set camera. Ignores the current value of . and has no effect in VR where only first person is allowed.
setCameraModePan(options)
Enables the pan camera, which follows the local player avatar at a fixed vector offset.

Signature
setCameraModePan(options?: PanCameraOptions & CameraTransitionOptions): Promise<CameraTransitionEndReason>;
Parameters
options: PanCameraOptions & CameraTransitionOptions(Optional) Optional properties that define how the previous camera should transition to this new camera. If not set, the transition is instant.
Returns
Promise<CameraTransitionEndReason>
Examples
Enable the pan camera after a delay of 1 second.
localCamera.setCameraModePan({delay: 1.0});
Remarks
Disables any previously set camera. Ignores the current value of . and has no effect in VR where only first person is allowed.
setCameraModeThirdPerson(options)
Enables the standard third-person game camera, which follows the local player avatar.

Signature
setCameraModeThirdPerson(options?: CameraTransitionOptions): Promise<CameraTransitionEndReason>;
Parameters
options: CameraTransitionOptions(Optional) Optional properties that define how the previous camera should transition to this new camera. If not set, the transition is instant.
Returns
Promise<CameraTransitionEndReason>
Examples
Enable the third person over a period of 1 second.
localCamera.setCameraModeThirdPerson({duration: 1.0});
Remarks
Disables any previously set camera, ignores the current value of Camera.perspectiveSwitchingEnabled, and has no effect in VR where only first person is allowed.
setCameraRollWithOptions(rollAngle, options)
Adjusts the current camera roll over time.

Signature
setCameraRollWithOptions(rollAngle: number, options?: CameraTransitionOptions): Promise<CameraTransitionEndReason>;
Parameters
rollAngle: numberThe roll rotation, in degrees, to set on the the current camera.
options: CameraTransitionOptions(Optional) Optional properties that define how the previous roll should transition to the new roll. If not set, the transition is instant.
Returns
Promise<CameraTransitionEndReason>
Examples
Roll the camera by 10 degrees left over 1 second.
localCamera.setCameraRoll(-10, {duration: 1.0});

FirstPersonCameraMode Class
Extends ICameraMode
Manipulates runtime properties of cameras in first person mode, which uses a camera view from the eyes of the player avatar.
Signature
export declare class FirstPersonCameraMode implements ICameraMode
Remarks
The Camera.setCameraModeFirstPerson() method enables first person camera mode. For more information on setting camera modes at runtime, see the Camera guide.
FixedCameraMode Class
Extends ICameraMode
Manipulates runtime properties of cameras in fixed camera mode, where the camera view is set to a fixed world position and rotation.
Signature
export declare class FixedCameraMode implements ICameraMode
Remarks
The Camera.setCameraModeFixed() method enables fixed camera mode. For more information on setting camera modes at runtime, see the Camera guide.
OrbitCameraMode Class
Extends ICameraMode
Manipulates runtime properties of cameras in orbit mode, where camera view follows the player avatar without being fixed behind the player.
Signature
export declare class OrbitCameraMode implements ICameraMode
Remarks
The Camera.setCameraModeOrbit() method enables orbit mode. For more information on setting camera modes at runtime, see the Camera guide.
Properties
distance
Camera rotation radius around the target.

Signature
distance: HorizonProperty<number>;
rotationSpeed
Controls how quickly the camera rotates to the desired rotation. If not set, the camera is always snapped to it instantly.

Signature
rotationSpeed: HorizonProperty<number | null>;
translationSpeed
Controls how quickly the camera moves to the desired position. If not set, the camera is always snapped to it instantly.

Signature
translationSpeed: HorizonProperty<number | null>;
verticalOffset
Vertical offset up from the target position. Camera rotates around the offsetted point

Signature
verticalOffset: HorizonProperty<number>;

PanCameraMode Class
Extends ICameraMode
Manipulates runtime properties of cameras in pan camera mode. In pan camera mode, the camera follows the player at a fixed position that you set adjacent to the player.
Signature
export declare class PanCameraMode implements ICameraMode
Remarks
The Camera.setCameraModePan() method enables pan camera mode. For more information on setting camera modes at runtime, see the Camera guide.
Properties
positionOffset
Local offset from the target position. Camera keeps looking at target.

Signature
positionOffset: HorizonProperty<Vec3>;
translationSpeed
Controls how quickly the camera moves to the desired position. If not set, the camera is always snapped to it instantly.

Signature
translationSpeed: HorizonProperty<number | null>;

ThirdPersonCameraMode Class
Extends ICameraMode
Manipulates runtime properties of cameras in third person mode, which uses a camera view that follows the local player avatar.
Signature
export declare class ThirdPersonCameraMode implements ICameraMode
Remarks
The Camera.setCameraModeThirdPerson() method enables third person camera mode. For more information on setting camera modes at runtime, see the Camera guide.
CameraMode Enum
The view modes for cameras.
Signature
export declare enum CameraMode
Enumeration Members


Member
Value
Description
Attach
2


FirstPerson
0


Fixed
3


Orbit
4


Pan
5


ThirdPerson
1



CameraTransitionEndReason Enum
The possible reasons for a camera transition to end.
Signature
export declare enum CameraTransitionEndReason
Enumeration Members


Member
Value
Description
Completed
0


Error
2


Interrupted
1



Easing Enum
The styles for camera transitions.
Signature
export declare enum Easing
Enumeration Members


Member
Value
Description
EaseIn
0


EaseInOut
2


EaseOut
1


Linear
3



ICameraMode Interface
The base interface for manipulating camera mode properties.
Signature
export interface ICameraMode
AttachCameraOptions type
Options used to determine the bahavior of a camera in attached mode.
Signature
export declare type AttachCameraOptions = {
    positionOffset?: Vec3;
    rotationOffset?: Vec3 | Quaternion;
    translationSpeed?: number;
    rotationSpeed?: number;
};
Remarks
Type Parameters:
A camera in attached mode is locked to a position relative to the target's position, with a rotation relative to the target's rotation.
positionOffset - The local space offset relative to the target. If not set, the camera is attached directly to the target's position.
rotationOffset - The local space rotation relative to the target. If not set, the camera faces the same direction as the target.
translationSpeed - Controls how quickly the camera moves with the target it's attached to. If not set, the camera is always snapped to the position offset from the target.
rotationSpeed - Controls how quickly the camera rotates to keep the target in view. If not set, the camera always points in the same direction the target is facing.
CameraTarget type
The camera target type used by a camera in attached mode.
Signature
export declare type CameraTarget = Entity | Player;
CameraTransitionOptions type
The options for transitioning between cameras.
Signature
export declare type CameraTransitionOptions = {
    delay?: number;
    duration?: number;
    easing?: Easing;
};
References
Easing
Remarks
Type Parameters:
delay - The time, in seconds, to wait until the transition begins. Defaults to 0.
duration - The time, in seconds, to transition from the previous camera to the new local camera. If not set, the transition is instant.
Easing - The style in which the transition from the previous to the new camera occurs over time. Defaults to Linear.
FixedCameraOptions type
The available options to apply when activating a fixed camera.
Signature
export declare type FixedCameraOptions = {
    position?: Vec3;
    rotation?: Quaternion;
};
Remarks
Type Parameters:
position - (Vec3) The position in world space to set the camera to. If not set, the camera will maintain it's current position.
rotation - The rotation for the camera to face. If not set, the camera maintains its current rotation.
OrbitCameraOptions type
Available options when applying an orbit camera.
Signature
export declare type OrbitCameraOptions = {
    distance?: number;
    verticalOffset?: number;
    translationSpeed?: number;
    rotationSpeed?: number;
};
Remarks
Type Parameters:
distance - (number) The distance from the target to the camera. If not set, the camera remains at its current distance. Default = 5.0
verticalOffset - Vertical offset up from the target position. Camera rotates around the offsetted point
translationSpeed - Controls how quickly the camera moves to the desired position. If not set, the camera is always snapped to it instantly.
rotationSpeed - Controls how quickly the camera rotates to the desired rotation. If not set, the camera is always snapped to it instantly.
PanCameraOptions type
Available options when applying a pan camera.
Signature
export declare type PanCameraOptions = {
    positionOffset?: Vec3;
    translationSpeed?: number;
};
Remarks
Type Parameters:
positionOffset - (number) The distance from the target to the camera. If not set, the camera remains at its current distance. Default = 5.0
translationSpeed - Controls how quickly the camera moves with the target it's attached to. If not set, the camera is always snapped to the position offset from the target.
ApiName Variable
The name of the camera API.
Signature
ApiName = "camera"
LocalCamera Variable
Global camera instance.
Signature
LocalCamera: Camera
BaseTestComponent Class
Extends Component<TComponent>
Used only in internal tests for compatability between the v1 and v2 APIs.
Signature
export declare abstract class BaseTestComponent<_TProps extends unknown, TComponent extends ComponentWithConstructor<Record<string, unknown>>> extends Component<TComponent>
Component Class
Extends DisposableObject
The core class for creating new types of components and attaching functionality to entities in a world.
Signature
export declare abstract class Component<TComponent = ComponentWithConstructor<Record<string, unknown>>, TSerializableState extends SerializableState = SerializableState> implements DisposableObject
Examples
In the following example, the NpcItem class extends the Component class to define a new type of component. The new component type is then registered so new instances of the NpcItem can be created in the world.
import * as hz from 'horizon/core';

class NpcItem extends hz.Component<typeof NpcItem> {
  static propsDefinition = {};

  start() {}
}
hz.Component.register(NpcItem);
Remarks
The Component class is an abstract class that you can extend to create new types of components that add properties and functionality to entities in your world. It provides properties and methods that manage the lifecycle of components, their relationship with attached entities, internal component data, and access to events including code block events.
When you create a new component in Desktop Editor, the editor generates a script that includes the following elements:
Component.propsDefinition - Defines internal properties for the class, which are also added to the Properties panel in Desktop Editor.
Component.start() - The method that executes when the class initially loads. This is where you can add event listeners that need to run when the script starts running.
Component.register() - The method that registers the new component class as a component definition that can be used to generate instances of the component in your world.
For more information about using components, see the Intro to Scripting tutorial, and the TypeScript Components, Properties, and Variables guide.
Properties
async
A set of asynchronous helper functions that are scoped to the component for automatic cleanup on dispose.

Signature
async: {
        setTimeout: (callback: TimerHandler, timeout?: number, ...args: unknown[]) => number;
        clearTimeout: (id: number) => void;
        setInterval: (callback: TimerHandler, timeout?: number, ...args: unknown[]) => number;
        clearInterval: (id: number) => void;
    };
Remarks
setTimeout - Sets a timer that executes a function or specified piece of code once the timer expires.
clearTimeout - Cancels a timeout previously established by calling setTimeout().
setInterval - Repeatedly calls a function or executes a code snippet, with a fixed time delay between each call.
clearInterval - Cancels a timed-repeating action that was previously established by a call to setInterval.
entity
[readonly]
The entity the component is attached to.

Signature
readonly entity: Entity;
entityId
[readonly]
The ID of the entity the component is attached to.

Signature
readonly entityId: number;
props
[readonly]
The properties that modify the component.

Signature
readonly props: GetPropsFromComponentOrPropsDefinition<TComponent>;
propsDefinition
static
The set of properties that define the available input and default values of the component.

Signature
static propsDefinition: {};
world
[readonly]
The World instance that contains the component.

Signature
readonly world: World;

Methods
connectCodeBlockEvent(target, event, callback)
Called when receiving a specified code block event from a given player or entity.

Signature
connectCodeBlockEvent<TEventArgs extends BuiltInVariableType[], TCallbackArgs extends TEventArgs>(target: Entity | Player, event: CodeBlockEvent<TEventArgs>, callback: (...payload: TCallbackArgs) => void): EventSubscription;
Parameters
target: Entity | PlayerThe entity or player to listen to.
event: CodeBlockEvent<TEventArgs>The incoming CodeBlockEvent object.
callback: (...payload: TCallbackArgs) => voidCalled when the event is received with any data as arguments.
Returns
EventSubscription
Examples
This example demonstrates how to receive a built-in CodeBlock event using the connectCodeBlockEvent method.
// Import CodeBlockEvents to access Built-in Events.
import { Component, CodeBlockEvents, Player } from 'horizon/core';

class BuiltInEventExample extends Component {
  start() {
    this.connectCodeBlockEvent(
     this.entity,
     CodeBlockEvents.OnIndexTriggerDown,
     (player: Player) => {
       // Perform an action when the Index Trigger is pressed.
     }
   );
     this.connectCodeBlockEvent (
       this.entity,
       CodeBlockEvents.OnGrabEnd,
       (player: Player) => {
       // Perform another action when the Grab Action ends.
     }
   );
 }
}

Component.register(BuiltInEventExample);
connectLocalBroadcastEvent(event, listener)
Adds a listener to the specified local event. The listener is called when the event is received.

Signature
connectLocalBroadcastEvent<TPayload extends LocalEventData>(event: LocalEvent<TPayload>, listener: (payload: TPayload) => void): EventSubscription;
Parameters
event: LocalEvent<TPayload>The local event to listen to.
listener: (payload: TPayload) => voidCalled when the event is received with any data as arguments.
Returns
EventSubscription
connectLocalEvent(target, event, callback)
Adds a listener to the local event on the given entity. The listener is called when the event is received.

Signature
connectLocalEvent<TPayload extends LocalEventData>(target: Entity | Player, event: LocalEvent<TPayload>, callback: (payload: TPayload) => void): EventSubscription;
Parameters
target: Entity | PlayerThe entity to listen to.
event: LocalEvent<TPayload>The local event.
callback: (payload: TPayload) => voidCalled when the event is received with any data as arguments.
Returns
EventSubscription
connectNetworkBroadcastEvent(event, callback)
Adds a listener to the specified network event. The listener is called when the event is received from the network.

Signature
connectNetworkBroadcastEvent<TPayload extends NetworkEventData>(event: NetworkEvent<TPayload>, callback: (payload: TPayload) => void): EventSubscription;
Parameters
event: NetworkEvent<TPayload>The network event to listen to.
callback: (payload: TPayload) => voidCalled when the event is received with any data as arguments.
Returns
EventSubscription
connectNetworkEvent(target, event, callback)
Adds a listener to the specified network event on the given entity. The listener is called when the event is received from network.

Signature
connectNetworkEvent<TPayload extends NetworkEventData>(target: Entity | Player, event: NetworkEvent<TPayload>, callback: (payload: TPayload) => void): EventSubscription;
Parameters
target: Entity | PlayerThe entity or player to listen to.
event: NetworkEvent<TPayload>The network event.
callback: (payload: TPayload) => voidCalled when the event is received with any data as arguments.
Returns
EventSubscription
dispose()
Called when the component is cleaned up.

Signature
dispose(): void;
Returns
void
Remarks
Subscriptions registered using , , , and are cleaned up automatically.
getComponents(type) static
Returns a list of all script component instances of the specified type in the world. Only returns script component instances if they're executing in the same context (i.e. On the server or on a particular client). This method should not be used in prestart() as other script component instances may not yet be instantiated.

Signature
static getComponents<T extends Component<unknown, SerializableState> = Component>(type: new () => T): T[];
Parameters
type: new () => TThe specified type of Component.
Returns
T[]A list of all active instances of the specified component type in the current execution context (i.e., on the server or on a particular client).
preStart()
Performs initialization tasks before the method is called.

Signature
preStart(): void;
Returns
void
Remarks
This method runs in these scenarios as follows:
World start: preStart runs for all components before the start method of any component is called. Asset spawn: preStart runs before any start methods are called for any components that are spawning. Ownership transfer: preStart is called directly before the start method is called.
receiveOwnership(_serializableState, _oldOwner, _newOwner)
Called when the script's ownership is being transferred to a new player. This method allows the new owner to receive the serializable state from the previous owner during ownership transfer.

Signature
receiveOwnership(_serializableState: TSerializableState | null, _oldOwner: Player, _newOwner: Player): void;
Parameters
_serializableState: TSerializableState | nullThe serializable state from prior owner, or null if that state is invalid.
_oldOwner: PlayerThe prior owner.
_newOwner: PlayerThe current owner.
Returns
void
Examples
type State = {ammo: number};
class WeaponWithAmmo extends Component<typeof WeaponWithAmmo, State> {
  static propsDefinition = {
    initialAmmo: {type: PropTypes.Number, default: 20},
  };
  private ammo: number = 0;
  start() {
    this.ammo = this.props.initialAmmo;
  }
  receiveOwnership(state: State | null, fromPlayer: Player, toPlayer: Player) {
    this.ammo = state?.ammo ?? this.ammo;
  }
  transferOwnership(fromPlayer: Player, toPlayer: Player): State {
    return {ammo: this.ammo};
  }
}
Remarks
When changing entity ownership to a new player, you must transfer the state of the entity as well or the state will be lost. You can use the Component.transferOwnership() and Component.receiveOwnership() methods to transfer an entity's state to a new owner. For more information, see Maintaining local state on ownership change.
If ownership for a parent entity changes, the ownership change doesn't automatically apply to any child entities.
register(componentClass, componentName) static
Registers a component class as a component definition that is used to instantiate components of the given type, which also allows them to be attached to entities.

Signature
static register<TComponentPropsDefinition>(componentClass: // this needs to be typed with the interface type so we know it can be instantiated (is not abstract)
    ComponentWithConstructor<TComponentPropsDefinition> & typeof Component<ComponentWithConstructor<TComponentPropsDefinition>>, componentName?: string): void;
Parameters
componentClass: ComponentWithConstructor<TComponentPropsDefinition> & typeof Component<ComponentWithConstructor<TComponentPropsDefinition>>The component class to register.
componentName: string(Optional) The name of component to display in the UI.
Returns
void
Examples
In this example, the NpcItem class is registered as a component definition.
hz.Component.register(NpcItem);
Remarks
Component registry is required when you create new classes that extend the abstract Component class.
registerDisposeOperation(operation)
Called to register a single operation. The operation runs automatically when the component is disposed unless it is manually run or canceled before the component is disposed.

Signature
registerDisposeOperation(operation: DisposeOperation): DisposeOperationRegistration;
Parameters
operation: DisposeOperationA function called to perform a single dispose operation.
Returns
DisposeOperationRegistrationA registration object that can be used to manually run or cancel the operation before dispose.
sendCodeBlockEvent(target, event, args)
Sends a code block event to the specified player or entity. These events are networked automatically, and sent and handled asynchronously.

Signature
sendCodeBlockEvent<TPayload extends BuiltInVariableType[]>(target: Entity | Player, event: CodeBlockEvent<TPayload>, ...args: TPayload): void;
Parameters
target: Entity | PlayerThe entity or player that receives the event.
event: CodeBlockEvent<TPayload>The CodeBlockEvent that represents the event.
args: TPayloadThe data to send with the event.
Returns
void
sendLocalBroadcastEvent(event, data)
Sends a local event to all listeners.
If a local event is sent, it is sent immediately. This function does not return until delivery completes.

Signature
sendLocalBroadcastEvent<TPayload extends LocalEventData, TData extends TPayload>(event: LocalEvent<TPayload>, data: TData): void;
Parameters
event: LocalEvent<TPayload>The local event to send.
data: TData
Returns
void
sendLocalEvent(target, event, data)
Sends a local event to a specific entity from the owner of the entity.

Signature
sendLocalEvent<TPayload extends LocalEventData, TData extends TPayload>(target: Entity | Player, event: LocalEvent<TPayload>, data: TData): void;
Parameters
target: Entity | PlayerThe entity that receives the event.
event: LocalEvent<TPayload>The local event to send.
data: TData
Returns
void
Remarks
The event is sent immediately and this function does not return until delivery completes.
sendNetworkBroadcastEvent(event, data, players)
Broadcasts a network event. The event is only handled if the host listens to the event.

Signature
sendNetworkBroadcastEvent<TPayload extends NetworkEventData>(event: NetworkEvent<TPayload>, data: TPayload, players?: Array<Player>): void;
Parameters
event: NetworkEvent<TPayload>The network event to broadcast.
data: TPayloadThe data to send with the event. the maximum amount data supported after serialization is 63kB.
players: Array<Player>(Optional) The list of players devices to send the event to. If you do not specify this parameter, the event is sent to all devices owned by the player. You should only use this parameter if you are familiar with how it works.
Returns
void
sendNetworkEvent(target, event, data, players)
Sends a network event to the player that owns the given entity.

Signature
sendNetworkEvent<TPayload extends NetworkEventData>(target: Entity | Player, event: NetworkEvent<TPayload>, data: TPayload, players?: Array<Player>): void;
Parameters
target: Entity | PlayerThe player or entity that recieves the event.
event: NetworkEvent<TPayload>The network event.
data: TPayloadThe data to send with the event. the maximum amount data after serialization is 63kB.
players: Array<Player>(Optional) The list of player devices to send the event to. If you don't specify this parameter, the event is sent to all devices owned by the player. You should only use specify this parameter if you understand it well.
Returns
void
Remarks
The event is only handled if is called on the same entity on the owner client.
start() abstract
Called when the component starts running. This is where you can add event listeners that need to run when the script starts running.

Signature
abstract start(): void;
Returns
void
transferOwnership(_oldOwner, _newOwner)
Called when transferring the script's ownership to a new player. During the transer, this method can condense the previous owner's state into a serializable format and pass it to the new owner.

Signature
transferOwnership(_oldOwner: Player, _newOwner: Player): TSerializableState;
Parameters
_oldOwner: PlayerThe original owner.
_newOwner: PlayerThe new owner.
Returns
TSerializableStateThe serializable state to transfer to the new owner.
Examples
type State = {ammo: number};
class WeaponWithAmmo extends Component<typeof WeaponWithAmmo, State> {
  static propsDefinition = {
    initialAmmo: {type: PropTypes.Number, default: 20},
  };
  private ammo: number = 0;
  start() {
    this.ammo = this.props.initialAmmo;
  }
  receiveOwnership(state: State | null, fromPlayer: Player, toPlayer: Player) {
    this.ammo = state?.ammo ?? this.ammo;
  }
  transferOwnership(fromPlayer: Player, toPlayer: Player): State {
    return {ammo: this.ammo};
  }
}
Remarks
When changing entity ownership to a new player, you must transfer the state of the entity as well or the state will be lost. You can use the Component.transferOwnership() and Component.receiveOwnership() methods to transfer an entity's state to a new owner. For more information, see Maintaining local state on ownership change.
If ownership for a parent entity changes, the ownership change doesn't automatically apply to any child entities.

AIAgentGizmo Class
Extends Entity
Represents an AI Agent gizmo, which enables NPCs and objects to use locomotion and pathfinding capabilities, and optionally be embodied by an avatar.
Signature
export declare class AIAgentGizmo extends Entity
Remarks
For more information about using NPCs, see the NPC guide.
Methods
toString()
Creates a human-readable representation of the AIAgentGizmo.

Signature
toString(): string;
Returns
stringA string representation of the AIAgentGizmo.

AchievementsGizmo Class
Extends Entity
Represents an Achievements gizmo, which is used to display player achievements.
Signature
export declare class AchievementsGizmo extends Entity
Remarks
For information about working with Player Achievements, see the Player Ahievements guide.
Methods
displayAchievements(achievementScriptIDs)
Displays a list of the given player achievements.

Signature
displayAchievements(achievementScriptIDs: Array<string>): void;
Parameters
achievementScriptIDs: Array<string>A list that contains the script IDs of the achievements to display.
Returns
void
toString()
Creates a human-readable representation of the entity.

Signature
toString(): string;
Returns
stringA string representation of the AchievementsGizmo.

AnimatedEntity Class
Extends Entity
Represents an entity that that can be animated by a transform.
Signature
export declare class AnimatedEntity extends Entity
Methods
pause()
Pauses the animation.

Signature
pause(): void;
Returns
void
play()
Starts the animation for the entity.

Signature
play(): void;
Returns
void
stop()
Stop the animation.

Signature
stop(): void;
Returns
void
toString()
Creates a human-readable representation of the AnimatedEntity.

Signature
toString(): string;
Returns
stringA string representation of the AnimatedEntity.

Asset Class
Represents an asset in Horizon Worlds. An asset is a set of objects and scripts you can store in an asset library outside of a world instance, and then spawn into the world at runtime.
Signature
export declare class Asset
Remarks
Assets are stored in asset libraries that you can view and manage in Desktop Editor. The SpawnController class provides a container for managing asset spawning and despsawning at runtime.
Asset spawning excels when spawning smaller sets of dynamic content, or content that needs to spawn at different locations in a world. For larger sets of static content that always spawns at the same location in the world, the world streaming API provides more optimal performance.
For information spawning and despawning assets, see the guide Introduction to Asset Spawning.
Constructors
(constructor)(id, versionId)
Creates an instance of Asset.

Signature
constructor(id: bigint, versionId?: bigint);
Parameters
id: bigintThe ID of the asset.
versionId: bigint(Optional) The version of the asset.

Properties
id
[readonly]
The ID of the asset.

Signature
readonly id: bigint;
versionId
[readonly]
The version of the asset.

Signature
readonly versionId: bigint;

Methods
as(assetClass)
Creates an instance of Asset with the given ID.

Signature
as<T extends Asset>(assetClass: Class<[bigint, bigint], T>): T;
Parameters
assetClass: Class<[bigint, bigint], T>The class to instantiate for this asset.
Returns
TThe new object.
fetchAsData(options)
Retrieves the raw content of the asset, such as a text asset.

Signature
fetchAsData(options?: Partial<FetchAsDataOptions>): Promise<AssetContentData>;
Parameters
options: Partial<FetchAsDataOptions>(Optional) The optional settings for the asset.
Returns
Promise<AssetContentData>An AssetContentData object that stores the raw asset content and can return it in formats that are easier to use.
Remarks
Use this method to retrieve large amounts of data to populate the world. Not all assets can be parsed as data. Before calling this function, you must upload the asset to the asset library.
The first time you fetch the asset content, it is loaded locally in the cache. This increases the speed of additional fetch attempts, which retrieve the data from the cache by default. In rare cases, the asset is updated outside of the world instance while the instance is running. In that case, you may want to ignore the cache and retrieve the updated data directly from the server.
In the options parameter, this method provides an optional skipCache setting, which enables you to ignore the local cache when retrieving the asset content. You should not enable this feature unless the content was already updated while the world instance is live; otherwise, it will degrade the performance of your world.
toJSON()
Specifies data to serialize as JSON.

Signature
toJSON(): {
        id: bigint;
        versionId: bigint;
        _hzType: string;
    };
Returns
{ id: bigint; versionId: bigint; _hzType: string; }A valid object that can be serialized as JSON.
toString()
Creates a human-readable representation of the object.

Signature
toString(): string;
Returns
stringA string representation of the object

AssetContentData Class
Parses and stores the raw content of an asset.
Signature
export declare class AssetContentData
Remarks
Not all assets can be retrieved as raw data. The asset is stored as a string currently. If you are using this as a JSON regularly, we currently recommend that you cache the JSON. Otherwise you should cache the object itself.
Constructors
(constructor)(assetContentData)
Constructs a new instance of this class.

Signature
constructor(assetContentData: Array<string>);
Parameters
assetContentData: Array<string>The content of the Asset.

Methods
asJSON()
Parse the raw contents of the asset and returns it as a JSON object. template T Provides an interface type for the JSON object to return. For example "interface JSONData { a: string; b: string; }". Leave this as empty if you want a generic JSON object.

Signature
asJSON<T = JSON>(): T | null;
Returns
T | nullA generic JSON object or a JSON object that uses a specific interface type. returns null if the content doesn't use JSON or the provided generic type.
asText()
Gets the content of the Asset as a string.

Signature
asText(): string;
Returns
stringThe raw content of the Asset as a string.

AttachableEntity Class
Extends Entity
Represents an entity that can be attached to other entities.
Signature
export declare class AttachableEntity extends Entity
Properties
socketAttachmentPosition
The socket attachment position offset applied to the AttachableEntity when using Anchor attachment mode.

Signature
socketAttachmentPosition: HorizonProperty<Vec3>;
socketAttachmentRotation
The socket attachment rotation offset applied to the AttachableEntity when using Anchor attachment mode.

Signature
socketAttachmentRotation: HorizonProperty<Quaternion>;

Methods
attachToPlayer(player, anchor)
Attaches the entity to a player.

Signature
attachToPlayer(player: Player, anchor: AttachablePlayerAnchor): void;
Parameters
player: PlayerThe player to attach the entity to.
anchor: AttachablePlayerAnchorThe attachment point to use.
Returns
void
detach()
Releases an attachment to a player.

Signature
detach(): void;
Returns
void
toString()
Creates a human-readable representation of the object.

Signature
toString(): string;
Returns
stringA string representation of the object

AudioGizmo Class
Extends Entity
Represents an audio gizmo in the world.
Signature
export declare class AudioGizmo extends Entity
Properties
pitch
The audio pitch in semitones, which ranges from -24 to 24.

Signature
pitch: WritableHorizonProperty<number>;
volume
The audio volume, which ranges from 0 (no sound) to 1 (full volume).

Signature
volume: WritableHorizonProperty<number, AudioOptions>;

Methods
pause(audioOptions)
Pauses an AudioGizmo sound.

Signature
pause(audioOptions?: AudioOptions): void;
Parameters
audioOptions: AudioOptions(Optional) Controls how the audio is paused.
Returns
void
Examples
const soundGizmo = this.props.sfx.as(hz.AudioGizmo);
const audioOptions: AudioOptions = {fade: 1, players: [player1, player2]};
soundGizmo.pause(audioOptions);
play(audioOptions)
Plays an AudioGizmo sound.

Signature
play(audioOptions?: AudioOptions): void;
Parameters
audioOptions: AudioOptions(Optional) Controls how the audio is played.
Returns
void
Examples
const soundGizmo = this.props.sfx.as(hz.AudioGizmo);
const audioOptions: AudioOptions = {fade: 1, players: [player1, player2]};
soundGizmo.play(audioOptions);
stop(audioOptions)
Stops an AudioGizmo sound.

Signature
stop(audioOptions?: AudioOptions): void;
Parameters
audioOptions: AudioOptions(Optional) Controls how the audio is played.
Returns
void
Examples
const soundGizmo = this.props.sfx.as(hz.AudioGizmo);
const audioOptions: AudioOptions = {fade: 1, players: [player1, player2]};
soundGizmo.stop(audioOptions);
toString()
Creates a human-readable representation of the audio gizmo.

Signature
toString(): string;
Returns
stringA string representation of the audio gizmo.

CodeBlockEvent Class
Represents an event sent locally or over a network within the code block scripting system. These events only supports predefined serializable types and are primarily used to interact with scripting events from a world.
Signature
export declare class CodeBlockEvent<T extends BuiltInVariableType[]>
Examples
Example 1
This example demonstrates how to create a custom code block event and send it to code blocks.
import { Component, *CodeBlockEvent*, Entity, PropTypes } from 'horizon/core';

class CodeBlockEvent_CB extends Component<typeof CodeBlockEvent_CB> {

  static propsDefinition= {
    target: {type: PropTypes.Entity},
  };

  sendEvent = new CodeBlockEvent<[player_name: String, player_id: Number]>('sendEvent', [PropTypes.String, PropTypes.Number]);
  receiveEvent = new CodeBlockEvent<[score: Number]>('receiveEvent', [PropTypes.Number]);

  start() {
    // Register for CodeBlock events.
    this.connectCodeBlockEvent(
    this.entity,
    this.receiveEvent,
    (score: Number) => {
       console.log(score);
     });

    // Delay by 500 milliseconds to ensure listeners are ready.
    this.async.setTimeout(() => {
      this.sendCodeBlockEvent(
        this.props.target!,
        this.sendEvent,
        "Player One",
        123
      );
     }, 500);
    }
  }
Component.register(CodeBlockEvent_CB);
Example 2
This example demonstrates how to receive a built-in CodeBlock event using the Component.connectCodeBlockEvent() function.
// Import CodeBlockEvents to access Built-in Events.
import { Component, CodeBlockEvents, Player } from 'horizon/core';

class BuiltInEventExample extends Component {
  start() {
    this.connectCodeBlockEvent(
     this.entity,
     CodeBlockEvents.OnIndexTriggerDown,
     (player: Player) => {
       // Perform an action when the Index Trigger is pressed.
     }
   );
     this.connectCodeBlockEvent (
       this.entity,
       CodeBlockEvents.OnGrabEnd,
       (player: Player) => {
       // Perform another action when the Grab Action ends.
     }
   );
 }
}

Component.register(BuiltInEventExample);
Remarks
A code block event is a legacy event that doesn't perform as well as a local event or a network event. You should only use the CodeBlockEvent class to interact with world scripting events.
You can create, send, and receive custom code block events, or subscribe to built-in code block events defined in the CodeBlockEvents variable.
For information about using code block events, see the Code Block Events guide.
Constructors
(constructor)(name, expectedTypes)
Creates a CodeBlockEvent object.

Signature
constructor(name: string, expectedTypes: ConstrainedPropTypes<T> | []);
Parameters
name: stringThe name of the event.
expectedTypes: ConstrainedPropTypes<T> | []The list of possible event types.
Remarks
Each of these types defines the parameters for the event and must be of type PropTypes.

Properties
expectedTypes
A list of possible types of the event.

Signature
expectedTypes: ConstrainedPropTypes<T> | [];
name
The name of the event.

Signature
name: string;

Color Class
Extends Comparable<Color>
Represents an RGB color.
Signature
export declare class Color implements Comparable<Color>
Constructors
(constructor)(r, g, b)
Creates an RGB color object.

Signature
constructor(r: number, g: number, b: number);
Parameters
r: numberThe red component of the RGB color as a float from 0 to 1.
g: numberThe green component of the RGB color as a float from 0 to 1.
b: numberThe blue component of the RGB color as a float from 0 to 1.

Properties
b
The blue component of the RGB color.

Signature
b: number;
black
static
[readonly]
Creates a black RGB color.

Signature
static get black(): Color;
blue
static
[readonly]
Creates a blue RGB color.

Signature
static get blue(): Color;
g
The green component of the RGB color.

Signature
g: number;
green
static
[readonly]
Creates a green RGB color.

Signature
static get green(): Color;
r
The red component of the RGB color.

Signature
r: number;
red
static
[readonly]
Creates a red RGB color.

Signature
static get red(): Color;
white
static
[readonly]
Creates a white RGB color.

Signature
static get white(): Color;

Methods
add(color)
Adds two RGB colors, returning a new RGB color.

Signature
static add(colorA: Color, colorB: Color, outColor?: Color): Color;
Parameters
colorA: ColorThe first RGB color to add.
colorB: ColorThe second color to add.
outColor: Color(Optional) The RGB color as a result of the operation. If not supplied, a new RGB color is created and returned.
Returns
ColorA new RGB color, if outColor is not supplied.
add(colorA, colorB, outColor) static
Adds two RGB colors, returning a new RGB color.

Signature
static add(colorA: Color, colorB: Color, outColor?: Color): Color;
Parameters
colorA: ColorThe first RGB color to add.
colorB: ColorThe second color to add.
outColor: Color(Optional) The RGB color as a result of the operation. If not supplied, a new RGB color is created and returned.
Returns
ColorA new RGB color, if outColor is not supplied.
addInPlace(color)
Adds an RGB color to the current RGB color, modifying the original color in place.

Signature
addInPlace(color: Color): this;
Parameters
color: ColorThe RGB color to add.
Returns
this
clone()
Clones the current RGB color's values into a mutable RGB color object.

Signature
clone(): Color;
Returns
Colora mutable RGB color with the same r, g, b values.
componentMul(color)
Creates an RGB color by multiplying each component of the current RGB color with the input RGB color's component.

Signature
componentMul(color: Color): Color;
Parameters
color: ColorThe RGB color to multiply.
Returns
ColorA new RGB color.
componentMulInPlace(color)
Multiplies the current RGB color's components by the specified RGB color's components, modifying the original RGB color in place.

Signature
componentMulInPlace(color: Color): this;
Parameters
color: ColorThe RGB color to multiply by.
Returns
this
copy(color)
Sets the current RGB color to the specified RGB color.

Signature
copy(color: Color): this;
Parameters
color: ColorThe specified RGB color.
Returns
this
div(scalar)
Performs scalar division on an RGB color, returning a new RGB color.

Signature
static div(color: Color, scalar: number, outColor?: Color): Color;
Parameters
color: ColorThe RGB color to scale.
scalar: numberThe value to scale the RGB color by.
outColor: Color(Optional) The new color as a result of the operation. If not supplied, a new 3D vector is created and returned.
Returns
ColorA new RGB color.
div(color, scalar, outColor) static
Performs scalar division on an RGB color, returning a new RGB color.

Signature
static div(color: Color, scalar: number, outColor?: Color): Color;
Parameters
color: ColorThe RGB color to scale.
scalar: numberThe value to scale the RGB color by.
outColor: Color(Optional) The new color as a result of the operation. If not supplied, a new 3D vector is created and returned.
Returns
ColorA new RGB color.
divInPlace(scalar)
Divides an RGB color's components by a scalar value, modifying the original RGB color in place.

Signature
divInPlace(scalar: number): this;
Parameters
scalar: numberThe value to scale the color by.
Returns
this
equals(color)
Determines whether two RGB colors are equal.

Signature
static equals(colorA: Color, colorB: Color): boolean;
Parameters
colorA: ColorThe first RGB color to compare.
colorB: ColorThe second RGB color to compare.
Returns
booleantrue if the RGB colors are equal, false otherwise.
equals(colorA, colorB) static
Determines whether two RGB colors are equal.

Signature
static equals(colorA: Color, colorB: Color): boolean;
Parameters
colorA: ColorThe first RGB color to compare.
colorB: ColorThe second RGB color to compare.
Returns
booleantrue if the RGB colors are equal, false otherwise.
equalsApprox(color, epsilon)
Determines whether two RGB colors are approximately equal.

Signature
static equalsApprox(colorA: Color, colorB: Color, epsilon?: number): boolean;
Parameters
colorA: ColorThe first RGB color to compare.
colorB: ColorThe second RGB color to compare.
epsilon: number(Optional) The maximum difference in value to be considered equal.
Returns
booleantrue if the two RGB colors are approximatel equal, false otherwise.
equalsApprox(colorA, colorB, epsilon) static
Determines whether two RGB colors are approximately equal.

Signature
static equalsApprox(colorA: Color, colorB: Color, epsilon?: number): boolean;
Parameters
colorA: ColorThe first RGB color to compare.
colorB: ColorThe second RGB color to compare.
epsilon: number(Optional) The maximum difference in value to be considered equal.
Returns
booleantrue if the two RGB colors are approximatel equal, false otherwise.
fromHex(hex) static
Converts a hex code string to a Color.

Signature
static fromHex(hex: string): Color;
Parameters
hex: stringA six-character hex code string prefixed with \#, ie: "\#ff0000".
Returns
ColorA Color representing the hex value.
fromHSV(hsv) static
Creates a new RGB color from an HSV value.

Signature
static fromHSV(hsv: Vec3): Color;
Parameters
hsv: Vec3The HSV color value to convert to RGB.
Returns
ColorA new RGB color.
mul(scalar)
Performs a scalar multiplication on an RGB color, returning a new RGB color.

Signature
static mul(color: Color, scalar: number, outColor?: Color): Color;
Parameters
color: ColorThe RGB color to scale.
scalar: numberThe value to scale the RGB color by.
outColor: Color(Optional) The new color as a result of the operation. If not supplied, a new 3D vector is created and returned.
Returns
ColorA new RGB color.
mul(color, scalar, outColor) static
Performs a scalar multiplication on an RGB color, returning a new RGB color.

Signature
static mul(color: Color, scalar: number, outColor?: Color): Color;
Parameters
color: ColorThe RGB color to scale.
scalar: numberThe value to scale the RGB color by.
outColor: Color(Optional) The new color as a result of the operation. If not supplied, a new 3D vector is created and returned.
Returns
ColorA new RGB color.
mulInPlace(scalar)
Performs a scalar multiplication on the current RGB color, modifying the original RGB color in place.

Signature
mulInPlace(scalar: number): this;
Parameters
scalar: numberThe value to scale the color by.
Returns
this
sub(color)
Subtracts an RGB color from another RGB color, returning a new RGB color.

Signature
static sub(colorA: Color, colorB: Color, outColor?: Color): Color;
Parameters
colorA: ColorThe RGB color to subtract from.
colorB: ColorThe RGB color to subtract.
outColor: Color(Optional) The new color as a result of the operation. If not supplied, a new 3D vector is created and returned.
Returns
ColorA new RGB color, if outColor is not supplied.
sub(colorA, colorB, outColor) static
Subtracts an RGB color from another RGB color, returning a new RGB color.

Signature
static sub(colorA: Color, colorB: Color, outColor?: Color): Color;
Parameters
colorA: ColorThe RGB color to subtract from.
colorB: ColorThe RGB color to subtract.
outColor: Color(Optional) The new color as a result of the operation. If not supplied, a new 3D vector is created and returned.
Returns
ColorA new RGB color, if outColor is not supplied.
subInPlace(color)
Subtracts an RGB color from the current RGB color, modifying the original RGB color in place.

Signature
subInPlace(color: Color): this;
Parameters
color: ColorThe RGB color to subtract.
Returns
this
toHex()
Converts an RGB color to a Hex color code.

Signature
toHex(): #${string};
Returns
\\#${string}\The hex color code of the color.
toHSV()
Converts an RGB color to an HSV (hue, saturation, value) 3D vector.

Signature
toHSV(): Vec3;
Returns
Vec3A 3D vector, where x is the hue, y is the saturation, and z is the value of the color.
toString()
Gets a string listing the RGB color components.

Signature
toString(): string;
Returns
stringA list of the components.
toVec3()
Gets the values of the current RGB color object as a 3D vector.

Signature
toVec3(): Vec3;
Returns
Vec3

DynamicLightGizmo Class
Extends Entity
Represents a dynamic lighting gizmo in the world, which provides lighting that's calculated in real-time.
Signature
export declare class DynamicLightGizmo extends Entity
Properties
enabled
Indicates whether the entity has a dynamic light effect on it. true to enable dynamic lighting; otherwise, false.

Signature
enabled: HorizonProperty<boolean>;
falloffDistance
The light falloff distance. 0 for the least distance and 100 for the greatest distance.

Signature
falloffDistance: HorizonProperty<number>;
intensity
The light intensity. 0 for least intense and 10 for most intense.

Signature
intensity: HorizonProperty<number>;
spread
The light spread. 0 for the least light spread (none) and 100 for the greatest light spread.

Signature
spread: HorizonProperty<number>;

Methods
toString()
Creates a human-readable representation of the DynamicLightGizmo.

Signature
toString(): string;
Returns
stringA string representation of the DynamicLightGizmo.

Entity Class
An entity, which represents an object in Horizon Worlds. All objects in a world are represented by entities.
Signature
export declare class Entity
Examples
Example 1
Here's an example of an entity cast as a gizmo.
import {TextGizmo} from 'horizon/core';

const textHint = entity.as(TextGizmo);
textHint.text.set('Aim here');
Example 2
In this example, the entity is moved to a new location by setting the position property of the entity to a new 3D vector.
entity.position.set(new Vec3(50, 65, 33));
Remarks
The functionality of an entity is provided by its attached components.
The most common way for script to access an entity is by using this.entity, which refers to the entity the current component instance is attached to. Another common way is for the script to cast an entity as a gizmo, such as TextGizmo.
Scripts can also interact with external entities in the following ways:
Entity panel: If the Entity Panel of the attached entity passes in entities as properties.
Events: If an entity is sent to a script using an event, such as a CodeBlockEvent.
Spawned entities: Entities that are spawned into the world. See the Asset Spawning guide for usage.
For information about using entities, see the TypeScript Components, Properties, and Variables guide.
Constructors
(constructor)(id)
Creates an entity in the world.

Signature
constructor(id: bigint);
Parameters
id: bigintThe ID of the entity to create.

Properties
children
The child entities of the entity.

Signature
children: ReadableHorizonProperty<Entity[]>;
collidable
Indicates whether the entity is collidable. true if the entity is collidable; otherwise, false.

Signature
collidable: HorizonProperty<boolean>;
color
The color of the entity.

Signature
color: HorizonProperty<Color>;
forward
The forward vector of the entity.

Signature
forward: ReadableHorizonProperty<Vec3>;
id
[readonly]
The ID of the entity in the world.

Signature
readonly id: bigint;
interactionMode
The interaction mode for the entity, such as whether it's grabble or supports physics.

Signature
interactionMode: HorizonProperty<EntityInteractionMode>;
name
The human readable name of the entity.

Signature
name: ReadableHorizonProperty<string>;
owner
The Player that owns the entity.

Signature
owner: HorizonProperty<Player>;
Remarks
When changing entity ownership to a new player, you must transfer the state of the entity as well or the state will be lost. You can use the Component.transferOwnership() and Component.receiveOwnership() methods to transfer an entity's state to a new owner. For more information, see Maintaining local state on ownership change.
If ownership for a Entity.parent entity changes, the ownership change doesn't automatically apply to any Entity.children.
parent
The parent of the entity.

Signature
parent: ReadableHorizonProperty<Entity | null>;
position
The current position of the entity in the world.

Signature
position: HorizonProperty<Vec3>;
right
The right vector of the entity.

Signature
right: ReadableHorizonProperty<Vec3>;
rotation
The rotation component of the entity.

Signature
rotation: HorizonProperty<Quaternion>;
scale
The current scale of the entity in the world.

Signature
scale: HorizonProperty<Vec3>;
simulated
Determines whether grabbing and physics is calculated. If simulated is off, then objects aren't grabbable and aren't affected by physics.

Signature
simulated: HorizonProperty<boolean>;
tags
Use tags to annotate entities with user-defined labels that identify and match objects.

Signature
tags: HorizonSetProperty<string>;
Examples
entity.tags.set(['tag1', 'tag2']);
const tags: Array<string> = entity.tags.get();
const containsTag1: boolean = entity.tags.contains('tag1');
entity.tags.remove('tag1');
entity.tags.clear();
Remarks
You can have up to five tags per entity. Each tag can be up to 20 characters long. Tags are case sensitive. Avoid using special characters. There is no check for duplicate tags. Tags set or modified in TypeScript only presist for the session; they are not be stored in the entity.
transform
[readonly]
The transform of the entity, which contains position, rotation, and scale information.

Signature
readonly transform: Transform;
up
The up vector of the entity.

Signature
up: ReadableHorizonProperty<Vec3>;
visible
Indicates whether players with permission can see the entity. true if players with permission can see the entity; false if no players can see the entity.

Signature
visible: HorizonProperty<boolean>;
Examples
const wasVisible: boolean = cubeEntity.visible.get();
cubeEntity.visible.set(!wasVisible);
Remarks
You can set which players have permission using Entity.setVisibilityForPlayers(). It's important to note that if any parent entity has its visibility set to false, the child entity will also be invisible regardless of its own visibility setting.

Methods
as(entityClass)
Cast an entity as its more specific subclass.

Signature
as<T extends Entity>(entityClass: Class<[bigint], T>): T;
Parameters
entityClass: Class<[bigint], T>The subclass to cast entity to.
Returns
T
exists()
Indicates whether the entity exists in the world. true if the entity exists in the world; otherwise, it does not exist in the world.

Signature
exists(): boolean;
Returns
booleanA boolean that indicates whether the entity exists in the world.
getComponents(type)
Returns a list of all script component instances attached to the entity and executing in the same context as the entity.

Signature
getComponents<T extends Component<unknown, SerializableState> = Component>(type?: (new () => T) | null): T[];
Parameters
type: (new () => T) | null(Optional) The type of components to return. Otherwise, if not provided, this method returns components of any type.
Returns
T[]The script component instances of the specified type that are attached to the entity.
Remarks
This method only returns script component instances if they're executing in the same context as the entity, such as on the same server or on a particular client.
Avoid using this method in Component.preStart() as other script component instances may not be instantiated.
isVisibleToPlayer(player)
Indicates whether the entity is visible to the player.

Signature
isVisibleToPlayer(player: Player): boolean;
Parameters
player: PlayerThe player to check the view permission for.
Returns
booleantrue if the player has permission to view the entity, false otherwise.
Examples
const playerHasViewPermission: boolean = cubeEntity.isVisibleTo(player);
const isTrulyVisible: boolean = playerHasViewPermission && cubeEntity.visible.get();
Remarks
The return value isn't affected by the visible property. For a player to view an entity, the entity must be visible (the visible property on the entity is true), and the user must have permission to view the entity (this function returns true).
lookAt(target, up)
Rotates an entity to look at a point.

Signature
lookAt(target: Vec3, up?: Vec3): void;
Parameters
target: Vec3The target for the entity to look at.
up: Vec3(Optional) The up direction of the rotation. The default value is Vec3.up.
Returns
void
moveRelativeTo(target, relativePosition, space)
Moves every client instance of the entity relative to another entity.

Signature
moveRelativeTo(target: Entity, relativePosition: Vec3, space?: Space): void;
Parameters
target: EntityThe entity to move towards.
relativePosition: Vec3The position for the client entity to move, relative to the target entity.
space: Space(Optional) Indicates whether relativePosition is a world or local position.
Returns
void
Remarks
We recommend that you use this operation in an update loop instead of in a one-off call. Make sure that the client or server owns both the source and target, as the operation might not work properly if they are owned by different clients or servers.
moveRelativeToPlayer(player, bodyPart, relativePosition, space)
Moves every client instance of the entity relative to a player.

Signature
moveRelativeToPlayer(player: Player, bodyPart: PlayerBodyPartType, relativePosition: Vec3, space?: Space): void;
Parameters
player: PlayerThe entity to move towards.
bodyPart: PlayerBodyPartTypeThe body part of the player.
relativePosition: Vec3The position for the client entity to move, relative to the target entity.
space: Space(Optional) Indicates whether the relativePosition is a world or a local position.
Returns
void
Remarks
We recommend that you use this operation in an update loop instead of in a one-off call. Make sure that the client or server owns both the source and target, as the operation might not work properly if they are owned by different clients or servers.
resetVisibilityForPlayers()
Makes the entity visible to all players in the world instance, which resets any changes made by calls to the method.

Signature
resetVisibilityForPlayers(): void;
Returns
void
Examples
cubeEntity.resetPlayerVisibilityList();
Remarks
If a player joins your world instance after an object's visibility is changed with the resetVisibilityForPlayers method, the object becomes invisible to the new player. To ensure all new players can see the object upon joining the world instance, you must use the resetVisibilityForPlayers method. If a parent entity has its visibility set to false, the child entity also becomes invisible regardless of its own visibility setting.
rotateRelativeTo(target, relativeRotation, space)
Rotates every client instance of the entity relative to another entity.

Signature
rotateRelativeTo(target: Entity, relativeRotation: Quaternion, space?: Space): void;
Parameters
target: EntityThe entity to rotate around.
relativeRotation: QuaternionThe rotation relative to the target.
space: Space(Optional) Indicates whether relativeRotation is a world or a local rotation.
Returns
void
Remarks
We recommend that you use this operation in an update loop instead of in a one-off call. Make sure that the client or server owns both the source and target, as the operation might not work properly if they are owned by different clients or servers.
rotateRelativeToPlayer(player, bodyPart, relativeRotation, space)
Rotates every client instance of the entity relative to a player.

Signature
rotateRelativeToPlayer(player: Player, bodyPart: PlayerBodyPartType, relativeRotation: Quaternion, space?: Space): void;
Parameters
player: PlayerThe player for the entity to rotate around.
bodyPart: PlayerBodyPartTypeThe body part of the player.
relativeRotation: QuaternionThe rotation relative to the player.
space: Space(Optional) Indicates whether the relativeRotation is a world or a local rotation.
Returns
void
Remarks
We recommend that you use this operation in an update loop instead of in a one-off call. Make sure that the client or server owns both the source and target, as the operation might not work properly if they are owned by different clients or servers.
setVisibilityForPlayers(players, mode)
Replaces the visibility state of the entity for the given players. The visibility state indicates whether the entity is visible or hidden for the given players.

Signature
setVisibilityForPlayers(players: Array<Player>, mode: PlayerVisibilityMode): void;
Parameters
players: Array<Player>An array of Player objects to set the visibility mode for.
mode: PlayerVisibilityModeIndicates whether the entity is visible only to the specified players.
Returns
void
Examples
cubeEntity.setVisibilityForPlayers([myPlayer], PlayerVisibilityMode.VisibleTo);
Remarks
Before updating the visibility state of the entity, this method clears the current visibility state of the entity for the given players.
This method can only make the entity visible to players if the visible property of the entity is already set to true. The visible property of an entity determines whether any players can view view the entity, so this method acts as a filter once the property is enabled.
toString()
Gets a human-readable representation of the entity.

Signature
toString(): string;
Returns
stringA string representing the entity.

FocusedInteraction Class
Options for setting up and customizing visual feedback when players interact with the world in Focused Interaction mode on web and mobile clients.
Signature
export declare class FocusedInteraction
Remarks
Focused Interaction mode replaces on-screen controls on web and mobile clients with touch and mouse input that includes direct input access.
You can enable and disable Focused Interaction mode with the Player.enterFocusedInteractionMode() and Player.exitFocusedInteractionMode() methods.
When Focused Interaction mode is enabled, you can subscribe to the PlayerControls.onFocusedInteractionInputStarted, PlayerControls.onFocusedInteractionInputMoved, and PlayerControls.onFocusedInteractionInputEnded events.
For more information, see the Focused Interaction guide.
Constructors
(constructor)(player)
Creates a new FocusedInteraction instance.

Signature
constructor(player: Player);
Parameters
player: PlayerThe player to assign to the focused interaction settings.

Properties
player
[readonly]
The current player.

Signature
protected readonly player: Player;

Methods
setTapOptions(isEnabled, tapOptions)
Toggle and customize the visual feedback to display when players use tap input during Focused Interaction mode.

Signature
setTapOptions(isEnabled: boolean, tapOptions?: Partial<FocusedInteractionTapOptions>): void;
Parameters
isEnabled: booleantrue to enable visual feedback for tap input; false to disable it.
tapOptions: Partial<FocusedInteractionTapOptions>(Optional) The options to customize the tap visuals.
Returns
void
setTrailOptions(isEnabled, trailOptions)
Toggle and customize visual feedback trails that are displayed when players use drag input during Focused Interaction mode.

Signature
setTrailOptions(isEnabled: boolean, trailOptions?: Partial<FocusedInteractionTrailOptions>): void;
Parameters
isEnabled: booleantrue to enable trails; false to disable them.
trailOptions: Partial<FocusedInteractionTrailOptions>(Optional) Options to customize trail visuals.
Returns
void

GrabbableEntity Class
Extends Entity
Represents an entity that a player can grab.
Signature
export declare class GrabbableEntity extends Entity
Methods
forceHold(player, hand, allowRelease)
Forces the player to hold the entity and attach it to a hand they control.

Signature
forceHold(player: Player, hand: Handedness, allowRelease: boolean): void;
Parameters
player: PlayerThe player that grabs the entity.
hand: HandednessThe player's hand that is grabbing the entity.
allowRelease: booleantrue if the player can release the entity when they are holding it; otherwise, fals.
Returns
void
forceRelease()
Forces the player to release the entity.

Signature
forceRelease(): void;
Returns
void
setWhoCanGrab(players)
Specifies the players that can grab the entity.

Signature
setWhoCanGrab(players: Array<Player>): void;
Parameters
players: Array<Player>An array of players that can grab the entity.
Returns
void
toString()
Creates a human-readable representation of the GrabbableEntity.

Signature
toString(): string;
Returns
stringA string representation of the GrabbableEntity.

HorizonProperty Class
Extends ReadableHorizonProperty<T>, WritableHorizonProperty<T>
Represents a property in Horizon Worlds.
Signature
export declare class HorizonProperty<T> implements ReadableHorizonProperty<T>, WritableHorizonProperty<T>
Constructors
(constructor)(getter, setter)
Creates a HorizonProperty instance.

Signature
constructor(getter: () => T, setter: (value: T) => void);
Parameters
getter: () => TThe function that returns the property value.
setter: (value: T) => voidThe function that sets the property value.

Properties
getter
Gets the property.

Signature
getter: () => T;
setter
Sets the property.

Signature
setter: (value: T) => void;

Methods
get()
Gets the property value. Calls are cached per frame.

Signature
get(): T;
Returns
TThe current value of the property.
Remarks
Mutating the state snapshot doesn't change the underlying value. You must call HorizonProperty.set() to do this.
set(value)
Sets the property value.

Signature
set(value: T): void;
Parameters
value: TThe property value to set.
Returns
void
Remarks
There's no guarantee that this is a synchronous operation.

HorizonReferenceProperty Class
Extends HorizonProperty<T>
Creates a HorizonReferenceProperty instance. Use this when the property is a reference type that implements copy and clone methods to properly capture the state of the object reference when called.
Signature
export declare class HorizonReferenceProperty<T extends Copyable<T>> extends HorizonProperty<T>
Methods
set(value)

Signature
set(value: T): void;
Parameters
value: T
Returns
void

IWPSellerGizmo Class
Extends Entity
Represents the IWP (in-world purchase) seller gizmo in the world.
Signature
export declare class IWPSellerGizmo extends Entity
Methods
consumeItemForPlayer(player, item)
Consumes a specific item owned by the player.

Signature
consumeItemForPlayer(player: Player, item: string): void;
Parameters
player: PlayerThe player that owns the item.
item: stringThe item the player owns.
Returns
void
playerHasConsumedItem(player, item)
Indicates whether a player used a specific item.

Signature
playerHasConsumedItem(player: Player, item: string): boolean;
Parameters
player: PlayerThe player to query.
item: stringThe item to query.
Returns
booleantrue if player consumed the item, false otherwise.
playerOwnsItem(player, item)
Indicates whether the player owns a specific item.

Signature
playerOwnsItem(player: Player, item: string): boolean;
Parameters
player: PlayerThe player to query.
item: stringThe item to query.
Returns
booleantrue if player owns the item, false otherwise.
quantityPlayerOwns(player, item)
Gets the number of the items that the player owns.

Signature
quantityPlayerOwns(player: Player, item: string): number;
Parameters
player: PlayerThe player to query.
item: stringThe item to query.
Returns
numberThe number of the items the player owns.
timeSincePlayerConsumedItem(player, item, timeOption)
Gets the time since a player consumed the item.

Signature
timeSincePlayerConsumedItem(player: Player, item: string, timeOption: MonetizationTimeOption): number;
Parameters
player: PlayerThe player that consumed the item.
item: stringThe item the player consumed.
timeOption: MonetizationTimeOptionThe time units since the player purchased the item and the item was consumed.
Returns
numberThe number of timeOption units since player consumed the item.
toString()
Creates a human-readable representation of the entity.

Signature
toString(): string;
Returns
stringA string representation

LocalEvent Class
Represents an event sent between TypeScript event listeners on the same client in Horizon Worlds. These events support arbitrary data.
Signature
export declare class LocalEvent<TPayload extends LocalEventData = Record<string, never>>
Remarks
When sent between event listeners on the same client (locally), LocalEvent outperforms CodeBlockEvent because it doesn't use the legacy messaging system used by Code Block scripting.
For events sent over a network, you can use NetworkEvent.
Constructors
(constructor)(name)
Creates a local event with the specified name.

Signature
constructor(name?: string);
Parameters
name: string(Optional) The name of the event.
Remarks
If a name is not provided, the event becomes unique and must be referenced by its object instance. This is useful if your event is used in an asset to avoid collision in a world.

Properties
name
The name of the event. If a name is not provided, a randomly generated name is assigned.

Signature
name: string;

MaterialAsset Class
Extends Asset
A material asset, which describes how the surface of a mesh is rendered.
Signature
export declare class MaterialAsset extends Asset
Methods
toString()
Gets a human readable representation of the material asset.

Signature
toString(): string;
Returns
stringA string representation of the material asset.

MeshEntity Class
Extends Entity
An Entity that uses a custom model.
Signature
export declare class MeshEntity extends Entity
Remarks
A custom model is built outside of Horizon Worlds with a 3D modeling tool exported as an .fbx file, and then consumed in the asset library by the asset pipeline.
Properties
style
The style of the MeshEntity.

Signature
style: EntityStyle;

Methods
setMaterial(materialAsset, options)
Sets the material on a MeshEntity (custom model entity) to a material asset.

Signature
setMaterial(materialAsset: MaterialAsset, options?: SetMaterialOptions): Promise<void>;
Parameters
materialAsset: MaterialAssetA material asset from the asset library.
options: SetMaterialOptions(Optional)
Returns
Promise<void>A promise that resolves when the material has been successfully updated.
Examples
class Button extends Component<typeof Button> {
  static propsDefinition = {
    material: {type: PropTypes.Asset},
    materialSlot: {type: PropTypes.Number | Proptypes.String},
    targetEntity: {type: PropTypes.Entity},
  };

  start() {
    this.connectCodeBlockEvent(this.entity, CodeBlockEvents.OnPlayerEnterTrigger, () => this.onButtonPress());
  }

  onButtonPress() {
    const options = {materialSlot: this.props.materialSlot};
    this.props.targetEntity.as(MeshEntity)!.setMaterial(this.props.material, options);
  }
}
setMesh(mesh, options)
Changes the mesh and optionally material of a MeshEntity (custom model entity).

Signature
setMesh(mesh: Asset, options: SetMeshOptions): Promise<void>;
Parameters
mesh: AssetThe new custom model asset to use in the world. You must use a custom model asset that was consumed as a custom model in the asset pipeline. You cannot use a custom model asset that is saved as an asset within Horizon Worlds.
options: SetMeshOptionstrue if players can decide to use the new material that comes with the new custom model; false to use the current material.
Returns
Promise<void>A promise that resolves when the mesh (and material) has been successfully swapped.
Examples
import { Component, PropTypes, Entity, AudioGizmo, CodeBlockEvents, Asset } from '@early_access_api/v1';
import { MeshEntity, TextureAsset } from '@early_access_api/v1';

class TargetEntity extends Component<{}> {
   static propsDefinition = {};

   start() {
       this.connectLocalEvent(this.entity, buttonPressedEvent, (data: {mesh: Asset}) => {
       this.entity.as(MeshEntity).setMesh(data.mesh, {updateMaterial: false});
    });
  }
}

type ButtonProps = {
  mesh: Asset,
  targetEntity: Entity,
};

class Button extends Component<ButtonProps> {
  static propsDefinition = {
    mesh: {type: PropTypes.Asset},
    targetEntity: {type: PropTypes.Entity},
  };

  start() {
    this.connectCodeBlockEvent(this.entity, CodeBlockEvents.OnPlayerEnterTrigger, () => this.onClick());
  }

  onClick() {
    this.sendLocalEvent(this.props.targetEntity, buttonPressedEvent, {mesh: this.props.mesh.as(Asset)});
  }
}

Component.register(Button);
Remarks
You should only apply this API to a custom model entity. Otherwise, this call does not take effect.
setTexture(texture, options)
Changes the texture of a MeshEntity (custom model entity) for the specified players.

Signature
setTexture(texture: TextureAsset, options?: SetTextureOptions): Promise<void>;
Parameters
texture: TextureAssetThe asset containing the texture to apply. The asset must be a texture asset that has been consumed as a texture in the asset pipeline.
options: SetTextureOptions(Optional) Indicates the players to apply the texture for.
Returns
Promise<void>A promise that resolves when the texture is successfully applied.
Examples
import { Component, PropTypes, Entity, AudioGizmo, CodeBlockEvents, Asset } from '@early_access_api/v1';
import { MeshEntity, TextureAsset } from '@early_access_api/2p';

class Button extends Component<typeof Button> {
  static propsDefinition = {
    texture: {type: PropTypes.Asset},
    panel: {type: PropTypes.Entity},
    sound: {type: PropTypes.Entity},
  };

  start() {
    this.connectCodeBlockEvent(this.entity, CodeBlockEvents.OnPlayerEnterTrigger, () => this.onClick());
  }

  onClick() {
    this.props.sound.as(AudioGizmo).play();
    this.props.panel.as(MeshEntity).setTexture(this.props.texture.as(TextureAsset));
  }
}

Component.register(Button);
Remarks
This API should only be applied to a custom model entity that uses a texture based material. Additionally, static/nondynamic entities may not update textures if the material shader is GI lit. Otherwise, this call does not take effect and throws an error at runtime.
toString()
Gets a human readable representation of the MeshEntity.

Signature
toString(): string;
Returns
stringA string representation of the MeshEntity.

NetworkEvent Class
Represents an event sent over a network. These events support any type of data that can be serialized through JSON.stringify().
Signature
export declare class NetworkEvent<TPayload extends NetworkEventData = Record<string, never>>
Remarks
When sent over the network, NetworkEvent outperforms CodeBlockEvent because it doesn't use the legacy messaging system used by Code Block scripting.
For events sent between event listeners on the same client (locally), you can use LocalEvent.
Constructors
(constructor)(name)
Creates a NetworkEvent with the specified name.

Signature
constructor(name: string);
Parameters
name: stringThe name of the event.

Properties
name
The name of the event.

Signature
name: string;

ParticleGizmo Class
Extends Entity
Represents a particle effect in the world.
Signature
export declare class ParticleGizmo extends Entity
Methods
play(options)
Plays the particle effect.

Signature
play(options?: ParticleFXPlayOptions): void;
Parameters
options: ParticleFXPlayOptions(Optional) Controls how the effect is played.
Returns
void
stop(options)
Stops the particle effect.

Signature
stop(options?: ParticleFXStopOptions): void;
Parameters
options: ParticleFXStopOptions(Optional) The options that control how the effect is stopped.
Returns
void
toString()
Creates a human-readable representation of the entity.

Signature
toString(): string;
Returns
stringA string representation of the entity.

PhysicalEntity Class
Extends Entity
Represents an entity influenced by physical effects such as gravity, in the world.
Signature
export declare class PhysicalEntity extends Entity
Properties
angularVelocity
The angular velocity of an object in world space.

Signature
angularVelocity: ReadableHorizonProperty<Vec3>;
gravityEnabled
Whether the entity has a gravity effect on it. If true, gravity has an effect, otherwise gravity does not have an effect.

Signature
gravityEnabled: WritableHorizonProperty<boolean>;
locked
true if the physics system is blocked from interacting with the entity; false otherwise.

Signature
locked: HorizonProperty<boolean>;
velocity
The velocity of an object in world space, in meters per second.

Signature
velocity: ReadableHorizonProperty<Vec3>;

Methods
applyForce(vector, mode)
Applies a force at a world space point. Adds to the current velocity.

Signature
applyForce(vector: Vec3, mode: PhysicsForceMode): void;
Parameters
vector: Vec3The force vector.
mode: PhysicsForceModeThe amount of force to apply.
Returns
void
applyForceAtPosition(vector, position, mode)
Applies a force at a world space point using a specified position as the center of force.

Signature
applyForceAtPosition(vector: Vec3, position: Vec3, mode: PhysicsForceMode): void;
Parameters
vector: Vec3The force vector.
position: Vec3The position of the center of the force vector.
mode: PhysicsForceModeThe amount of force to apply.
Returns
void
applyLocalForce(vector, mode)
Applies a local force at a world space point. Adds to the current velocity.

Signature
applyLocalForce(vector: Vec3, mode: PhysicsForceMode): void;
Parameters
vector: Vec3The force vector.
mode: PhysicsForceModeThe amount of force to apply.
Returns
void
applyLocalTorque(vector)
Applies a local torque to the entity.

Signature
applyLocalTorque(vector: Vec3): void;
Parameters
vector: Vec3The force vector.
Returns
void
applyTorque(vector)
Applies torque to the entity.

Signature
applyTorque(vector: Vec3): void;
Parameters
vector: Vec3The force vector.
Returns
void
springPushTowardPosition(position, options)
Pushes a physical entity toward a target position as if it's attached to a spring. This should be called every frame and requires the physical entity's motion type to be interactive.

Signature
springPushTowardPosition(position: Vec3, options?: Partial<SpringOptions>): void;
Parameters
position: Vec3The target position, or 'origin' of the spring
options: Partial<SpringOptions>(Optional) Additional optional arguments to control the spring's behavior.
Returns
void
Examples
var physEnt = this.props.obj1.as(hz.PhysicalEntity);
this.connectLocalBroadcastEvent(hz.World.onUpdate, (data: { deltaTime: number }) => {
 physEnt.springPushTowardPosition(this.props.obj2.position.get(), {stiffness: 5, damping: 0.2});
})
springSpinTowardRotation(rotation, options)
Spins a physical entity toward a target rotation as if it's attached to a spring. This should be called every frame and requires the physical entity's motion type to be interactive.

Signature
springSpinTowardRotation(rotation: Quaternion, options?: Partial<SpringOptions>): void;
Parameters
rotation: QuaternionThe target quaternion rotation.
options: Partial<SpringOptions>(Optional) Additional optional arguments to control the spring's behavior.
Returns
void
Examples
var physEnt = this.props.obj1.as(hz.PhysicalEntity);
this.connectLocalBroadcastEvent(hz.World.onUpdate, (data: { deltaTime: number }) => {
 physEnt.springSpinTowardRotation(this.props.obj2.rotation.get(), {stiffness: 10, damping: 0.5, axisIndependent: false});
})
toString()
Gets a string representation of the entity.

Signature
toString(): string;
Returns
stringThe human readable string representation of this entity.
zeroVelocity()
Sets the velocity of an entity to zero.

Signature
zeroVelocity(): void;
Returns
void

Player Class
Represents a player in the world. This is the primary class for managing an individual player's physical presence and game play in the world, including their avatar.
Signature
export declare class Player
Constructors
(constructor)(id)
Creates a player in the world.

Signature
constructor(id: number);
Parameters
id: numberThe ID of the player.

Properties
deviceType
Gets the type of device the player is using.

Signature
deviceType: ReadableHorizonProperty<PlayerDeviceType>;
Remarks
New device types may be added in the future, so you should handle this property with a switch statement.
focusedInteraction
The FocusedInteraction instance associated with the player.

Signature
focusedInteraction: FocusedInteraction;
Remarks
Focused Interaction mode replaces on-screen controls on web and mobile clients with touch and mouse input that includes direct input access.
For more information about Focused Interaction, see the Focused Interaction guide.
foot
The player's foot.

Signature
foot: PlayerBodyPart;
forward
The player's forward direction relative to the world origin.

Signature
forward: ReadableHorizonProperty<Vec3>;
gravity
The player's gravity before simulation.

Signature
gravity: HorizonProperty<number>;
head
The player's head.

Signature
head: PlayerBodyPart;
id
[readonly]
The player's ID.

Signature
readonly id: number;
index
The index that identifies the player in the list of all players in the world instance.

Signature
index: ReadableHorizonProperty<number>;
Examples
This example demonstrates how to retrieve a Player object using a player index.
var playerIndex = player.index.get();
var playerFromIndex = this.world.getPlayerFromIndex(playerIndex);
Remarks
When joing a world, each player is assigned an index, which ranges from 0 (the first player) to Max Players - 1. Use the index value to keep track of players and get a Player object using the World.getPlayerFromIndex() method.
isGrounded
Indicates whether the player is grounded (touching a floor). If a player is grounded then gravity has no effect on their velocity.

Signature
isGrounded: ReadableHorizonProperty<boolean>;
isInBuildMode
Indicates whether a player is in build mode.

Signature
isInBuildMode: ReadableHorizonProperty<boolean>;
Remarks
Build mode means the player is editing the world. The alternative, preview mode, is when they're playing the world.
jumpSpeed
The speed applied to a player when they jump, in meters per second. Setting this to 0 effectively disables a player's ability to jump.

Signature
jumpSpeed: HorizonProperty<number>;
Remarks
Default value is 4.3. jumpSpeed must be a value between 0 and 45. jumpSpeed.set can be called on any player from any context, but jumpSpeed.get will throw an error unless it's called from a local script attached to an object owned by the player in question.
leftHand
The player's left hand.

Signature
leftHand: PlayerHand;
locomotionSpeed
The speed at which the player moves.

Signature
locomotionSpeed: WritableHorizonProperty<number>;
name
The player's name displayed in the game.

Signature
name: ReadableHorizonProperty<string>;
position
The player's position relative to the world origin.

Signature
position: HorizonProperty<Vec3>;
rightHand
The player's right hand.

Signature
rightHand: PlayerHand;
rootRotation
The root rotation of the player's avatar. This is different from the normal player.rotation, which retrieves the player's head rotation. When setting, only the yaw component of the input rotation will be used, keeping the character upright.

Signature
rootRotation: HorizonProperty<Quaternion>;
rotation
The player's facing/head rotation relative to the world origin.

Signature
rotation: ReadableHorizonProperty<Quaternion>;
torso
The player's torso.

Signature
torso: PlayerBodyPart;
up
The player's up direction relative to the world origin.

Signature
up: ReadableHorizonProperty<Vec3>;
velocity
The player's velocity relative to the origin, in meters per second, due to physics and not locomotion input.

Signature
velocity: HorizonProperty<Vec3>;

Methods
applyForce(force)
Applies a force vector to the player.

Signature
applyForce(force: Vec3): void;
Parameters
force: Vec3The force vector applied to the player's body.
Returns
void
clearAimAssistTarget()
Disables the Aim Assistance by clearing the current target. This method must be called on a local player. This method has no effect on VR players.

Signature
clearAimAssistTarget(): void;
Returns
void
clearAvatarGripPoseOverride()
Clears any override on an avatar grip pose, reverting it to the pose of the currently held grabbable.

Signature
clearAvatarGripPoseOverride(): void;
Returns
void
Remarks
For information on overriding an avatar grip pose, see .
configurePhysicalHands(collideWithDynamicObjects, collideWithStaticObjects)
Specifies whether physical hands can collide with objects.

Signature
configurePhysicalHands(collideWithDynamicObjects: boolean, collideWithStaticObjects: boolean): void;
Parameters
collideWithDynamicObjects: booleanIndicates whether physical hands can collide with dynamic objects.
collideWithStaticObjects: booleanIndicates whether physical hands can collide with static objects.
Returns
void
enterFocusedInteractionMode()
Enables Focused Interaction mode for the player.

Signature
enterFocusedInteractionMode(): void;
Returns
void
Remarks
This method must be called on a local player and has no effect on VR players.
Focused Interaction mode replaces on-screen controls on web and mobile clients with touch and mouse input that includes direct input access.
Player.exitFocusedInteractionMode() disables Focused Interaction mode.
When Focused Interaction mode is enabled, you can recieve input data from the PlayerControls.onFocusedInteractionInputStarted, PlayerControls.onFocusedInteractionInputMoved, and PlayerControls.onFocusedInteractionInputEnded events.
For more information, see the Focused Interaction guide.
exitFocusedInteractionMode()
Disables Focused Interaction mode for the player.

Signature
exitFocusedInteractionMode(): void;
Returns
void
Remarks
This method must be called on a local player and has no effect on VR players.
Player.enterFocusedInteractionMode() enables Focused Interaction mode.
When Focused Interaction mode is enabled, you can recieve input data from the PlayerControls.onFocusedInteractionInputStarted, PlayerControls.onFocusedInteractionInputMoved, and PlayerControls.onFocusedInteractionInputEnded events.
For more information, see the Focused Interaction guide.
focusUI(selectable, options)
Focuses the player's camera on the given selectable entity in the world, such as a custom UI. This method only affects web and mobile clients.

Signature
focusUI(selectable: Entity, options?: FocusUIOptions): void;
Parameters
selectable: EntityThe selectable entity to focus on.
options: FocusUIOptions(Optional) The options to apply to, such as settings for the camera view and animation transitions.
Returns
void
Remarks
You can use this method along with the method to manage the camera focus when creating a custom UI component. For more information about creating custom UI components, see the Custom UI panel guide.
hasCompletedAchievement(achievementScriptID)
Indicates whether a player has completed an achievement.

Signature
hasCompletedAchievement(achievementScriptID: string): boolean;
Parameters
achievementScriptID: stringThe scriptID of the achievement. This can be accessed and set on the Achievements page in the VR creator UI.
Returns
booleantrue if the player has the achievement, false otherwise.
Examples
var WonAGameAchievementScriptID = "wonAGame" var hasAchievement = player.hasCompletedAchievement(WonAGameAchievementScriptID)
playAvatarAnimation(animation, options)
Plays an animation asset on the player's avatar one time.

Signature
playAvatarAnimation(animation: Asset, options?: PlayAnimationOptions): void;
Parameters
animation: Asset
options: PlayAnimationOptions(Optional) The options that control how to play the animation.
Returns
void
Remarks
This method allows you to use custom animations for player avatars and access callbacks that allow your scripts to respond when the animation starts and stops.
playAvatarGripPoseAnimationByName(avatarGripPoseAnimationName, options)
Triggers a one shot AvatarGripPose animation by name.

Signature
playAvatarGripPoseAnimationByName(avatarGripPoseAnimationName: string, options?: PlayAvatarGripPoseAnimationOptions): void;
Parameters
avatarGripPoseAnimationName: stringThe avatar grip pose animation to play.
options: PlayAvatarGripPoseAnimationOptions(Optional) Configuration to influence animation handling PlayAvatarGripPoseAnimationOptions.
Returns
void
Examples
player.playAvatarGripPoseAnimationByName(AvatarGripPoseAnimationNames.Fire, {callback: (reason: hz.AnimationCallbackReasons) => {}});
setAchievementComplete(achievementScriptID, complete)
Specifies whether the player's achievement is complete.

Signature
setAchievementComplete(achievementScriptID: string, complete: boolean): void;
Parameters
achievementScriptID: stringThe scriptID of the achievement. This can be accessed/set on the Achievements page in the VR creator UI.
complete: booleantrue sets the achievement to complete; false sets the achievement to incomplete.
Returns
void
Examples
var WonAGameAchievementScriptID = "wonAGame"
player.setAchievementComplete(WonAGameAchievementScriptID, true)
setAimAssistTarget(target, options)
Enables Aim Assistance on a target. This generates a force pulling the cursor towards a target when the aim cursor approaches it.

Signature
setAimAssistTarget(target: Player | Entity | Vec3, options?: AimAssistOptions): void;
Parameters
target: Player | Entity | Vec3The target that receives Aim Assistance.
options: AimAssistOptions(Optional) The options to use when applying Aim Assistance.
Returns
void
Remarks
This method must be called on a local player and has no effect on VR players.
setAvatarGripPoseOverride(avatarGripPose)
Overrides the existing HWXS avatar grip type, which is determined by the currently held grabbable.

Signature
setAvatarGripPoseOverride(avatarGripPose: AvatarGripPose): void;
Parameters
avatarGripPose: AvatarGripPoseThe new pose to apply. This persists until cleared or another grip override is set. For information on clearing an override, see .
Returns
void
setVoipSetting(setting)
Sets the VOIP setting for the player.

Signature
setVoipSetting(setting: VoipSetting): void;
Parameters
setting: VoipSettingThe VOIP setting to use.
Returns
void
stopAvatarAnimation(options)
Stops any avatar animation asset that is playing.

Signature
stopAvatarAnimation(options?: StopAnimationOptions): void;
Parameters
options: StopAnimationOptions(Optional) The options that control the animation.
Returns
void
Remarks
The Player.stopAvatarAnimation() method is used to play custom avatar animations.
throwHeldItem(options)
Attempts throws the item held in the specified hand.

Signature
throwHeldItem(options?: Partial<ThrowOptions>): void;
Parameters
options: Partial<ThrowOptions>(Optional) Options to adjust the throwing speed, yaw, pitch, and animation.
Returns
void
toString()
Creates a human-readable representation of the player.

Signature
toString(): string;
Returns
stringA string representation of the player.
unfocusUI()
Removes focus from any in-world UI the player's camera is currently focused on. This method only affects web and mobile clients.

Signature
unfocusUI(): void;
Returns
void
Remarks
You can use this method along with the Player.focusUI() method to manage the camera focus when creating a custom UI component. For more information about creating custom UI components, see the Custom UI panel guide.

PlayerBodyPart Class
Represents a player body part.
Signature
export declare class PlayerBodyPart
Constructors
(constructor)(player, type)
Creates a PlayerBodyPart.

Signature
constructor(player: Player, type: PlayerBodyPartType);
Parameters
player: PlayerThe player that owns the body part.
type: PlayerBodyPartTypeThe type of the body part.

Properties
forward
The forward direction of the body part.

Signature
forward: ReadableHorizonProperty<Vec3>;
localPosition
The position of the body part relative to the player's torso.

Signature
localPosition: ReadableHorizonProperty<Vec3>;
localRotation
The local rotation of the body part relative to the player's torso.

Signature
localRotation: ReadableHorizonProperty<Quaternion>;
player
[readonly]
The player that owns the body part.

Signature
protected readonly player: Player;
position
The position of the body part relative to the player.

Signature
position: ReadableHorizonProperty<Vec3>;
rotation
The rotation of the body part relative to the player's body.

Signature
rotation: ReadableHorizonProperty<Quaternion>;
type
[readonly]
The type of the body part.

Signature
protected readonly type: PlayerBodyPartType;
up
The up direction of the body part.

Signature
up: ReadableHorizonProperty<Vec3>;

Methods
getPosition(space)
Gets the world or the local position of the body part.

Signature
getPosition(space: Space): Vec3;
Parameters
space: SpaceIndicates whether to get the world or local position of the body part.
Returns
Vec3The position of the body part in this space.
getRotation(space)
Gets the rotation or the local rotation of the body part.

Signature
getRotation(space: Space): Quaternion;
Parameters
space: SpaceIndicates whether to get the world or local rotation of the body part.
Returns
QuaternionThe rotation of the body part in this space.

PlayerControls Class
Provides static methods to bind to, and query data about custom player input bindings.
Signature
export declare class PlayerControls
Properties
onFocusedInteractionInputEnded
static
[readonly]
This event broadcasts on the last frame of input when the player ends a touch gesture or mouse click while in Focused Interaction mode.

Signature
static readonly onFocusedInteractionInputEnded: LocalEvent<{
        interactionInfo: InteractionInfo[];
    }>;
Remarks
For more information, see the Focused Interaction guide.
onFocusedInteractionInputMoved
static
[readonly]
This event broadcasts while the player is in Focused Interaction mode while using touch gestures or mouse clicks. The event fires on all frames of the input except for the first and last frames which instead fire the PlayerControls.onFocusedInteractionInputStarted and PlayerControls.onFocusedInteractionInputEnded events respectively.

Signature
static readonly onFocusedInteractionInputMoved: LocalEvent<{
        interactionInfo: InteractionInfo[];
    }>;
Remarks
For more information, see the Focused Interaction guide.
onFocusedInteractionInputStarted
static
[readonly]
This event fires on the first frame of input when the player starts a touch gesture or mouse click while in Focused Interaction mode.

Signature
static readonly onFocusedInteractionInputStarted: LocalEvent<{
        interactionInfo: InteractionInfo[];
    }>;
Remarks
You can also recieve input data from the PlayerControls.onFocusedInteractionInputMoved and PlayerControls.onFocusedInteractionInputEnded events during Focused Interaction mode.
For more information, see the Focused Interaction guide.
onHolsteredItemsUpdated
static
[readonly]
This event fires when an item is holstered or unholstered. The purpose of this event is to populate a list of holstered items in a UI panel in order to allow the player to switch between them.

Signature
static readonly onHolsteredItemsUpdated: LocalEvent<{
        player: Player;
        items: Entity[];
        grabbedItem: Entity;
    }>;
Remarks
The grabbedItem also appears in the items list so this will need to be filtered out when iterating the list of items to display in the UI.

Methods
connectLocalInput(input, icon, disposableObject, options) static
Connects to input events for the local player.

Signature
static connectLocalInput(input: PlayerInputAction, icon: ButtonIcon, disposableObject: DisposableObject, options?: PlayerControlsConnectOptions): PlayerInput;
Parameters
input: PlayerInputActionThe action to respond to.
icon: ButtonIconThe icon to use for the button, on platforms that display on-screen buttons for actions.
disposableObject: DisposableObjectThe DisposableObject that controls the lifetime of the connection
options: PlayerControlsConnectOptions(Optional) Connection options, see PlayerControlsConnectOptions for defaults.
Returns
PlayerInputA PlayerInput instance that can be used to poll the status of the input, or register a state change callback.
Remarks
This function fails if called on the server. On platforms that display on-screen buttons for actions (such as mobile), displays a button with the specified icon.
disableSystemControls() static
Disables the on-screen system controls for the local player.

Signature
static disableSystemControls(): void;
Returns
void
Remarks
This function fails if called on the server.
enableSystemControls() static
Enables the on-screen system controls for the local player.

Signature
static enableSystemControls(): void;
Returns
void
Remarks
This function fails if called on the server.
equipHolsteredItem(index) static
Equips the item at the selected holster index if there is one

Signature
static equipHolsteredItem(index: number): void;
Parameters
index: number
Returns
void
equipNextHolsteredItem() static
Equips the next holstered item if there is one

Signature
static equipNextHolsteredItem(): void;
Returns
void
equipPreviousHolsteredItem() static
Equips the previous holstered item if there is one

Signature
static equipPreviousHolsteredItem(): void;
Returns
void
getPlatformKeyNames(action) static
Returns a list of names that represent the physical buttons or keys bound to the specified action.

Signature
static getPlatformKeyNames(action: PlayerInputAction): Array<string>;
Parameters
action: PlayerInputActionThe action to get the key names for.
Returns
Array<string>An array of key names.
Remarks
This function fails if called on the server.
isInputActionSupported(action) static
Indicates whether the action is supported on the current platform.

Signature
static isInputActionSupported(action: PlayerInputAction): boolean;
Parameters
action: PlayerInputActionThe action to query.
Returns
booleantrue if the action is supported on the current platform; otherwise, false.
Remarks
This function fails if called on the server. Connecting to an unsupported input is allowed, but the input won't activate and its axis value will remain at 0.
triggerContextualMultiHolsterAction() static
Triggers a contextual based multi-holstering action if one is available. This function is designed to mirror the behaviour of the system holstering button, and will open the system holstering UI if there is more than one item holstered.

Signature
static triggerContextualMultiHolsterAction(): void;
Returns
void
triggerDropAction() static
Triggers the player action to drop the currently held item

Signature
static triggerDropAction(): void;
Returns
void
triggerInputActionDown(inputAction) static
Triggers the down event for an input action for the local player.

Signature
static triggerInputActionDown(inputAction: PlayerInputAction): void;
Parameters
inputAction: PlayerInputActionThe action to trigger / activate.
Returns
void
Remarks
This function fails if called on the server. On platforms that display on-screen buttons for actions (such as mobile), triggers the specified action.
triggerInputActionUp(inputAction) static
Triggers the up event for an input action for the local player.

Signature
static triggerInputActionUp(inputAction: PlayerInputAction): void;
Parameters
inputAction: PlayerInputActionThe action to trigger / activate.
Returns
void
Remarks
This function fails if called on the server. On platforms that display on-screen buttons for actions (such as mobile), triggers the specified action.

PlayerHand Class
Extends PlayerBodyPart
A player's hand.
Signature
export declare class PlayerHand extends PlayerBodyPart
Constructors
(constructor)(player, handedness)
Contructs a new PlayerHand.

Signature
constructor(player: Player, handedness: Handedness);
Parameters
player: PlayerThe player associated with the hand.
handedness: HandednessThe player's handedness.

Properties
handedness
[readonly]
The player handedness.

Signature
protected readonly handedness: Handedness;

Methods
playHaptics(duration, strength, sharpness)
Plays haptic feedback on the specified hand.

Signature
playHaptics(duration: number, strength: HapticStrength, sharpness: HapticSharpness): void;
Parameters
duration: numberThe duration of the feedback in MS.
strength: HapticStrengthThe strength of feedback to play.
sharpness: HapticSharpnessThe sharpness of the feedback.
Returns
void

PlayerInput Class
A customizable player input that is bound to an input action on a player's input device, such as a VR controller, gamepad, or on-screen button.
Signature
export declare class PlayerInput
Remarks
You can create a PlayerInput instance by calling the PlayerControls.connectLocalInput() method.
For more information about binding player input, see the Custom Input API guide.
Properties
action
The action this input is bound to. For analog inputs, a pressed state corresponds to an axis value greater than 0.5 or lesser than -0.5.

Signature
action: ReadableHorizonProperty<PlayerInputAction>;
axisValue
Gets the axis value, between -1 and 1. If the input is digital, 0 or 1 is returned.

Signature
axisValue: ReadableHorizonProperty<number>;
connected
Indicates whether the input is currently connected and active.

Signature
connected: ReadableHorizonProperty<boolean>;
held
Indicates whether the input is being held active. For analog inputs, a pressed state corresponds to an axis value greater than 0.5 or lesser than -0.5.

Signature
held: ReadableHorizonProperty<boolean>;
pressed
Indicates whether the input was pressed this frame.

Signature
pressed: ReadableHorizonProperty<boolean>;
released
Indicates whether the input was released this frame.

Signature
released: ReadableHorizonProperty<boolean>;

Methods
disconnect()
Disconnects the input. On platforms that display on-screen buttons for actions, the button will be removed. Any callbacks registered to this instance will stop being called.

Signature
disconnect(): void;
Returns
void
registerCallback(callback)
Registers a callback that is called when the input is pressed or released. For analog inputs, a pressed state corresponds to an axis value greater than 0.5 or lesser than -0.5.

Signature
registerCallback(callback: PlayerInputStateChangeCallback): void;
Parameters
callback: PlayerInputStateChangeCallbackThe callback that is called when the pressed state changes.
Returns
void
unregisterCallback()
Unregisters the currently registered callback, if any.

Signature
unregisterCallback(): void;
Returns
void

ProjectileLauncherGizmo Class
Extends Entity
Represents a projectile launcher in the world.
Signature
export declare class ProjectileLauncherGizmo extends Entity
Properties
projectileGravity
The gravity applied to the projectile.

Signature
projectileGravity: WritableHorizonProperty<number>;

Methods
launch(options)
Launches a projectile with options.

Signature
launch(options?: LaunchProjectileOptions): void;
Parameters
options: LaunchProjectileOptions(Optional) Optional options for launching projectile
Returns
void
launchProjectile(speed)
Warning: This API is now obsolete.
use launch instead.
Launches a projectile.

Signature
launchProjectile(speed?: number): void;
Parameters
speed: number(Optional) Optional. The speed at which the projectile will launch from the launcher.
Returns
void
toString()
Creates a human-readable representation of the entity.

Signature
toString(): string;
Returns
stringA string representation

Quaternion Class
Extends Comparable<Quaternion>
Represents a quaternion (a four-element vector defining the orientation of a 3D point in space).
Signature
export declare class Quaternion implements Comparable<Quaternion>
Constructors
(constructor)(x, y, z, w)
Creates a quaternion.

Signature
constructor(x: number, y: number, z: number, w: number);
Parameters
x: numberThe x component of the quaternion.
y: numberThe y component of the quaternion.
z: numberThe z component of the quaternion.
w: numberThe w component of the quaternion.

Properties
fromAxisAngle
static
Creates a quaternion from an axis angle.

Signature
static fromAxisAngle: (axis: Vec3, angle: number) => Quaternion;
i
static
[readonly]
Creates a quaternion representing a rotation around the X-axis. Axis is not normalized.

Signature
static get i(): Quaternion;
j
static
[readonly]
Creates a quaternion representing a rotation around the Y-axis. The axis is not normalized.

Signature
static get j(): Quaternion;
k
static
[readonly]
Creates a quaternion representing a rotation around the Z-axis. The axis is not normalized.

Signature
static get k(): Quaternion;
mulVec3
static
Creates a copy of a 3D vector and then rotates the copy by a quaternion.

Signature
static mulVec3: (quat: Quaternion, vec: Vec3) => Vec3;
one
static
[readonly]
Creates a unit quaternion [0,0,0,1].

Signature
static get one(): Quaternion;
toEuler
Converts the quaternion to an Euler angle in degrees.

Signature
toEuler: (order?: EulerOrder) => Vec3;
w
The w component of the quaternion.

Signature
w: number;
x
The x component of the quaternion.

Signature
x: number;
y
The y component of the quaternion.

Signature
y: number;
z
The z component of the quaternion.

Signature
z: number;
zero
static
[readonly]
Creates a zero element quaternion.

Signature
static get zero(): Quaternion;

Methods
angle()
Gets the angle, in radians, of rotation represented by the quaternion.

Signature
angle(): number;
Returns
numberThe angle in radians.
axis()
Gets the axis of the rotation represented by the quaternion.

Signature
axis(): Vec3;
Returns
Vec3The vector that represents the axis.
clone()
Creates a copy of the quaternion.

Signature
clone(): Quaternion;
Returns
QuaternionThe new quaternion.
conjugate()
Creates a quaternion that is the conjugation of a quaternion.

Signature
static conjugate(quat: Quaternion, outQuat?: Quaternion): Quaternion;
Parameters
quat: QuaternionThe quaternion to conjugate.
outQuat: Quaternion(Optional) The quaternion to perform the operation on. If this isn't supplied, a new quaternion is created and returned.
Returns
QuaternionThe new quaternion.
conjugate(quat, outQuat) static
Creates a quaternion that is the conjugation of a quaternion.

Signature
static conjugate(quat: Quaternion, outQuat?: Quaternion): Quaternion;
Parameters
quat: QuaternionThe quaternion to conjugate.
outQuat: Quaternion(Optional) The quaternion to perform the operation on. If this isn't supplied, a new quaternion is created and returned.
Returns
QuaternionThe new quaternion.
conjugateInPlace()
Updates the current quaternion with its conjugated values.

Signature
conjugateInPlace(): this;
Returns
thisThe updated quaterion.
copy(quat)
Updates the values of the quaternion with the values of another quaterium.

Signature
copy(quat: Quaternion): this;
Parameters
quat: QuaternionThe quaternion to copy.
Returns
thisThe updated quaternion.
equals(quat)
Determines whether two quaternions are equal. A quaternion is equal to another quaternion if its components are equal or if the negation of its components are equal.

Signature
static equals(quatA: Quaternion, quatB: Quaternion): boolean;
Parameters
quatA: QuaternionThe first quaternion to compare.
quatB: QuaternionThe second quaternion to compare.
Returns
booleantrue if the quaternions are equal; otherwise, false.
equals(quatA, quatB) static
Determines whether two quaternions are equal. A quaternion is equal to another quaternion if its components are equal or if the negation of its components are equal.

Signature
static equals(quatA: Quaternion, quatB: Quaternion): boolean;
Parameters
quatA: QuaternionThe first quaternion to compare.
quatB: QuaternionThe second quaternion to compare.
Returns
booleantrue if the quaternions are equal; otherwise, false.
equalsApprox(quat, epsilon)
Compares the approximate equality between two quaternions. A quaternion is equal to another quaternion if its components are equal or if the negation of its components are equal.

Signature
static equalsApprox(quatA: Quaternion, quatB: Quaternion, epsilon?: number): boolean;
Parameters
quatA: QuaternionThe first quaternion to compare.
quatB: QuaternionThe second quaternion to compare.
epsilon: number(Optional) The maxium difference in values to consider approximately equal.
Returns
booleantrue if the quaternions are approximately equal; otherwise, false.
equalsApprox(quatA, quatB, epsilon) static
Compares the approximate equality between two quaternions. A quaternion is equal to another quaternion if its components are equal or if the negation of its components are equal.

Signature
static equalsApprox(quatA: Quaternion, quatB: Quaternion, epsilon?: number): boolean;
Parameters
quatA: QuaternionThe first quaternion to compare.
quatB: QuaternionThe second quaternion to compare.
epsilon: number(Optional) The maxium difference in values to consider approximately equal.
Returns
booleantrue if the quaternions are approximately equal; otherwise, false.
fromEuler(euler, order) static
Creates a quaternion from a Euler angle.

Signature
static fromEuler(euler: Vec3, order?: EulerOrder): Quaternion;
Parameters
euler: Vec3The Euler angle in degrees.
order: EulerOrder(Optional) The order of the Euler angle. The default order is XYZ.
Returns
Quaternion
fromVec3(vec) static
Creates a quaternion from a 3D vector, where w is 0.

Signature
static fromVec3(vec: Vec3): Quaternion;
Parameters
vec: Vec3The 3D vector to create the quaternion from.
Returns
QuaternionThe new quaternion.
inverse()
Gets a new quaternion that is the inverse of the specified quaternion.

Signature
static inverse(quat: Quaternion): Quaternion;
Parameters
quat: QuaternionThe specified quaternion.
Returns
QuaternionThe new quaternion.
inverse(quat) static
Gets a new quaternion that is the inverse of the specified quaternion.

Signature
static inverse(quat: Quaternion): Quaternion;
Parameters
quat: QuaternionThe specified quaternion.
Returns
QuaternionThe new quaternion.
inverseInPlace()
Updates the current quaternion with its inverse values.

Signature
inverseInPlace(): this;
Returns
thisThe updated quaternion.
lookRotation(forward, up, outQuat) static
Creates a quaternion using forward and up 3D vectors.

Signature
static lookRotation(forward: Vec3, up?: Vec3, outQuat?: Quaternion): Quaternion;
Parameters
forward: Vec3The forward direction of rotation; must be orthogonal to up.
up: Vec3(Optional) The up direction of rotation; must be orthogonal to forward. The default value is Vec3.up.
outQuat: Quaternion(Optional) The quaternion to perform the operation on. If not supplied, a new quaternion is created and returned.
Returns
QuaternionThe quaternion aimed at the provided 3D vectors.
mul(quat)
Gets a quaternion that is the product of two quaternions.

Signature
static mul(quatA: Quaternion, quatB: Quaternion, outQuat?: Quaternion): Quaternion;
Parameters
quatA: QuaternionThe first quaternion to multiply.
quatB: QuaternionThe second uaternion to multiply.
outQuat: Quaternion(Optional) The quaternion to perform the operation on. If this isn't supplied, a new quaternion is created and returned.
Returns
QuaternionA new quaternion.
mul(quatA, quatB, outQuat) static
Gets a quaternion that is the product of two quaternions.

Signature
static mul(quatA: Quaternion, quatB: Quaternion, outQuat?: Quaternion): Quaternion;
Parameters
quatA: QuaternionThe first quaternion to multiply.
quatB: QuaternionThe second uaternion to multiply.
outQuat: Quaternion(Optional) The quaternion to perform the operation on. If this isn't supplied, a new quaternion is created and returned.
Returns
QuaternionA new quaternion.
mulInPlace(quat)
Updates the current quaternion by multiplying it by another quaternion.

Signature
mulInPlace(quat: Quaternion): this;
Parameters
quat: QuaternionThe quaternion to use as the multiplier.
Returns
thisThe current quaternion.
normalize()
Gets a new quaternion that is the normalized version of the specified quaternion.

Signature
static normalize(quat: Quaternion, outQuat?: Quaternion): Quaternion;
Parameters
quat: QuaternionThe specified quaternion.
outQuat: Quaternion(Optional) The quaternion to perform the operation on. If this isn't supplied, a new quaternion is created and returned.
Returns
QuaternionThe new normalized quaternion.
normalize(quat, outQuat) static
Gets a new quaternion that is the normalized version of the specified quaternion.

Signature
static normalize(quat: Quaternion, outQuat?: Quaternion): Quaternion;
Parameters
quat: QuaternionThe specified quaternion.
outQuat: Quaternion(Optional) The quaternion to perform the operation on. If this isn't supplied, a new quaternion is created and returned.
Returns
QuaternionThe new normalized quaternion.
normalizeInPlace()
Updates the current quaterion with its normalized values.

Signature
normalizeInPlace(): this;
Returns
thisThe updated quaternion
slerp(left, right, amount, outQuat) static
Peforms slerp (spherical linear interpolation) between two quaternions.

Signature
static slerp(left: Quaternion, right: Quaternion, amount: number, outQuat?: Quaternion): Quaternion;
Parameters
left: QuaternionThe leftmost quaternion.
right: QuaternionThe rightmost quaternion.
amount: numberDefines the gradient to use for interpolation, clamped 0 to 1.
outQuat: Quaternion(Optional) The quaternion to perform the operation on. If this isn't supplied, a new quaternion is created and returned.
Returns
QuaternionA new interpolated quaternion.
toString()
Gets a human-readable represention of the quaternion.

Signature
toString(): string;
Returns
stringa string representation of the quaternion.

RaycastGizmo Class
Extends Entity
Represents a Raycast gizmo in the world.
Signature
export declare class RaycastGizmo extends Entity
Remarks
A Raycast gizmo projects an invisible beam into a world to return information about any objects it collides with.
Methods
raycast(origin, direction, options)
Casts a ray from the Raycast gizmo using the given origin and direction and then retrieves collision information.

Signature
raycast(origin: Vec3, direction: Vec3, options?: {
        layerType?: LayerType;
        maxDistance?: number;
    }): RaycastHit | null;
Parameters
origin: Vec3The starting point of the ray.
direction: Vec3The direction for the ray to travel.
options: { layerType?: LayerType; maxDistance?: number; }(Optional) The options for configuring the raycast operation.
Returns
RaycastHit | nullThe collision information.
toString()
Creates a human-readable representation of the RaycastGizmo.

Signature
toString(): string;
Returns
stringA string representation of the RaycastGizmo.

SpawnController Class
Extends SpawnControllerBase
Represents a controller used to spawn assets.
Signature
export declare class SpawnController extends SpawnControllerBase
Constructors
(constructor)(asset, position, rotation, scale)
Creates a controller for spawning an asset.

Signature
constructor(asset: Asset, position: Vec3, rotation: Quaternion, scale: Vec3);
Parameters
asset: AssetThe asset to spawn.
position: Vec3The position of the asset in the world.
rotation: QuaternionThe rotation of the asset in the world.
scale: Vec3The scale of the asset in the world.

Properties
asset
[readonly]
The asset that is currently being spawned.

Signature
readonly asset: Asset;

SpawnControllerBase Class
The base class for a spawn controller.
Signature
export declare class SpawnControllerBase
Properties
_spawnId
The ID of the asset that is currently being spawned. This is a protected version of the property.

Signature
protected _spawnId: number;
currentState
[readonly]
The current spawn state of the spawn controller asset.

Signature
readonly currentState: ReadableHorizonProperty<SpawnState>;
rootEntities
[readonly]
A list of entities contained in a spawned asset.

Signature
readonly rootEntities: ReadableHorizonProperty<Entity[]>;
spawnError
[readonly]
An error associated with the spawn operation.

Signature
readonly spawnError: ReadableHorizonProperty<SpawnError>;
spawnId
[readonly]
The ID of the asset that is currently being spawned.

Signature
get spawnId(): number;
targetState
[readonly]
The spawn state the spawn controller asset is attempting to reach.

Signature
readonly targetState: ReadableHorizonProperty<SpawnState>;

Methods
dispose()
Unloads the asset data of a spawn controller, and performs cleanup on the spawn controller object.

Signature
dispose(): Promise<unknown>;
Returns
Promise<unknown>A promise that indicates whether the dispose operation succeeded.
Remarks
This method is equivalent to , except afterwards the spawn controller is no longer available for use and all of its methods throw errors. Call dispose in order to clean up resources that are no longer needed.
load()
Preloads the asset data for a spawn controller.

Signature
load(): Promise<void>;
Returns
Promise<void>A promise that indicates whether the operation succeeded.
pause()
Pauses the spawning process for a spawn controller.

Signature
pause(): Promise<void>;
Returns
Promise<void>A promise that indicates whether the operation succeeded.
spawn()
Loads asset data if it's not previously loaded and then spawns the asset.

Signature
spawn(): Promise<void>;
Returns
Promise<void>A promise that indicates whether the operation succeeded.
unload()
Unloads the spawn controller asset data. If the spawn controller isn't needed after the data is unloaded, call .

Signature
unload(): Promise<void>;
Returns
Promise<void>A promise that indicates whether the operation succeeded.

SpawnPointGizmo Class
Extends Entity
A Spawn Point gizmo, which you can use to teleport players to a location in a world using a fade-out/fade-in transition.
Signature
export declare class SpawnPointGizmo extends Entity
Remarks
For more information about using the Spawn Point gizmo, see Spawn Points guide.
Properties
gravity
The gravity for players spawned using this gizmo.

Signature
gravity: HorizonProperty<number>;
Remarks
Range = (0, 9.81)
speed
The speed for players spawned using this gizmo.

Signature
speed: HorizonProperty<number>;
Remarks
Range = (0, 45)

Methods
teleportPlayer(player)
Teleports a player to the spawn point.

Signature
teleportPlayer(player: Player): void;
Parameters
player: PlayerThe player to teleport.
Returns
void
toString()
Creates a human-readable representation of the SpawnPointGizmo.

Signature
toString(): string;
Returns
stringA string representation of the SpawnPointGizmo.

TextGizmo Class
Extends Entity
Represents a text label in the world.
Signature
export declare class TextGizmo extends Entity
Properties
text
The content to display in the text label.

Signature
text: HorizonProperty<string>;
Remarks
If the content was previously set with localizableText, the getter of this property will return the localized string in the language of the local player. Do not use the returned text in attributes shared with other players. Other players might use differnet languages, and only the LocalizableText object is localized.

Methods
toString()
Creates a human-readable representation of the entity.

Signature
toString(): string;
Returns
stringA string representation of the TextGizmo.

TextureAsset Class
Extends Asset
Represents a texture Asset. A texture is a binary image that is applied over the mesh surface. Texture images can be stretched (or shrunk) and attached to a mesh.
Signature
export declare class TextureAsset extends Asset
Methods
toString()
Gets a human readable representation of the object.

Signature
toString(): string;
Returns
stringa string representation of this asset.

TrailGizmo Class
Extends Entity
Represents a trail effect in the world.
Signature
export declare class TrailGizmo extends Entity
Properties
length
The length of the trail, in meters.

Signature
length: HorizonProperty<number>;
width
The width of the trail, in meters.

Signature
width: HorizonProperty<number>;

Methods
play()
Plays the trail effect.

Signature
play(): void;
Returns
void
stop()
Stops the trail effect.

Signature
stop(): void;
Returns
void
toString()
Creates a human-readable representation of the entity.

Signature
toString(): string;
Returns
stringA string representation of the entity.

Transform Class
A transform for an entity, which represents the position, rotation, and scale of the entity in a world.
Signature
export declare class Transform
Constructors
(constructor)(entity)
Constructs a new instance of the Transform class.

Signature
constructor(entity: Entity);
Parameters
entity: EntityThe entity to transform.

Properties
localPosition
The local position of the entity relative to its parent.

Signature
localPosition: HorizonProperty<Vec3>;
localRotation
Represents the rotation component of the entity relative to its parent.

Signature
localRotation: HorizonProperty<Quaternion>;
localScale
Represents the local scale of the entity relative to its parent.

Signature
localScale: HorizonProperty<Vec3>;
position
The position of the entity in the world.

Signature
position: HorizonProperty<Vec3>;
rotation
The rotation component of the entity.

Signature
rotation: HorizonProperty<Quaternion>;
scale
The scale of the entity in the world in the world.

Signature
scale: ReadableHorizonProperty<Vec3>;

TriggerGizmo Class
Extends Entity
Represents a Trigger in the world.
Signature
export declare class TriggerGizmo extends Entity
Properties
enabled
Whether the Trigger is enabled.

Signature
enabled: WritableHorizonProperty<boolean>;

Methods
getWhoCanTrigger()
Gets all the players that can trigger the entity.

Signature
getWhoCanTrigger(): Array<Player>;
Returns
Array<Player>An array of players that can trigger the entity.
Remarks
If the trigger is set to Objects, it will return an empty array.
If the trigger is set to Players, it will return all players (default) or the players given in .
setWhoCanTrigger(players)
Specifies the players that can trigger the entity.

Signature
setWhoCanTrigger(players: 'anyone' | Array<Player>): void;
Parameters
players: 'anyone' | Array<Player>An array of players that can trigger the entity, or 'anyone' (default).
Returns
void
Examples
trigger.setWhoCanTrigger('anyone'); // anyone can trigger
trigger.setWhoCanTrigger([]); // no one can trigger
trigger.setWhoCanTrigger([player1, player2]); // only those 2 players can trigger
toString()
Creates a human-readable representation of the entity.

Signature
toString(): string;
Returns
stringA string representation

Vec3 Class
Extends Comparable<Vec3>
Represents a 3D vector. This is the main class for creating and updating 3D points and directions in Horizon Worlds.
Signature
export declare class Vec3 implements Comparable<Vec3>
Examples
In this example, an entity is moved to a new location in a world by updating the properties of a Vec3 object.
entity.position.set(new Vec3(10, 20, 52));
Remarks
For information about rotating 3D vectors, see the Quaternion class.
Constructors
(constructor)(x, y, z)
Creates a 3D vector.

Signature
constructor(x: number, y: number, z: number);
Parameters
x: numberThe magnitude of the 3D vector along the X axis.
y: numberThe magnitude of the 3D vector along the Y axis.
z: numberThe magnitude of the 3D vector along the Z axis.

Properties
backward
static
[readonly]
A backward 3D vector: Vec3(0, 0, -1).

Signature
static get backward(): Vec3;
down
static
[readonly]
A down 3D vector: Vec3(0, -1, 0).

Signature
static get down(): Vec3;
forward
static
[readonly]
A forward 3D vector: Vec3(0, 0, 1).

Signature
static get forward(): Vec3;
left
static
[readonly]
A left 3D vector: Vec3(-1, 0, 0).

Signature
static get left(): Vec3;
one
static
[readonly]
A one 3D vector: Vec3(1, 1, 1).

Signature
static get one(): Vec3;
right
static
[readonly]
A right 3D vector: Vec3(1, 0, 0).

Signature
static get right(): Vec3;
up
static
[readonly]
An up 3D vector: Vec3(0, 1, 0).

Signature
static get up(): Vec3;
x
The magnitude of the 3D vector along the X axis.

Signature
x: number;
y
The magnitude of the 3D vector along the Y axis.

Signature
y: number;
z
The magnitude of the 3D vector along the Z axis.

Signature
z: number;
zero
static
[readonly]
A zero 3D vector: Vec3(0, 0, 0).

Signature
static get zero(): Vec3;

Methods
add(vec)
Adds two 3D vectors and returns the result in a new or an existing 3D vector.

Signature
static add(vecA: Vec3, vecB: Vec3, outVec?: Vec3): Vec3;
Parameters
vecA: Vec3The first 3D vector to add.
vecB: Vec3The second 3D vector to add.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3The new 3D vector that is the sum, if outVec is not provided.
add(vecA, vecB, outVec) static
Adds two 3D vectors and returns the result in a new or an existing 3D vector.

Signature
static add(vecA: Vec3, vecB: Vec3, outVec?: Vec3): Vec3;
Parameters
vecA: Vec3The first 3D vector to add.
vecB: Vec3The second 3D vector to add.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3The new 3D vector that is the sum, if outVec is not provided.
addInPlace(vec)
Adds a 3D vector to the current 3D vector, modifying the original 3D vector.

Signature
addInPlace(vec: Vec3): this;
Parameters
vec: Vec3The 3D vector to add.
Returns
this
clone()
Clones a 3D vector's values into a mutable Vec3.

Signature
clone(): Vec3;
Returns
Vec3A mutable Vec3 with the same x,y,z values.
componentDiv(vec)
Divides the current 3D vector's components by another 3D vector's components and returns the results.

Signature
componentDiv(vec: Vec3): Vec3;
Parameters
vec: Vec3The 3D vector to use as the divisor.
Returns
Vec3A new 3D vector.
Remarks
The division is performed as follows (a.x/b.x, a.y/b.y, a.z/b.z).
componentDivInPlace(vec)
Divides the current 3D Vector by another 3D vector, modifying the original 3D vector.

Signature
componentDivInPlace(vec: Vec3): this;
Parameters
vec: Vec3The 3D vector to divide by.
Returns
this
componentMul(vec)
Creates a 3D vector by multiplying the current 3D vector's components by another 3D vector's components.

Signature
componentMul(vec: Vec3): Vec3;
Parameters
vec: Vec3The additional 3D vector to multiply.
Returns
Vec3A new 3D vector.
Remarks
The vector components are multiplied as follows (a.x\*b.x, a.y\*b.y, a.z\*b.z).
componentMulInPlace(vec)
Muliplies the current 3D vector by another 3D vector, modifying the original 3D vector.

Signature
componentMulInPlace(vec: Vec3): this;
Parameters
vec: Vec3The 3D vector to multiply.
Returns
this
copy(vec)
Creates a copy of the specified 3D vector with the same x, y, and z values.

Signature
copy(vec: Vec3): this;
Parameters
vec: Vec3The 3D vector to copy.
Returns
thisA new 3D vector.
cross(vec)
Gets the cross product of two 3D vectors and returns the result in a new or an existing 3D vector.

Signature
static cross(vecA: Vec3, vecB: Vec3, outVec?: Vec3): Vec3;
Parameters
vecA: Vec3The left side 3D vector of the cross product.
vecB: Vec3The right side 3D vector of the cross product.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3A new 3D vector, if outVec is not provided.
cross(vecA, vecB, outVec) static
Gets the cross product of two 3D vectors and returns the result in a new or an existing 3D vector.

Signature
static cross(vecA: Vec3, vecB: Vec3, outVec?: Vec3): Vec3;
Parameters
vecA: Vec3The left side 3D vector of the cross product.
vecB: Vec3The right side 3D vector of the cross product.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3A new 3D vector, if outVec is not provided.
crossInPlace(vec)
Gets the cross product of the current 3D vector and another 3D vector, and modifies the current vector with the result.

Signature
crossInPlace(vec: Vec3): this;
Parameters
vec: Vec3The additional 3D vector to compute the cross product with.
Returns
this
distance(vec)
Gets the distance between the current 3D vector and another 3D vector.

Signature
distance(vec: Vec3): number;
Parameters
vec: Vec3The 3D vector to compare.
Returns
numberThe distance between the 3D vectors.
distanceSquared(vec)
Gets the squared distance between the current 3D vector and another 3D vector.

Signature
distanceSquared(vec: Vec3): number;
Parameters
vec: Vec3The 3D vector to compare.
Returns
numberThe squared distance between the 3D vectors.
div(scalar)
Performs a scalar division on a 3D vector and returns the result in a new or an existing 3D vector.

Signature
static div(vec: Vec3, scalar: number, outVec?: Vec3): Vec3;
Parameters
vec: Vec3The 3D vector to scale.
scalar: numberThe value to scale the 3D vector by.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3A new 3D vector, if outVec is not provided.
div(vec, scalar, outVec) static
Performs a scalar division on a 3D vector and returns the result in a new or an existing 3D vector.

Signature
static div(vec: Vec3, scalar: number, outVec?: Vec3): Vec3;
Parameters
vec: Vec3The 3D vector to scale.
scalar: numberThe value to scale the 3D vector by.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3A new 3D vector, if outVec is not provided.
divInPlace(scalar)
Divides the current 3D vector by a scalar value, modifying the original 3D vector.

Signature
divInPlace(scalar: number): this;
Parameters
scalar: numberThe scalar value to divide by.
Returns
this
dot(vec)
Gets the dot product of the two 3D vectors.

Signature
static dot(vecA: Vec3, vecB: Vec3): number;
Parameters
vecA: Vec3The first 3D vector of the dot product.
vecB: Vec3The second 3D vector of the dot product.
Returns
numberThe dot product of the 3D vectors.
dot(vecA, vecB) static
Gets the dot product of the two 3D vectors.

Signature
static dot(vecA: Vec3, vecB: Vec3): number;
Parameters
vecA: Vec3The first 3D vector of the dot product.
vecB: Vec3The second 3D vector of the dot product.
Returns
numberThe dot product of the 3D vectors.
equals(vec)
Determines whether two 3D vectors are equal.

Signature
static equals(vecA: Vec3, vecB: Vec3): boolean;
Parameters
vecA: Vec3The first 3D vector to compare.
vecB: Vec3The second 3D vector to compare.
Returns
booleantrue if the 3D vectors are equal; false otherwise.
Remarks
3D vectors are equal if they have the same x, y, and z components.
To determine whether the vectors are within a given range of each other, see the method.
equals(vecA, vecB) static
Determines whether two 3D vectors are equal.

Signature
static equals(vecA: Vec3, vecB: Vec3): boolean;
Parameters
vecA: Vec3The first 3D vector to compare.
vecB: Vec3The second 3D vector to compare.
Returns
booleantrue if the 3D vectors are equal; false otherwise.
Remarks
3D vectors are equal if they have the same x, y, and z components.
To determine whether the vectors are within a given range of each other, see the method.
equalsApprox(vec, epsilon)
Determines whether two 3D vectors are relatively equal.

Signature
static equalsApprox(vecA: Vec3, vecB: Vec3, epsilon?: number): boolean;
Parameters
vecA: Vec3The first 3D vector to compare.
vecB: Vec3The second 3D vector to compare.
epsilon: number(Optional) The maxium difference to consider equal.
Returns
booleantrue if the 3D vectors are relatively equal; false otherwise.
Remarks
The vectors are relatively equal if the difference between their x, y, and z components doesn't exceed the value provided in the epsilon paramter.
To determine whether the vectors are equal, see .
equalsApprox(vecA, vecB, epsilon) static
Determines whether two 3D vectors are relatively equal.

Signature
static equalsApprox(vecA: Vec3, vecB: Vec3, epsilon?: number): boolean;
Parameters
vecA: Vec3The first 3D vector to compare.
vecB: Vec3The second 3D vector to compare.
epsilon: number(Optional) The maxium difference to consider equal.
Returns
booleantrue if the 3D vectors are relatively equal; false otherwise.
Remarks
The vectors are relatively equal if the difference between their x, y, and z components doesn't exceed the value provided in the epsilon paramter.
To determine whether the vectors are equal, see .
lerp(vecA, vecB, amount, outVec) static
Performs a lerp (linear interpolation) between two 3D vectors.

Signature
static lerp(vecA: Vec3, vecB: Vec3, amount: number, outVec?: Vec3): Vec3;
Parameters
vecA: Vec3The first vec3 to lerp.
vecB: Vec3The second vec3 to lerp.
amount: numberThe gradient to use for interpolation (clamped 0 to 1)
outVec: Vec3(Optional) The new 3D vector as a result of the operation. If not supplied, a new 3D vector is created and returned.
Returns
Vec3A new 3D vector, if outVec is not supplied.
magnitude()
Gets the magnitude of a 3D vector.

Signature
magnitude(): number;
Returns
numberThe magnitude of the 3D vector.
Remarks
The magnitude of a 3D vector is its length.
magnitudeSquared()
Gets the squared magnitude of a 3D vector.

Signature
magnitudeSquared(): number;
Returns
number
mul(scalar)
Performs a scalar multiplication on a 3D vector and returns the result in a new or an existing 3D vector.

Signature
static mul(vec: Vec3, scalar: number, outVec?: Vec3): Vec3;
Parameters
vec: Vec3The 3D vector to scale.
scalar: numberThe value to scale the 3D vector by.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3A new 3D vector, if outVec is not provided.
mul(vec, scalar, outVec) static
Performs a scalar multiplication on a 3D vector and returns the result in a new or an existing 3D vector.

Signature
static mul(vec: Vec3, scalar: number, outVec?: Vec3): Vec3;
Parameters
vec: Vec3The 3D vector to scale.
scalar: numberThe value to scale the 3D vector by.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3A new 3D vector, if outVec is not provided.
mulInPlace(scalar)
Multiplies the current 3D vector by a scalar value, modifying the original 3D vector.

Signature
mulInPlace(scalar: number): this;
Parameters
scalar: numberThe value to scale the 3D vector by.
Returns
this
normalize()
Normalizes a 3D vector (changes the magnitude to 1) and returns the result in a new or an existing 3D vector.

Signature
static normalize(vec: Vec3, outVec?: Vec3): Vec3;
Parameters
vec: Vec3The 3D vector to normalize.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3A new 3D vector, if outVec is not provided.
normalize(vec, outVec) static
Normalizes a 3D vector (changes the magnitude to 1) and returns the result in a new or an existing 3D vector.

Signature
static normalize(vec: Vec3, outVec?: Vec3): Vec3;
Parameters
vec: Vec3The 3D vector to normalize.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3A new 3D vector, if outVec is not provided.
normalizeInPlace()
Normalizes the 3D vector (changes its magnitude to 1).

Signature
normalizeInPlace(): this;
Returns
this
reflect(normal)
Reflects the current 3D vector off a surface defined by a normal and returns the result.

Signature
reflect(normal: Vec3): Vec3;
Parameters
normal: Vec3The normal vector that defines the reflecting surface. This value should be normalized.
Returns
Vec3A new 3D vector that defines the reflection.
reflectInPlace(normal)
Reflects the current 3D vector off a surface defined by a normal and modifies the orginal vector with the result.

Signature
reflectInPlace(normal: Vec3): this;
Parameters
normal: Vec3The normal vector that defines the reflecting surface. This value should be normalized.
Returns
this
sub(vec)
Subtracts a 3D vector from another and returns the result in a new or an existing 3D vector.

Signature
static sub(vecA: Vec3, vecB: Vec3, outVec?: Vec3): Vec3;
Parameters
vecA: Vec3The 3D vector to substract from.
vecB: Vec3The 3D vector to subtract.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3A new 3D vector, if outVec is not provided.
sub(vecA, vecB, outVec) static
Subtracts a 3D vector from another and returns the result in a new or an existing 3D vector.

Signature
static sub(vecA: Vec3, vecB: Vec3, outVec?: Vec3): Vec3;
Parameters
vecA: Vec3The 3D vector to substract from.
vecB: Vec3The 3D vector to subtract.
outVec: Vec3(Optional) The resulting 3D vector. If not provided, a new 3D vector is created and returned.
Returns
Vec3A new 3D vector, if outVec is not provided.
subInPlace(vec)
Subtracts a 3D vector from the current 3D vector, modifying the original 3D vector.

Signature
subInPlace(vec: Vec3): this;
Parameters
vec: Vec3The 3D vector to subtract.
Returns
this
toString()
Gets a string representation of the x, y, and z values for the 3D vector.

Signature
toString(): string;
Returns
stringThe x, y, and z values.

World Class
Represents a virtual world in Horizon Worlds, which provides access to properties, events, and operations related to the world state; including events scripts can use to time operations based on state changes to the world.
Signature
export declare class World
Properties
id
Returns the current world ID.

Signature
id: ReadableHorizonProperty<bigint>;
leaderboards
The leaderboards for the players in the world.

Signature
leaderboards: ILeaderboards;
matchmaking
The matchmaking system for queueing players into the world.

Signature
matchmaking: {
        allowPlayerJoin(allow: boolean): Promise<void>;
    };
Remarks
allowPlayerJoin - Indicates whether players can join the world.
name
The human-readable name of the world.

Signature
name: ReadableHorizonProperty<string>;
onPrePhysicsUpdate
static
[readonly]
An event that broadcasts on every rendered frame before the physics engine updates the world state. This event is especially useful for timing animations and entity locations before physics calculations are performed.

Signature
static readonly onPrePhysicsUpdate: LocalEvent<{
        deltaTime: number;
    }>;
Remarks
The World.onPrePhysicsUpdate event provides similar functionality, but after the physics engine performs calculations.
For more information about subscribing to world update events, see the World Update Events guide.
onUpdate
static
[readonly]
An event that broadcasts on every rendered frame in the world, allowing synchronization between the state of the world and the rendering pipeline. You can use this event to time animations, physics, and entity transforms for optimal performance.

Signature
static readonly onUpdate: LocalEvent<{
        deltaTime: number;
    }>;
Remarks
By subscribing to this event, a script can perform operations during the world update loop, such as spawning an asset.
The World.onPrePhysicsUpdate event provides similar functionality, but before the physics engine performs calculations.
For more information about subscribing to world update events, see the World Update Events guide.
persistentStorage
A persistent storage object, which contains a set of functions that interact with player variables.
For information about using player variables, see the Persistent Variables guide.

Signature
persistentStorage: IPersistentStorage;
ui
Basic UI functions for displaying popups and tooltips.

Signature
ui: IUI;
Remarks
For an example, see the Lobby tutorial.

Methods
deleteAsset(entity, fullDelete)
Removes a previously spawned asset from the world.

Signature
deleteAsset(entity: Entity, fullDelete?: boolean): Promise<undefined>;
Parameters
entity: EntityThe previously spawned entity.
fullDelete: boolean(Optional) if true, the entity must be the root object, thus deleting all sub-objects.
Returns
Promise<undefined>A promise that resolves when the entity has been deleted.
getEntitiesWithTags(tags, matchOperation)
Gets all world entities containing the provided tags using the provided match operation.

Signature
getEntitiesWithTags(tags: string[], matchOperation?: EntityTagMatchOperation): Entity[];
Parameters
tags: string[]An array of tag names to match against. The comparison is case sensitive.
matchOperation: EntityTagMatchOperation(Optional) The match operation to run when searching for entities with given tags. Defaults to EntityTagMatchOperation.HasAnyExact.
Returns
Entity[]An array of all of the entities matching the tags and operation.
Examples
entityA.tags.set(['tag1', 'tag2', 'tag3']);
entityB.tags.set(['tag2', 'tag3', 'tag4']);
entitiesWithAnytags = this.world.getEntitiesWithTags(['tag1', 'tag2'], EntityTagMatchOperation.MatchAny); // returns entityA & entityB
entitiesWithAlltags = this.world.getEntitiesWithTags(['tag3', 'tag4'], EntityTagMatchOperation.MatchAll); // returns entityB
Remarks
This is an expensive operation and should be used carefully.
getLocalPlayer()
Gets the player corresponding to the local Horizon Worlds client running on some player's machine where this script is currently executing.

Signature
getLocalPlayer(): Player;
Returns
PlayerThe local player.
Remarks
This is particularly useful for Local Scripting to figure out which player's machine a local script is executing on. Note that if the local script is executing on the server, this will return the server player.
getPlayerFromIndex(playerIndex)
Gets the Player object for the given player index.

Signature
getPlayerFromIndex(playerIndex: number): Player | null;
Parameters
playerIndex: numberThe index of the player. Retrievable with the Player.index property.
Returns
Player | nullThe player corresponding to that index, or null if no player exists at the index.
getPlayers()
Gets all players currently in the world, not including the server player.

Signature
getPlayers(): Player[];
Returns
Player[]An array of Player objects in the world.
getServerPlayer()
Gets the player corresponding to the server Horizon Worlds client.

Signature
getServerPlayer(): Player;
Returns
PlayerThe server player.
Remarks
This is particularly useful for Local Scripting to figure out if a script is executing on some client other than the server. Note that a server player is not physically present in the world and does not support a number of standard features (such as name.get() or being moved) that normal players do.
reset()
Resets the world's state. This sets all entities back to their initial position, cancels all event and event listeners, and restarts scripts in the world.

Signature
reset(): void;
Returns
void
spawnAsset(asset, position, rotation, scale)
Asynchronously spawns an asset.

Signature
spawnAsset(asset: Asset, position: Vec3, rotation?: Quaternion, scale?: Vec3): Promise<Entity[]>;
Parameters
asset: AssetThe asset to spawn.
position: Vec3The position where the asset is spawned.
rotation: Quaternion(Optional) The rotation of the spawned asset. If invalid, is replace with Quaternion.one (no rotation).
scale: Vec3(Optional) The scale of the spawned asset.
Returns
Promise<Entity[]>A promise resolving to all of the root entities within the asset.
toString()
Creates a string representation of the World object.

Signature
toString(): string;
Returns
stringA string representation of the World object.
update(updateType, deltaTime)
Called on every frame.

Signature
update(updateType: WorldUpdateType, deltaTime: number): undefined;
Parameters
updateType: WorldUpdateTypeThe type of update.
deltaTime: numberThe duration, in seconds, since the last frame.
Returns
undefined

AnimationCallbackReasons Enum
The possible reasons for the AnimationCallbackReason type that is provided when an animation callback triggers.
Signature
export declare enum AnimationCallbackReasons
Enumeration Members
Member
Value
Description
Starting
0
The animation is starting to play.
Stopping
1
The animation is stopping.

AttachablePlayerAnchor Enum
The location of an attachment point on a player.
Signature
export declare enum AttachablePlayerAnchor
Enumeration Members
Member
Value
Description
Head
"Head"
The attachment is at the head.
Torso
"Torso"
The attachment is at the torso.

AudibilityMode Enum
Determines whether sound from an AudioGizmo is audible to specific players.
Signature
export declare enum AudibilityMode
Enumeration Members
Member
Value
Description
AudibleTo
0
The sound is audible.
InaudibleTo
1
The sound is inaudible.

AvatarGripPose Enum
The type of grip animation assigned to an avatar when holding an object.
Signature
export declare enum AvatarGripPose
Enumeration Members
Member
Value
Description
CarryHeavy
"CarryHeavy"
Generic grip for carrying heavier objects
CarryLight
"CarryLight"
Generic grip for carrying lighter objects
Default
"Default"
The Default grip type.
Fishing
"Fishing"
Held in a fishing grip.
Pistol
"Pistol"
Held in a pistol grip.
Rifle
"Rifle"
Held in a rifle grip.
RPG
"RPG"
Held in an RPG grip.
Shield
"Shield"
Held in a shield grip.
Shotgun
"Shotgun"
Held in a shotgun grip.
Sword
"Sword"
Held in a sword grip.
Torch
"Torch"
Held in a torch grip.

AvatarGripPoseAnimationNames Enum
Defines the currently available avatar grip pose animations.
Signature
export declare enum AvatarGripPoseAnimationNames
Enumeration Members
Member
Value
Description
CancelThrow
"CancelThrow"
Cancels the "ReadyThrow" or "ChargeThrow" animations.
ChargeThrow
"ChargeThrow"
Puts the player into a "Charging up throw" animation.
Fire
"Fire"
Fire animation for the player.
ReadyThrow
"ReadyThrow"
Puts the player into a "Ready to throw" animation.
Reload
"Reload"
Reload animation for the player.
Throw
"Throw"
Throw animation for the player.

ButtonIcon Enum
The icons to use when binding to custom player inputs. These are used on platforms that display buttons for inputs.
Signature
export declare enum ButtonIcon
Enumeration Members
Member
Value
Description
Ability
0
The icon for Ability.
Aim
1
The icon for Aim.
Airstrike
2
The icon for Airstrike.
Contract
42
The icon for Contract.
Crouch
3
The icon for Crouch.
Door
4
The icon for Door.
Drink
5
The icon for Drink.
Drop
6
The icon for Drop.
DualWield
7
The icon for Dual Wield.
EagleEye
8
The icon for Eagle Eye.
Eat
9
The icon for Eat.
Expand
41
The icon for Expand.
Fire
11
The icon for Fire.
FireSpecial
10
The icon for Fire Special.
Grab
12
The icon for Grab.
Heal
13
The icon for Heal.
InfiniteAmmo
14
The icon for Infinite Ammo.
Inspect
15
The icon for Inspect.
Interact
16
The icon for Interact.
Invisible
17
The icon for invisible.
Jump
18
The icon for Jump.
LeftChevron
44
The icon for ChevronLeft.
Map
43
The icon for Map.
Menu
46
The icon for Menu.
MouseLeft
19
The icon for House Left.
MouseMiddle
20
The icon for Mouse Middle.
MouseRight
21
The icon for Mouse Right.
MouseScroll
22
The icon for Mouse Scroll.
Net
23
The icon for Net.
None
24
The icon for None.
Place
25
The icon for Place.
Punch
40
The icon for Punch.
Purchase
26
The icon for Purchase.
Reload
27
The icon for Reload.
RightChevron
45
The icon for ChevronRight.
Rocket
30
The icon for Rocket.
RocketJump
28
The icon for Rocket Jump.
RocketVolley
29
The icon for Rocket Volley.
Shield
31
The icon for Shield.
Speak
32
The icon for Speak.
Special
33
The icon for Special.
SpeedBoost
34
The icon for Speed Boost.
Sprint
35
The icon for Sprint.
Swap
36
The icon for Swap.
SwingWeapon
37
The icon for Swing Weapon.
Throw
38
The icon for Throw.
Use
39
The icon for Use.

ButtonPlacement Enum
The available button placements.
Signature
export declare enum ButtonPlacement
Enumeration Members
Member
Value
Description
Center
1
Centered. Bottom center of the screen on most devices.
Default
0
The device's default placement for this button.

EntityInteractionMode Enum
The options for interacting with an entity.
Signature
export declare enum EntityInteractionMode
Enumeration Members
Member
Value
Description
Both
"Both"
The entity can be grabbed and supports physics.
Grabbable
"Grabbable"
The entity can be grabbed.
Invalid
"Invalid"
The entity cannot be grabbed, and does not support physics.
Physics
"Physics"
The entity supports physics and can be moved by script.

EntityTagMatchOperation Enum
Defines the valid matching operations that are available when using getEntitiesWithTags() to find world entities.
Signature
export declare enum EntityTagMatchOperation
Enumeration Members
Member
Value
Description
HasAllExact
1
All of the sought tags must be present in an Entity's tags for that entity to be included in the result. The match must be exact.
HasAnyExact
0
A single match encountered in an Entity's tags results in that entity being included in the result. The match must be exact.

EulerOrder Enum
Defines the orientation of the x, y, z axis in space.
Signature
export declare enum EulerOrder
Enumeration Members
Member
Value
Description
XYZ
"XYZ"
The orientation is XYZ.
XZY
"XZY"
The orientation is XZY.
YXZ
"YXZ"
The orientation is YXZ.
YZX
"YZX"
The orientation is YZX.
ZXY
"ZXY"
The orientation is ZXY.
ZYX
"ZYX"
The orientation is ZYX.

EventTargetType Enum
The target or destination of an event.
Signature
export declare enum EventTargetType
Enumeration Members
Member
Value
Description
Broadcast
2
A broadcast event.
Entity
0
An entity.
Player
1
A player.

Handedness Enum
Indicates whether a player is left or right-handed.
Signature
export declare enum Handedness
Enumeration Members
Member
Value
Description
Left
0
The player is left-handed.
Right
1
The player is right-handed.

HapticSharpness Enum
The sharpness of the haptic pulse.
Signature
export declare enum HapticSharpness
Enumeration Members
Member
Value
Description
Coarse
1
The pulse is medium.
Sharp
0
The pulse is sharp.
Soft
2
The pulse is soft.

HapticStrength Enum
The strength of a haptic pulse.
Signature
export declare enum HapticStrength
Enumeration Members
Member
Value
Description
Light
1
The player is touching the controller and should fire a light haptic.
Medium
2
The player is touching the controller and should fire a medium haptic.
Strong
3
The player is touching the controller and should fire a strong haptic.
VeryLight
0
The player is not touching the controller, so no haptic pulse will be fired.

LayerType Enum
The type of layer in the world.
Signature
export declare enum LayerType
Enumeration Members
Member
Value
Description
Both
2
The layer is for both players and objects.
Objects
1
The layer is for objects.
Player
0
The layer for players.

MonetizationTimeOption Enum
Indicates how to display time in a world using the monetary gizmo.
Signature
export declare enum MonetizationTimeOption
Enumeration Members
Member
Value
Description
Days
"DAYS"
The time is displayed in days.
Hours
"HOURS"
The time is displayed in hours.
Seconds
"SECONDS"
The time is displayed in seconds.

PhysicsForceMode Enum
Indicates how physics is applied to an object in the world.
Signature
export declare enum PhysicsForceMode
Enumeration Members
Member
Value
Description
Force
0
Add a continuous force to an object, using its mass. The acceleration = Force * Time ^ 2 / Mass.
Impulse
1
Add an instant force impulse to an object, using its mass. The acceleration = Force * Time / Mass.
VelocityChange
2
Add an instant velocity change to an object, ignoring its mass. The acceleration = Force * Time.

PlayerBodyPartType Enum
The type of body part of a player.
Signature
export declare enum PlayerBodyPartType
Enumeration Members
Member
Value
Description
Foot
1
The body part is a foot.
Head
0
The body part is a head.
LeftHand
3
The body part is a left hand.
RightHand
4
The body part is a right hand.
Torso
2
The body part is a torso.

PlayerDeviceType Enum
The type of device the player is using.
Signature
export declare enum PlayerDeviceType
Enumeration Members
Member
Value
Description
Desktop
"Desktop"
The player is using an desktop device.
Mobile
"Mobile"
The player is using a mobile device.
VR
"VR"
The player is using a VR device.

PlayerInputAction Enum
The input actions available for the local player. The actions are bound to specific keys by default on multiple platforms.
Signature
export declare enum PlayerInputAction
Enumeration Members
Member
Value
Description
Jump
0
Oculus Touch: A
Desktop: spacebar
Mobile: on-screen button
LeftGrip
11
Oculus Touch: left analog grip button
Desktop: Q
Mobile: on-screen button
LeftPrimary
8
Oculus Touch: X
Desktop: T
Mobile: on-screen button
LeftSecondary
9
Oculus Touch: Y
Desktop: G
Mobile: on-screen button
LeftTertiary
10
Oculus Touch: left thumbstick click
Desktop: H
Mobile: on-screen button
LeftTrigger
12
Oculus Touch: left analog trigger
Desktop: right mouse click
Mobile: on-screen button
LeftXAxis
13
Oculus Touch: left stick X Axis
Desktop: A/D
Mobile: Unavailable
LeftYAxis
14
Oculus Touch: left stick Y axis
Desktop: W/S
Mobile: Unavailable
RightGrip
4
Oculus Touch: right analog grip button
Desktop: E
Mobile: on-screen button
RightPrimary
1
Oculus Touch: right thumbstick click
Desktop: R
Mobile: on-screen button
RightSecondary
2
Oculus Touch: B
Desktop: F
Mobile: on-screen button
RightTertiary
3
Oculus Touch: Unavailable
Desktop: Y
Mobile: on-screen button
RightTrigger
5
Oculus Touch: right analog trigger
Desktop: left mouse click
Mobile: on-screen button
RightXAxis
6
Oculus Touch: right stick X axis
Desktop: Unavailable
Mobile: Unavailable
RightYAxis
7
Oculus Touch: right stick Y axis
Desktop: Unavailable
Mobile: Unavailable

Remarks


The member descriptions contain a list of the default bindings. The bindings are valid with the user setting Jump Controls set to Press A button. These bindings are affected by the Jump Controls user setting.
PlayerVisibilityMode Enum
The entity visibility options for a set of players.
Signature
export declare enum PlayerVisibilityMode
Enumeration Members
Member
Value
Description
HiddenFrom
1
The entity is not visible to the specified players.
VisibleTo
0
The entity is visible to the specified players.

RaycastTargetType Enum
The target type during a raycast collision.
Signature
export declare enum RaycastTargetType
Enumeration Members
Member
Value
Description
Entity
1
An entity.
Player
0
A player.
Static
2
A static object.

Space Enum
Indicates whether a method or object operates in local or global scope.
Signature
export declare enum Space
Enumeration Members
Member
Value
Description
Local
1
The method operates in a local scope.
World
0
The method operates in a global scope.

SpawnError Enum
The possible errors encounted during asset spawning.
Signature
export declare enum SpawnError
Enumeration Members
Member
Value
Description
Cancelled
2
The spawn was cancelled by the user.
ExceedsCapacity
1
The spawn failed due to capacity limitations.
InvalidAsset
3
The specified asset ID was invalid or that type of asset cannot be spawned.
InvalidParams
5
One of more of the request parameters is not valid.
None
0
No error since the last attempt to spawn.
UnauthorizedContent
4
The asset contains content which is not approved for spawning in this world.
Unknown
6
An unexpected error.

SpawnState Enum
The available spawn states for the asset of an entity.
Signature
export declare enum SpawnState
Enumeration Members
Member
Value
Description
Active
5
The spawn is complete and the asset and ready for use.
Disposed
7
The spawn controller is disposed and is not longer available for use.
Loaded
4
The load is complete and ready to be enabled, but does not yet count towards capacity.
Loading
2
The asset data is being loaded.
NotReady
0
The asset data is not yet available.
Paused
3
The asset spawn operition is paused.
Unloaded
1
The asset data is available, but not loaded.
Unloading
6
The spawned asset is in the process of unloading.

TooltipAnchorLocation Enum
The location where a tooltip is anchored.
Signature
export declare enum TooltipAnchorLocation
Enumeration Members
Member
Value
Description
LEFT_WRIST
"LEFT_WRIST"
The tooltip is anchored at the left wrist.
RIGHT_WRIST
"RIGHT_WRIST"
The tooltip is anchored at the right wrist.
TORSO
"TORSO"
The tooltip is anchored at the torso.

assert() Function
Asserts that an expression is true.
Signature
export declare function assert(condition: boolean): void;
Parameters
condition: booleanThe expression that must be true to avoid an error.
Returns
void
clamp() Function
Clamps a value between a minimum value and a maximum value.
Signature
export declare function clamp(value: number, min: number, max: number): number;
Parameters
value: numberThe value to clamp.
min: numberThe minimum value.
max: numberThe maxium value.
Returns
numberThe clamped value.
 lass Interface
An interface representing a class.
Signature
export interface Class<TConstructorParameters extends any[] = any[], TClassInstance = unknown>
Methods
(new)(args)
Creates a new instance of the class.

Signature
new (...args: TConstructorParameters): TClassInstance;
Parameters
args: TConstructorParametersThe arguments for creating the instance.
Returns
TClassInstanceThe new class instance.

Comparable Interface
The Comparable interface defines a set of methods for comparing values of the same type, including equals() and equalsApprox() methods.
Signature
export interface Comparable<T>
Methods
equals(val)
Whether the two values are equal.

Signature
equals(val: T): boolean;
Parameters
val: TThe value to compare to the current value.
Returns
boolean
equalsApprox(val, epsilon)
Whether two values are within epsilon of each other.

Signature
equalsApprox(val: T, epsilon?: number): boolean;
Parameters
val: TThe value to compare to the current value.
epsilon: number(Optional) The difference between the two values when they are equal.
Returns
boolean

DisposableObject Interface
An interface for objects that allow registration of additional dispose time operations.
Signature
export interface DisposableObject
Remarks
Implemented by Component, this inteface is typically used to tie the lifetime of API objects to the lifetime of the component that uses them. However, creators can register their own operations instead of implementing dispose, or implement their own disposable object for advanced scenarios requiring custom lifetime management.
The implementation of DisposableObject on Component runs the dispose operations when the component is destroyed (such as at world teardown or asset despawn), or when ownership is transfered between clients. Other implementations of DisposableObject may have different semantics.
For information about component lifecycles, see the TypeScript component lifecyle guide.
Methods
dispose()
Called when the disposable object is cleaned up.

Signature
dispose(): void;
Returns
void
registerDisposeOperation(operation)
Called to register a single dispose operation. The operation is run automatically at Object dispose time, unless it is manually run or canceled before the object is disposed.

Signature
registerDisposeOperation(operation: DisposeOperation): DisposeOperationRegistration;
Parameters
operation: DisposeOperationA function called to perform a single dispose operation.
Returns
DisposeOperationRegistrationA registration object that can be used to manually run or cancel the operation before dispose.

DisposeOperationRegistration Interface
The object returned from a call to DisposableObject.registerDisposeOperation(). This object can be used to run the operation manually before dispose time, or to cancel the operation entirely.
Signature
export interface DisposeOperationRegistration
Properties
cancel
Cancels the dispose operation so that it is never runs.

Signature
cancel: () => void;
run
Manually run the dispose operation before the DisposableObject is disposed. Dispose operations are only run once--a call to run guarantees the operation will not run at dispose time.

Signature
run: () => void;

EntityStyle Interface
Represents a style for a Custom model entity that can change its style.
Signature
export interface EntityStyle
Properties
brightness
Brightness in the range of 0 - 100; where 0 is black, 1 is no adjustment, and 100 is very bright; defaults to 1.

Signature
brightness: HorizonProperty<number>;
tintColor
Color in the RGB range of 0 - 1; defaults to 1, 1, 1 (no tint color).

Signature
tintColor: HorizonProperty<Color>;
tintStrength
Tint strength in the range of 0 - 1; where 0 is no tint and 1 is fully tinted; defaults to 0.

Signature
tintStrength: HorizonProperty<number>;



EventSubscription Interface
Represents what is returned from subscribing to an event.
Signature
export interface EventSubscription
Properties
disconnect
Disconnect from an event listener so that you no longer receive events.

Signature
disconnect: () => void;

ILeaderboards Interface
The leaderboards for the players in the world.
Signature
export interface ILeaderboards
Methods
setScoreForPlayer(leaderboardName, player, score, override)
Sets the leaderboard score for a player.

Signature
setScoreForPlayer(leaderboardName: string, player: Player, score: number, override: boolean): void;
Parameters
leaderboardName: stringThe name of the leader board.
player: PlayerThe player for whom the score is updated.
score: numberThe new score.
override: booleanIf true, overrides the previous score; otherwise the previous score is retained.
Returns
void

IPersistentStorage Interface
A persistent storage object, which contains a set of functions that interact with player variables.
For information about using player variables, see the Persistent Variables guide.
Signature
export interface IPersistentStorage
Methods
getPlayerVariable(player, key)
Gets the value of a persistent player variable.

Signature
getPlayerVariable<T extends PersistentSerializableState = number>(player: Player, key: string): T extends number ? T : T | null;
Parameters
player: PlayerThe player for whom to get the value.
key: stringThe name of the variable to get.
Returns
T extends number ? T : T | nullThe value of the variable as some PersistentSerializableState, defaulting to number.
setPlayerVariable(player, key, value)
Sets a persistent player variable

Signature
setPlayerVariable<T extends PersistentSerializableState>(player: Player, key: string, value: T): void;
Parameters
player: PlayerThe player for whom to set the value.
key: stringThe name of the variable to set.
value: TThe value to assign to the variable.
Returns
void

IUI Interface
Basic UI functions for displaying popups and tooltips.
Signature
export interface IUI
Remarks
For an example, see the Lobby tutorial.
Methods
dismissTooltip(player, playSound)
Dismisses any active tooltip for the target player

Signature
dismissTooltip(player: Player, playSound?: boolean): void;
Parameters
player: Playerthe player that has their tooltip dismissed
playSound: boolean(Optional) determines if a default "close sound" should play when the tooltip is closed
Returns
void
showPopupForEveryone(text, displayTime, options)
Shows a popup modal to all players.

Signature
showPopupForEveryone(text: string | i18n_utils.LocalizableText, displayTime: number, options?: Partial<PopupOptions>): void;
Parameters
text: string | i18n_utils.LocalizableTextThe text to display in the popup.
displayTime: numberThe duration, in seconds, to display the popup.
options: Partial<PopupOptions>(Optional) The configuration, such as color or position, for the popup.
Returns
void
showPopupForPlayer(player, text, displayTime, options)
Shows a popup modal to a player.

Signature
showPopupForPlayer(player: Player, text: string | i18n_utils.LocalizableText, displayTime: number, options?: Partial<PopupOptions>): void;
Parameters
player: PlayerThe player to whom the popup is to displayed.
text: string | i18n_utils.LocalizableTextThe text to display in the popup.
displayTime: numberThe duration, in seconds, to display the popup.
options: Partial<PopupOptions>(Optional) The configuration, such as color or position, for the popup.
Returns
void
showTooltipForPlayer(player, tooltipAnchorLocation, tooltipText, options)
Shows a tooltip modal to a specific player

Signature
showTooltipForPlayer(player: Player, tooltipAnchorLocation: TooltipAnchorLocation, tooltipText: string | i18n_utils.LocalizableText, options?: Partial<TooltipOptions>): void;
Parameters
player: Playerthe player this tooltip displays for
tooltipAnchorLocation: TooltipAnchorLocationthe anchor point that is used to determine the tooltip display location
tooltipText: string | i18n_utils.LocalizableTextthe message the tooltip displays
options: Partial<TooltipOptions>(Optional) configuration for the tooltip (display line, play sounds, attachment entity, etc)
Returns
void

ReadableHorizonProperty Interface
Represents a readable property.
Signature
export interface ReadableHorizonProperty<T>
Remarks
You cannot get the property value directly; you must use get. Using get typically results in a bridge call and might result in lower performance. Therefore, we recommend caching these values when possible.
Methods
get()
Gets the property value.

Signature
get(): T;
Returns
Tthe property value

WritableHorizonProperty Interface
Represents a writable property.
Signature
export interface WritableHorizonProperty<T, U = never>
Remarks
You cannot set the property value directly; you must use set. Using set typically results in a bridge call and might result in lower performance. Therefore, we recommend caching these values when possible.
Methods
set(value, values)
Sets the value(s) of the property

Signature
set(value: T, ...values: [U?]): void;
Parameters
value: Tthe new property value
values: [U?]the new property values
Returns
void

AimAssistOptions type
The available options for enabling Aim Assist with the Player.setAimAssistTarget() method.
Signature
export declare type AimAssistOptions = {
    assistanceStrength?: number;
    targetSize?: number;
    noInputGracePeriod?: number;
};
Remarks
assistanceStrength - The intensity of the pulling force towards the Aim Assist target, in degrees of camera rotation per second. The default value is 10.
targetSize - The size of the target used to determine whether the assistance forces apply, in meters. A bigger target causes the assistance to apply when the aiming reticle (center of the screen) is farther away from the center of the target. The default value is 4.
noInputGracePeriod - The duration in seconds after which the aim assistance stops being applied when no input is received. 0 = infinite. The default value is 1.
AnimationCallback type
A callback that signals changes in the pressed state of a PlayerInput object. This callback is used to inform scripts when an avatar animation starts or completes, so the script can respond to the animations.
Signature
export declare type AnimationCallback = (animation: Asset, reason: AnimationCallbackReason) => void;
References
Asset, AnimationCallbackReason
Remarks
This callback is optionally provided by the Player.playAvatarAnimation() and Player.stopAvatarAnimation() methods when providing custom avatar animations.
AnimationCallbackReason type
Represents the reason that an animation callback triggered, such as if the animation is starting or stopping.
Signature
export declare type AnimationCallbackReason = AnimationCallbackReasons;
References
AnimationCallbackReasons
AudioOptions type
Provides AudioGizmo playback options for a set of players.
Signature
export declare type AudioOptions = {
    fade: number;
    players?: Array<Player>;
    audibilityMode?: AudibilityMode;
};
References
Player, AudibilityMode
Remarks
fade - The duration, in seconds, that it takes for the audio to fade in or fade out.
players - Only plays the audio for the specified players.
audibilityMode - Indicates whether the audio is audible to the specified players. See AudibilityMode for more information.
vatarGripPoseAnimationCallback type
A callback used to signal changes in the animation state of a player
Signature
export declare type AvatarGripPoseAnimationCallback = (reason: AnimationCallbackReason) => void;
References
AnimationCallbackReason
BuiltInVariableType type
Used to validate the type of a built-in variable.
Signature
export declare type BuiltInVariableType = PropTypeFromEnum<AllPropTypes>;
ComponentWithConstructor type
The base type of a component that takes a prop definition. This can be used to set default props for a base component.
Signature
export declare type ComponentWithConstructor<TPropsDefinition, S extends SerializableState = SerializableState> = ComponentWithoutConstructor<TPropsDefinition> & {
    new (): Component<ComponentWithConstructor<TPropsDefinition, S>, S>;
};
References
SerializableState, Component, ComponentWithConstructor
DisposeOperation type
A callback used to perform a single registered dispose operation, either automatically at the dispose time of the DisposableObject instance, or manually before the dispose operation.
Signature
export declare type DisposeOperation = () => void;
FetchAsDataOptions type
The additional options for the Asset.fetchAsData() method.
Signature
export declare type FetchAsDataOptions = {
    skipCache: boolean;
};
Remarks
Type parameters:
skipCache - Indicates whether to ignore the local cache when fetching the asset data and to instead fetch the data from the server. This option is only useful when fetching the latest version of an asset while the world instance is live and the asset was previously updated in the same world instance. Otherwise, you should not enable this option because retrieving unnecessary data from the server will degrade performance when the cached data is already up to date.
FocusUIOptions type
Options for the Player.focusUI() method including settings to apply to the camera view and animation transitions.
Signature
export declare type FocusUIOptions = {
    duration?: number;
    horizontalOffset?: number;
    verticalOffset?: number;
    rotation?: Vec3;
    fillPercentage?: number;
};
References
Vec3
FocusedInteractionTapOptions type
The FocusedInteraction options for visuals that are displayed when players use tap input.
Signature
export declare type FocusedInteractionTapOptions = {
    duration: number;
    startScale: number;
    endScale: number;
    startRotation: number;
    endRotation: number;
    startColor: Color;
    endColor: Color;
    startOpacity: number;
    endOpacity: number;
};
References
Color
Remarks
See DefaultFocusedInteractionTapOptions for the default values for this type.
FocusedInteractionTrailOptions type
The FocusedInteraction options for visual trails that are displayed when players use swipe and drag input.
Signature
export declare type FocusedInteractionTrailOptions = {
    length: number;
    startWidth: number;
    endWidth: number;
    startColor: Color;
    endColor: Color;
    startOpacity: number;
    endOpacity: number;
};
References
Color
InteractionInfo type
Information about an input received from the player during Focused Interaction mode.
Signature
export declare type InteractionInfo = {
    interactionIndex: number;
    screenPosition: Vec3;
    worldRayOrigin: Vec3;
    worldRayDirection: Vec3;
};
References
Vec3
Remarks
interactionIndex: An index for differentiating between simultaneous inputs. The first input is 0, the second is 1, etc.
screenPosition: The screen position of the input normalized to the range (0,0) to (1,1).
worldRayOrigin: The origin point of a ray in the world generated from a touch gesture.
worldRayDirection: The direction vector of a ray in the world generated from a touch gesture.
InteractionInfo is passed by the PlayerControls.onFocusedInteractionInputStarted, PlayerControls.onFocusedInteractionInputMoved, and PlayerControls.onFocusedInteractionInputEnded events.
For more information, see the Focused Interaction guide.
LaunchProjectileOptions type
Options for launching a projectile.
Signature
export declare type LaunchProjectileOptions = {
    speed: number;
    duration?: number;
};
ParticleFXPlayOptions type
The settings for playing a particle effect.
Signature
export declare type ParticleFXPlayOptions = {
    fromStart?: boolean;
    players?: Array<Player>;
    oneShot?: boolean;
};
References
Player
Remarks
fromStart - true to play the effect from the beginning even if already playing. Otherwise, the effect doesn't play if already playing.
players - The array of players to apply the change to.
oneShot - If true, the effect emits a new particle that plays until its full duration completes. This does not interfere with other play interactions.
ParticleFXStopOptions type
The settings for ending particle effect playback.
Signature
export declare type ParticleFXStopOptions = {
    players?: Array<Player>;
};
References
Player
Remarks
players - The array of players to apply the change to.
PersistentSerializableState type
A state that can persist across sessions within persistent variables for each player. Used with the getPlayerVariable and setPlayerVariable methods.
Signature
export declare type PersistentSerializableState = {
    [key: string]: PersistentSerializableState;
} | PersistentSerializableState[] | PersistentSerializableStateNode;
References
PersistentSerializableState
PlayAnimationOptions type
The options for the Player.playAvatarAnimation() method, which triggers a non-looping animation on an avatar.
Signature
export declare type PlayAnimationOptions = {
    playRate?: number;
    looping?: boolean;
    fadeInDuration?: number;
    fadeOutDuration?: number;
    callback?: AnimationCallback;
};
References
AnimationCallback
PlayAvatarGripPoseAnimationOptions type
An optional parameter that can be passed when triggering a grip pose animation on an avatar
Signature
export declare type PlayAvatarGripPoseAnimationOptions = {
    callback?: AvatarGripPoseAnimationCallback;
};
References
AvatarGripPoseAnimationCallback
PlayerControlsConnectOptions type
The options to pass to PlayerControls.connectLocalInput().
Signature
export declare type PlayerControlsConnectOptions = {
    preferredButtonPlacement?: ButtonPlacement;
};
References
ButtonPlacement
Remarks
preferredButtonPlacement - The button placement to use, if supported. Certain platforms might not support all placements. Attempting to place multiple buttons at the same location prioritizes the latest button enabled.
PlayerInputStateChangeCallback type
A callback that signals state changes when player input is pressed.
Signature
export declare type PlayerInputStateChangeCallback = (action: PlayerInputAction, pressed: boolean) => void;
References
PlayerInputAction
Remarks
Use PlayerInput.registerCallback() to register this callback.
action - The input action that triggered the callback.
pressed - true if the input was pressed; false if it was released.
PopupOptions type
The sound and display settings for a popup message.
Signature
export declare type PopupOptions = {
    position: Vec3;
    fontSize: number;
    fontColor: Color;
    backgroundColor: Color;
    playSound: boolean;
    showTimer: boolean;
};
References
Vec3, Color
Remarks
position: The offset of the popup message relative to the player's local position.
fontSize: The size of the popup message.
fontColor: The font color of the popup message.
backgroundColor: The background color of the popup message.
playSound: true to play the standard popup sound when displaying the popup message; false otherwsie.
showTimer: true to display the timer when displaying the popup message; false otherwise.
PropsDefinitionFromComponent type
A helper utility that derives prop types from a component class type.
Signature
export declare type PropsDefinitionFromComponent<T> = T extends ComponentWithoutConstructor<infer TPropsDefinition> ? Readonly<TPropsDefinition> : never;
PropsFromDefinitions type
The properties for initializing a component.
Signature
export declare type PropsFromDefinitions<T> = {
    [K in keyof T]: T[K] extends never ? never : T[K] extends {
        type: NullablePropTypes;
        default?: never;
    } ? Readonly<PropTypeFromEnum<T[K]['type']>> | undefined : T[K] extends {
        type: NonNullablePropTypes;
        default?: PropTypeFromEnum<NonNullablePropTypes>;
    } ? Readonly<PropTypeFromEnum<T[K]['type']>> : never;
};
Remarks
Used to provide input for instances in the UI.
RaycastHit type
The result of a raycast collision.
Signature
export declare type RaycastHit = StaticRaycastHit | EntityRaycastHit | PlayerRaycastHit;
SerializableState type
The entity state to transfer when entity ownership changes.
Signature
export declare type SerializableState = {
    [key: string]: SerializableState;
} | SerializableState[] | PersistentSerializableStateNode | TransientSerializableStateNode;
References
SerializableState
Remarks
This type is used to transfer the state of an entity when its ownership changes from one player to another. The state of an entity isn't automatically transferred when its ownership changes. To transfer the state, you can pass it to the new owner using SerializableState through the Component.transferOwnership() and Component.receiveOwnership() methods.
For more information, see Maintaining local state on ownership change.
SetMaterialOptions type
Options for the MeshEntity.setMaterial() method.
Signature
export declare type SetMaterialOptions = {
    materialSlot?: number | string;
};
Remarks
materialSlot - The index or the name of the material slot to update. If null or an empty string, the material is applied to slot 0.
SetMeshOptions type
Options that indicate whether players can choose to use new material from a custom model or keep the current material when updating the mesh of a custom model entity.
Signature
export declare type SetMeshOptions = {
    updateMaterial?: boolean;
};
Remarks
updateMaterial - true to enable use of the new material; false to use the current material.
For information on updating the mesh of a custom model entity, see the MeshEntity.setMesh() method.
SetTextureOptions type
Options for the MeshEntity.setTexture() method.
Signature
export declare type SetTextureOptions = {
    players?: Array<Player>;
};
References
Player
Remarks
players - The players to apply the texture for. If null or empty, applies the texture for all players.
SpringOptions type
The spring physics settings for an entity. Spring physics moves an entity as if it were attached to a spring.
Signature
export declare type SpringOptions = {
    stiffness: number;
    damping: number;
    axisIndependent: boolean;
};
Remarks
For more information, see PhysicalEntity.springPushTowardPosition() and PhysicalEntity.springSpinTowardRotation().
stiffness: The stiffness of the spring, which controls the amount of force applied to the object.
damping: The damping ratio of the string, which reduces oscillation.
axisIndependent: true if the object's motion is parallel to the push direction; false otherwise.
StopAnimationOptions type
The options for the Player.stopAvatarAnimation() method, which stops a non-looping animation on an avatar.
Signature
export declare type StopAnimationOptions = {
    fadeOutDuration?: number;
};
ThrowOptions type
Options for customising the effect of calling the Player.throwHeldItem() method.
Signature
export declare type ThrowOptions = {
    speed?: number | null;
    pitch?: number | null;
    yaw?: number | null;
    playThrowAnimation?: boolean | null;
    hand?: Handedness | null;
};
References
Handedness
Remarks
speed: The speed of the object when launched.
pitch: The pitch of the throwing force.
yaw: The yaw of the throwing force.
playThrowAnimation: true to play the throwing animation on web & mobile clients; false otherwise. This value does not affect VR.
hand: The hand to use for throwing.
TooltipLineAttachmentProperties type
Determines how the line attached to a tooltip is displayed.
Signature
export declare type TooltipLineAttachmentProperties = {
    lineAttachmentEntity?: Entity | PlayerBodyPartType;
    lineAttachmentLocalOffset?: Vec3;
    lineAttachmentRounded?: boolean;
    lineChokeStart?: number;
    lineChokeEnd?: number;
};
References
Entity, PlayerBodyPartType, Vec3
Remarks
lineAttachmentEntity - The entity to attach to the line (defaults to the anchor attachment point). You can also set this to a PlayerBodyPartType.
lineAttachmentLocalOffset - Adds a local Vec3 offset on the attachment point of the line.
lineAttachmentRounded - true to round off the start and end edges of the line; false otherwise.
lineChokeStart - The distance where the line should start rendering, after the attachment point.
lineChokeEnd - The distance where the line should stop rendering, before the line hits the tooltip.
TooltipOptions type
The settings for displaying a tooltip message.
Signature
export declare type TooltipOptions = {
    tooltipAnchorOffset?: Vec3;
    displayTooltipLine?: boolean;
    tooltipLineAttachmentProperties?: TooltipLineAttachmentProperties;
    playSound?: boolean;
};
References
Vec3, TooltipLineAttachmentProperties
Remarks
tooltipAnchorOffset - The offset of the tooltip relative to the anchor location.
displayTooltipLine - true to display a line that connects the tooltip to its attachment point; false otherwise.
tooltipLineAttachmentProperties - The attachment point and offset of the line that connects to the tooltip.
playSound - true to play a sound when displaying the tooltip; false otherwise.
VoipSetting type
The player's in-game voice chat setting.
Signature
export declare type VoipSetting = keyof typeof VoipSettingValues;
References
VoipSettingValues
ApiVersion Variable
The version number of the Horizon TypeScript API.
Signature
ApiVersion = "2.0.0"
CodeBlockEvents Variable
The built-in CodeBlock events.
Signature
CodeBlockEvents: {
    OnPlayerEnterTrigger: CodeBlockEvent<[enteredBy: Player]>;
    OnPlayerExitTrigger: CodeBlockEvent<[exitedBy: Player]>;
    OnEntityEnterTrigger: CodeBlockEvent<[enteredBy: Entity]>;
    OnEntityExitTrigger: CodeBlockEvent<[enteredBy: Entity]>;
    OnPlayerCollision: CodeBlockEvent<[collidedWith: Player, collisionAt: Vec3, normal: Vec3, relativeVelocity: Vec3, localColliderName: string, OtherColliderName: string]>;
    OnEntityCollision: CodeBlockEvent<[collidedWith: Entity, collisionAt: Vec3, normal: Vec3, relativeVelocity: Vec3, localColliderName: string, OtherColliderName: string]>;
    OnPlayerEnterWorld: CodeBlockEvent<[player: Player]>;
    OnPlayerExitWorld: CodeBlockEvent<[player: Player]>;
    OnPassiveInstanceCameraCreated: CodeBlockEvent<[sessionId: Player, cameraMode: string]>;
    OnGrabStart: CodeBlockEvent<[isRightHand: boolean, player: Player]>;
    OnGrabEnd: CodeBlockEvent<[player: Player]>;
    OnMultiGrabStart: CodeBlockEvent<[player: Player]>;
    OnMultiGrabEnd: CodeBlockEvent<[player: Player]>;
    OnIndexTriggerDown: CodeBlockEvent<[player: Player]>;
    OnIndexTriggerUp: CodeBlockEvent<[player: Player]>;
    OnButton1Down: CodeBlockEvent<[player: Player]>;
    OnButton1Up: CodeBlockEvent<[player: Player]>;
    OnButton2Down: CodeBlockEvent<[player: Player]>;
    OnButton2Up: CodeBlockEvent<[player: Player]>;
    OnAttachStart: CodeBlockEvent<[player: Player]>;
    OnAttachEnd: CodeBlockEvent<[player: Player]>;
    OnProjectileLaunched: CodeBlockEvent<[launcher: Entity]>;
    OnProjectileHitPlayer: CodeBlockEvent<[playerHit: Player, position: Vec3, normal: Vec3, headshot: boolean]>;
    OnProjectileHitObject: CodeBlockEvent<[objectHit: Entity, position: Vec3, normal: Vec3]>;
    OnProjectileHitWorld: CodeBlockEvent<[position: Vec3, normal: Vec3]>;
    OnProjectileExpired: CodeBlockEvent<[position: Vec3, rotation: Quaternion, velocity: Vec3]>;
    OnAchievementComplete: CodeBlockEvent<[player: Player, scriptId: string]>;
    OnCameraPhotoTaken: CodeBlockEvent<[player: Player, isSelfie: boolean]>;
    OnItemPurchaseStart: CodeBlockEvent<[player: Player, item: string]>;
    OnItemPurchaseComplete: CodeBlockEvent<[player: Player, item: string, success: boolean]>;
    OnItemConsumeStart: CodeBlockEvent<[player: Player, item: string]>;
    OnItemConsumeComplete: CodeBlockEvent<[player: Player, item: string, success: boolean]>;
    OnItemPurchaseSucceeded: CodeBlockEvent<[player: Player, item: string]>;
    OnItemPurchaseFailed: CodeBlockEvent<[player: Player, item: string]>;
    OnPlayerConsumeSucceeded: CodeBlockEvent<[player: Player, item: string]>;
    OnPlayerConsumeFailed: CodeBlockEvent<[player: Player, item: string]>;
    OnPlayerSpawnedItem: CodeBlockEvent<[player: Player, item: Entity]>;
    OnAssetSpawned: CodeBlockEvent<[entity: Entity, asset: Asset]>;
    OnAssetDespawned: CodeBlockEvent<[entity: Entity, asset: Asset]>;
    OnAssetSpawnFailed: CodeBlockEvent<[asset: Asset]>;
    OnAudioCompleted: CodeBlockEvent<[]>;
    OnPlayerEnterAFK: CodeBlockEvent<[player: Player]>;
    OnPlayerExitAFK: CodeBlockEvent<[player: Player]>;
    OnPlayerEnteredFocusedInteraction: CodeBlockEvent<[player: Player]>;
    OnPlayerExitedFocusedInteraction: CodeBlockEvent<[player: Player]>;
}
Remarks
OnPlayerEnterTrigger: Invoked when the player enters a trigger zone.
OnPlayerExitTrigger: Invoked when the player exits a trigger zone.
OnEntityEnterTrigger: Invoked when an entity enters a trigger zone.
OnEntityExitTrigger: Invoked when an entity exits a trigger zone.
OnPlayerCollision: Invoked when a player collides with something.
OnEntityCollision: Invoked when an entity collides with something.
OnPlayerEnterWorld: Invoked when a player enters the world.
OnPlayerExitWorld: Invoked when a player exits the world.
OnGrabStart: Invoked when a player starts to grab an entity.
OnGrabEnd: Invoked when a player releases an entity.
OnMultiGrabStart: Invoked when a player grabs multiple entities.
OnMultiGrabEnd: Invoked when a player releases multiple entities.
OnIndexTriggerDown: Invoked when the index finger button is pressed.
OnIndexTriggerUp: Invoked when the index finger button is released.
OnButton1Down: Invoked when button 1 is pressed.
OnButton1Up: Invoked when button 1 is released.
OnButton2Down: Invoked when button 2 is pressed.
OnButton2Up: Invoked when button 2 is released.
OnAttachStart: Invoked when an attachment is attached.
OnAttachEnd: Invoked when an attachment is detached.
OnProjectileLaunched: Invoked when a projectile is launched.
OnProjectileHitPlayer: Invoked when a projectile hits a player.
OnProjectileHitObject: Invoked when a projectile hits an object.
OnProjectileHitWorld: Invoked when a projectile hits something in the world.
OnProjectileExpired: Invoked when a projectile expires without hitting anything.
OnAchievementComplete: Invoked when a player completes an achievement.
OnCameraPhotoTaken: Invoked when the camera captures a photo.
OnItemPurchaseSucceeded: Invoked when an item is successfully purchased.
OnItemPurchaseFailed: Invoked when an item purchase fails.
OnPlayerConsumeSucceeded: Invoked when an item is successfully consumed.
OnPlayerConsumeFailed: Invoked when an item fails to be consumed.
OnPlayerSpawnedItem: Invoked when an item spawns from the inventory.
OnAssetSpawned: Invoked when an asset spawns.
OnAssetDespawned: Invoked when an asset despawns.
OnAssetSpawnFailed: Invoked when an asset fails to spawn.
OnAudioCompleted: Invoked when audio playback completes.
OnPlayerEnterAFK: Invoked when a player goes AFK, such as when they open the Oculus menu or remove their headset.
OnPlayerExitAFK: Invoked when a players returns from being AFK.
OnPlayerEnteredFocusedInteraction: Invoked when a player enters Focused Interaction mode.
OnPlayerExitedFocusedInteraction: Invoked when a player exits Focused Interaction mode.
DefaultFetchAsDataOptions Variable
Defines the default values for the type.
Signature
DefaultFetchAsDataOptions: FetchAsDataOptions
Remarks
Values:
skipCache: false
DefaultFocusedInteractionTapOptions Variable
The default values for the FocusedInteractionTapOptions type, which defines the visual options when players use tap input.
Signature
DefaultFocusedInteractionTapOptions: FocusedInteractionTapOptions
Remarks
duration: 0.5
startScale: 0.4
endScale: 1
startRotation: 0
endRotation: 0
startColor: Color.white
endColor: Color.white
startOpacity: 0.4
endOpacity: 0
DefaultFocusedInteractionTrailOptions Variable
The default values for the FocusedInteractionTrailOptions type, which displays visual trails when players use swipe and drag input.
Signature
DefaultFocusedInteractionTrailOptions: FocusedInteractionTrailOptions
Remarks
length: 0.25
startWidth: 1
endWidth: 0.1
startColor: Color.white
endColor: Color.white
startOpacity: 0.4
endOpacity: 0
DefaultPopupOptions Variable
The default options for showing a popup when using the PopupOptions type.
Signature
DefaultPopupOptions: PopupOptions
Remarks
position: new Vec3(0, -0.5, 0)
fontSize: 5
fontColor: Color.black
backgroundColor: Color.white
playSound: true
showTimer: false
DefaultSpringOptions Variable
Defines the default values for spring physics when using the SpringOptions type.
Signature
DefaultSpringOptions: SpringOptions
Remarks
stiffness: 2
damping: 0.5
axisIndependent: true
DefaultThrowOptions Variable
The default values for the ThrowOptions type, which defines the throwing behaviour when using the Player.throwHeldItem() API.
Signature
DefaultThrowOptions: ThrowOptions
Remarks
speed: 20
pitch: 10
yaw: 0
playThrowAnimation: true
hand: Handedness.Right
DefaultTooltipOptions Variable
The default values for showing a tooltip using the TooltipOptions type.
Signature
DefaultTooltipOptions: TooltipOptions
Remarks
tooltipAnchorOffset: 0, 0.4f, 0
displayTooltipLine: true
playSound: true
PropTypes Variable
A list of property types available for a Typescript Component. You can pass these variable types to an instance of a Typescript component when attached to an entity.
Signature
PropTypes: {
    Number: "number";
    String: "string";
    Boolean: "boolean";
    Vec3: "Vec3";
    Color: "Color";
    Entity: "Entity";
    Quaternion: "Quaternion";
    Player: "Player";
    Asset: "Asset";
    NumberArray: "Array<number>";
    StringArray: "Array<string>";
    BooleanArray: "Array<boolean>";
    Vec3Array: "Array<Vec3>";
    ColorArray: "Array<Color>";
    EntityArray: "Array<Entity>";
    QuaternionArray: "Array<Quaternion>";
    PlayerArray: "Array<Player>";
    AssetArray: "Array<Asset>";
}
VoipSettingValues Variable
The VoIP (Voice over Internet Protocol) settings for the player.
Signature
VoipSettingValues: {
    readonly Default: "Default";
    readonly Global: "Global";
    readonly Nearby: "Nearby";
    readonly Extended: "Extended";
    readonly Whisper: "Whisper";
    readonly Mute: "Mute";
    readonly Environment: "Environment";
}
Remarks
Default: Players can hear normally.
Global: All players can hear.
Nearby: Only nearby players can hear.
Extended: Players who are further away than normal can hear.
Whisper: Only players next to the current player (closer than nearby) can hear.
Mute: Only the current player can hear.
Environment: The default VoIP settings for the world.
NavMesh Class
Extends INavMesh
A reference to a navigation mesh instance, which scripts can use to query paths, raycasts, and nearest points. Each NavMesh instance represents a profile already defined in the editor; you can't define or modify profiles at runtime. As such, the NavMesh class is considered read-only.
Signature
export declare class NavMesh implements INavMesh
Remarks
There can only be one instance of a given NavMesh for each profile. For example, if multiple scripts retrieve the same reference, their operations are performed on the same NavMesh instance. This ensures your NavMesh reference can be safely passed between elements such as classes and functions.
For information about usage, see the NavMesh generation guide.
Constructors
(constructor)(profileData)
Constructs a new instance of the NavMesh class

Signature
constructor(profileData: Partial<NavMeshProfile>);
Parameters
profileData: Partial<NavMeshProfile>

Properties
getNearestPoint
Gets the nearest point on the navigation mesh within the range of the target position, even if the target isn't on the navigation mesh.

Signature
getNearestPoint: (position: Vec3, range: number) => Vec3 | null;
Remarks
This is useful for filtering input parameters for other NavMesh queries. For example, if we want to navigate towards a player that is standing on a box (and therefore off the NavMesh), we can use this call to find the closest valid position for a NavMesh query.
getPath
Calculates any viable or partially-viable path between a start position and target destination.

Signature
getPath: (start: Vec3, end: Vec3) => NavMeshPath | null;
Remarks
If either the start position or destination position don't lie on the given NavMesh, no path is returned. If both points lie on the mesh but don't have a viable path between them, a partial path is returned with waypoints from the start position to the closest possible point to the destination.
We recommend using the method to filter the parameters for this method, so the start and target paths are always valid.
getPathAlongSurface
Calculates any viable or partially-viable path between a start position and target destination, returning significant waypoints which are aligned with the underlying geometry surface.

Signature
getPathAlongSurface: (start: Vec3, end: Vec3) => NavMeshDetailedPath | null;
Remarks
Output is similar to , but returns more detailed waypoint information. This is slightly more computationally expensive than .
We recommend using instead when the returned waypoint output is used in conjunction with other NavMesh APIs such as .
getStatus
Gets information about the navmesh instance, such as its profile and current bake status.

Signature
getStatus: () => NavMeshInstanceInfo;
profile
The attached profile for this NavMesh instance.

Signature
profile: NavMeshProfile;
rebake
Requests that the server rebuilds the navigation mesh.
This allows you to rebuild a navigation profile's mesh at runtime in order to respond to loading and placing assets or as a result of an obstacle in the world moving.

Signature
rebake: () => Promise<{
        success: boolean;
    }>;

Methods
raycast(startPoint, endPoint)
Performs a raycast between a start and end position on a navigation mesh.

Signature
raycast(startPoint: Vec3, endPoint: Vec3): NavMeshHit;
Parameters
startPoint: Vec3The start position of the raycast.
endPoint: Vec3The destination of the raycast.
Returns
NavMeshHitData about the raycast calculation, such as if a collision occurred and the distance from the origin.
Remarks
This raycast is different from a physics ray cast because it works in 2.5D on the navigation mesh. A NavMesh raycast can detect all kinds of navigation obstructions, such as holes in the ground, and can also climb up slopes if the area is navigable. A physics raycast, in comparison, typically travels linearly through 3D space.
raycast(origin, direction, range)
Performs a raycast from an origin position that travels in the given direction along the navigation mesh. The ray travels until it has either hit something or reaches the max range.

Signature
raycast(origin: Vec3, direction: Vec3, range: number): NavMeshHit;
Parameters
origin: Vec3The starting position of the raycast.
direction: Vec3The direction for the raycast to travel in 3D space.
range: numberThe maximum distance the raycast should travel.
Returns
NavMeshHitData about the raycast calculation, such as if a collision occurred and the distance from the origin.
Remarks
This raycast is different from a physics ray cast because it works in 2.5D on the navigation mesh. A NavMesh raycast can detect all kinds of navigation obstructions, such as holes in the ground, and can also climb up slopes if the area is navigable. A physics raycast, in comparison, typically travels linearly through 3D space.
You can use this function to check if an agent can walk unobstructed between two points on the NavMesh.

NavMeshAgent Class
Extends INavMeshAgent
Extends Entity
Represents an entity with locomotion and pathfinding capabilities.
Signature
export declare class NavMeshAgent extends Entity implements INavMeshAgent
Remarks
For more information, see the NavMesh agents guide.
Properties
Constants
static
List of common constants used when setting the avoidance layer and mask.

Signature
static Constants: {
        LAYER_DEFAULT: number;
        MASK_DEFAULT: number;
        LAYER_PLAYERS: number;
        MASK_IGNORE_ALL: number;
    };
Remarks
Constants:
LAYER_DEFAULT: 1 << 0 - Represents the default layer that agents belong to upon creation. For use with the avoidanceLayer property.
MASK_DEFAULT: (1 << 0) | (1 << 30) - Represents the default masks that agents apply upon creation. For use with the avoidanceMask property.
LAYER_PLAYERS: 1 << 30 - Represents the collision layer for human players. For use with the avoidanceLayer property.
MASK_IGNORE_ALL: -1 - Ensure an agent ignores all other agents during collision avoidance, regardless of the layer they are on. For use with the avoidanceMask property.
acceleration
The acceleration rate for the agent. This is used to propel the agent forward until it reaches its max speed.

Signature
acceleration: HorizonProperty<number>;
Remarks
This should be a positive number. The default value is 10 m/s^2.
alignmentMode
The orientation faced by the agent when traveling.

Signature
alignmentMode: HorizonProperty<NavMeshAgentAlignment>;
Remarks
When travelling, agents default to facing towards their next waypoint. To change the orientation of the agent as it is moving, you can use this property.
See NavMeshAgentAlignment for more information on the available modes.
Default: NavMeshAgentAlignment.NextWaypoint
avoidanceLayer
A bitmask that represents the avoidance layer used to perform collision avoidance calculations for the navigation mesh agent.

Signature
avoidanceLayer: HorizonProperty<number>;
Remarks
Each agent belongs to an avoidance layer. These layers are taken into consideration during collision avoidance calculations to identify which agents to avoid.
In tandem with the layer is the avoidance mask, which is a bitmask representing the layers which this agent should take into consideration during collision avoidance calculations.
This property only sets the agent's avoidance layer. If you want to set the mask, see .
avoidanceMask
A bitmask that represents the layers the navigation mesh agent should avoid colliding with.

Signature
avoidanceMask: HorizonProperty<number>;
Remarks
Each agent belongs to an avoidance layer. These layers are taken into consideration during collision avoidance calculations, to identify which agents to avoid.
In tandem with the layer is the avoidance mask, a bitmask representing the layers which this agent should take into consideration during collision avoidance calculations.
This method only sets the agent's avoidance mask. If you want to set the layer, see .
avoidanceRadius
The radius used for the agent when calculating collision avoidance.

Signature
avoidanceRadius: HorizonProperty<number>;
Remarks
Default: The attached navigation profile radius.
baseOffset
The distance from the agent's center to the surface of its attached NavMesh, in meters. Use this to produce psuedo-flying agents.

Signature
baseOffset: HorizonProperty<number>;
Remarks
This value affects collision avoidance; agents with higher values will avoid other agents with similar base offsets.
Default: 0
currentSpeed
The current speed of the agent, in meters per second.

Signature
currentSpeed: ReadableHorizonProperty<number>;
currentVelocity
The current velocity of the agent, in meters per second.

Signature
currentVelocity: ReadableHorizonProperty<Vec3>;
deceleration
The deceleration rate for the agent. This is used to slow the agent as it approaches the final waypoint of its path.

Signature
deceleration: HorizonProperty<number>;
Remarks
This should be a negative number.
Default: -10 m/s^2
destination
The destination of the agent.

Signature
destination: HorizonProperty<Vec3 | null>;
Remarks
In Play Mode, agents move towards their destination until reached. If the position is outside the navigable surface then it sets the closest navigable point as the destination. Overrides any existing destination set.
getNavMesh
Gets a reference to the current navigation mesh the agent is using.

Signature
getNavMesh: () => Promise<INavMesh | null>;
getNavProfile
Gets a reference to the current navigation mesh profile the agent is using.

Signature
getNavProfile: () => Promise<NavMeshProfile | null>;
isImmobile
Indicates whether the agent is immobile and unable avoid collisions.

Signature
isImmobile: HorizonProperty<boolean>;
Remarks
By default, an agent attempts to avoid impending collisions with other agents or players. However, if you want your agent to plant itself and not avoid collisions with anything, you can use this property. Other agents will try to navigate around it. However, if the world geometry doesn't allow for it, it's possible other agents will collide with this agent or get stuck trying to move past it.
The agent will not move at all unless isImmobile is set to false, even if the property is set.
Default: false
maxSpeed
The max travel speed for the agent.

Signature
maxSpeed: HorizonProperty<number>;
Remarks
To change how fast the agent reaches its max speed, use the property.
Default: 5 meters per second
nextWaypoint
The next waypoint on the agent's current path.

Signature
nextWaypoint: ReadableHorizonProperty<Vec3 | null>;
path
The current path the agent is using.

Signature
path: ReadableHorizonProperty<Vec3[]>;
profileName
The name of the Navigation Profile attached to the agent.

Signature
profileName: HorizonProperty<string | null>;
Remarks
Setting this value causes the agent to use the new profile's NavMesh for pathfinding operations.
remainingDistance
The agent's remaining distance in its current path, accounting for the agent's stopping distance.

Signature
remainingDistance: ReadableHorizonProperty<number>;
Remarks
This may not be the same distance to its intended target. For example, if the path to the destination is incomplete or blocked.
requiredForwardAlignment
The required alignment, in degrees, between the agent's destination and the direction they are facing, at which point the agent can start moving towards the target direction.

Signature
requiredForwardAlignment: HorizonProperty<number>;
Remarks
When traveling, it is possible the agent starts to move in a different direction than it is currently facing. For instance, when navigating to a destination behind the agent, it will begin travelling while turning to face the proper direction.
You can leverage this property to ensure that an agent only travels forward when it is generally facing the correct direction. We recommend that you keep this value higher than \~10.
Default: 360 degrees
stoppingDistance
The distance where the agent considers itself within an acceptable range of its destination.

Signature
stoppingDistance: HorizonProperty<number>;
Remarks
Agents automatically decelerate and then stop when reaching this distance.
Default: 0 meters
turnSpeed
The rate in degrees pers second, at which the agent rotates towards its desired orientation.

Signature
turnSpeed: HorizonProperty<number>;
Remarks
The agent's desired orientation is determined by its property.
Default: 120 degrees per second
usePhysicalSurfaceSnapping
The surface snapping setting for the agent, which determines whether the agent uses the navmesh or the world's physical surface to determine its surface position.

Signature
usePhysicalSurfaceSnapping: HorizonProperty<boolean>;
Remarks
By default, the agent uses the navigation mesh to determine its surface position. The surface position is used when moving the agent to ensure it is attached to the navigation mesh at all times.
The navigation mesh is a simplified representation of the world, so it may not be totally accurate, particularly along slopes or curves. In some cases, you'd want the actual physical surface position to be used instead.
This setting allows you to toggle this physical surface snapping on/off.
Enabling this setting icurs a per-frame performance cost for the agent.
Default: false

Methods
clearDestination()
Warning: This API is now obsolete.
Use destination.set(null) instead!
This method is deprecated.

Signature
clearDestination(): void;
Returns
void
toString()
Creates a human-readable representation of the NavMeshAgent.

Signature
toString(): string;
Returns
stringA string representation of the NavMeshAgent.

NavMeshManager Class
Stores and retrieves references to NavMesh instances.
Signature
export default class NavMeshManager
Remarks
NavMesh instances are cached to ensure that retrieving their profile multiple times with a script only generates one class reference. This is useful for updating navigation mesh profiles at runtime.
Properties
getByName
Gets a reference to a instance based on a profile name.

Signature
getByName: (name: string) => Promise<NavMesh | null>;
Remarks
If no matching profile is found, returns null.
getNavMeshes
Gets a set of instances from the cache.

Signature
getNavMeshes: () => Promise<NavMesh[]>;
world
Signature
world: World;

Methods
getInstance(world) static
Gets a NavMeshManager directory that stores the references to NavMesh instances.

Signature
static getInstance(world: World): NavMeshManager;
Parameters
world: World
Returns
NavMeshManager

NavMeshAgentAlignment Enum
The possible orientation values for NavMeshAgent locomotion.
Signature
export declare const enum NavMeshAgentAlignment
Enumeration Members
Member
Value
Description
CurrentVelocity
1
The agent rotates to face its current direction of travel. (Default)
Destination
4
The agent rotates to face its target destination. This may be different than its final waypoint; for instance, if the path is incomplete.
FinalWaypoint
3
The agent rotates to face the final waypoint of its current path. This may be different than its destination, for instance, if the path is incomplete.
NextWaypoint
2
The agent rotates to face the next waypoint of its current path.
None
0
The agent does not change orientation as it travels.

Remarks


See the NavMeshAgent.alignmentMode property for usage.
NavMeshState Enum
The possible state values for the NavMeshInstanceInfo type.
Signature
export declare enum NavMeshState
Enumeration Members
Member
Value
Description
Baking
"Baking"
The navigation mesh is being rebuilt.
Loading
"Loading"
Details are being loaded for this navigation mesh.
Ready
"Ready"
The instance is initialized and ready to use.
Uninitialized
"Uninitialized"
The instance hasn't been initialized yet.

INavMesh Interface
A reference to a navigation mesh instance, which scripts can use to query paths, raycasts, and nearest points. Each NavMesh instance represents a profile already defined in the editor; you can't define or modify profiles at runtime. As such, the NavMesh class is considered read-only.
Signature
export interface INavMesh
Remarks
There can only be one instance of a given NavMesh for each profile. For example, if multiple scripts retrieve the same reference, their operations are performed on the same NavMesh instance. This ensures your NavMesh reference can be safely passed between elements such as classes and functions.
For information about usage, see the NavMesh generation guide.
Properties
profile
The attached profile for this NavMesh instance.

Signature
profile: NavMeshProfile;

Methods
getNearestPoint(position, range)
Gets the nearest point on the navigation mesh within the range of the target position, even if the target isn't on the navigation mesh.

Signature
getNearestPoint(position: Vec3, range: number): null | Vec3;
Parameters
position: Vec3The target position to check for the nearest point.
range: numberThe maximum distance for the calculation.
Returns
null | Vec3The nearest Vec3 position within the range, or null if no point is available.
Remarks
This is useful for filtering input parameters for other NavMesh queries. For example, if we want to navigate towards a player that is standing on a box (and therefore off the NavMesh), we can use this call to find the closest valid position for a NavMesh query.
getPath(start, destination)
Calculates any viable or partially-viable path between a start position and target destination.

Signature
getPath(start: Vec3, destination: Vec3): null | NavMeshPath;
Parameters
start: Vec3The starting position of the desired path.
destination: Vec3The target destination of the desired path.
Returns
null | NavMeshPathA NavMeshPath object containing the path information. Otherwise, if there's no path available, returns null.
Remarks
If either the start position or destination position don't lie on the given NavMesh, no path is returned. If both points lie on the mesh but don't have a viable path between them, a partial path is returned with waypoints from the start position to the closest possible point to the destination.
We recommend using the method to filter the parameters for this method, so the start and target paths are always valid.
getPathAlongSurface(start, destination)
Calculates any viable or partially-viable path between a start position and target destination, returning significant waypoints which are aligned with the underlying geometry surface.

Signature
getPathAlongSurface(start: Vec3, destination: Vec3): null | NavMeshDetailedPath;
Parameters
start: Vec3
destination: Vec3
Returns
null | NavMeshDetailedPath
Remarks
Output is similar to , but returns more detailed waypoint information. This is slightly more computationally expensive than .
We recommend using instead when the returned waypoint output is used in conjunction with other NavMesh APIs such as .
getStatus()
Gets information about the navmesh instance, such as its profile and current bake status.

Signature
getStatus(): NavMeshInstanceInfo;
Returns
NavMeshInstanceInfo
raycast(origin, direction, range)
Performs a raycast from an origin position that travels in the given direction along the navigation mesh. The ray travels until it has either hit something or reaches the max range.
You can use this function to check if an agent can walk unobstructed between two points on the NavMesh.

Signature
raycast(origin: Vec3, direction: Vec3, range: number): NavMeshHit;
Parameters
origin: Vec3The starting position of the raycast.
direction: Vec3The direction for the raycast to travel in 3D space.
range: numberThe maximum distance the raycast should travel.
Returns
NavMeshHitData about the raycast calculation, such as if a collision occurred and the distance from the origin.
Remarks
This raycast is different from a physics ray cast because it works in 2.5D on the navigation mesh. A NavMesh raycast can detect all kinds of navigation obstructions, such as holes in the ground, and can also climb up slopes if the area is navigable. A physics raycast, in comparison, typically travels linearly through 3D space.
raycast(startPoint, endPoint)
Performs a raycast between a start and end position on a navigation mesh.

Signature
raycast(startPoint: Vec3, endPoint: Vec3): NavMeshHit;
Parameters
startPoint: Vec3The start position of the raycast.
endPoint: Vec3The destination of the raycast.
Returns
NavMeshHitData about the raycast calculation, such as if a collision occurred and the distance from the origin.
Remarks
This raycast is different from a physics ray cast because it works in 2.5D on the navigation mesh. A NavMesh raycast can detect all kinds of navigation obstructions, such as holes in the ground, and can also climb up slopes if the area is navigable. A physics raycast, in comparison, typically travels linearly through 3D space.
rebake()
Requests that the server rebuilds the navigation mesh.

Signature
rebake(): Promise<NavMeshBakeInfo>;
Returns
Promise<NavMeshBakeInfo>A promise containing the result of the rebake request.
Remarks
This allows you to rebuild a navigation profile's mesh at runtime in order to respond to loading and placing assets or as a result of an obstacle in the world moving.

INavMeshAgent Interface
An entity with locomotion and pathfinding capabilities.
Signature
export interface INavMeshAgent
Remarks
For more information, see the NavMesh agents guide.
Properties
acceleration
The acceleration rate for the agent. This is used to propel the agent forward until it reaches its max speed.

Signature
acceleration: HorizonProperty<number>;
Remarks
This should be a positive number. The default value is 10 m/s^2.
alignmentMode
The orientation faced by the agent when traveling.

Signature
alignmentMode: HorizonProperty<NavMeshAgentAlignment>;
Remarks
When travelling, agents default to facing towards their next waypoint. To change the orientation of the agent as it is moving, you can use this property.
See NavMeshAgentAlignment for more information on the available modes.
Default: NavMeshAgentAlignment.NextWaypoint
avoidanceLayer
A bitmask that represents the avoidance layer used to perform collision avoidance calculations for the navigation mesh agent.

Signature
avoidanceLayer: HorizonProperty<number>;
Examples
enum MyGroups {
  Red = 1 << 1,
  Green = 1 << 2,
  Blue = 1 << 3,
}

agent.avoidanceLayer.set(MyGroups.Red); // Join the Red layer
agent.avoidanceMask.set(MyGroups.Red); // Ignore other Reds
Remarks
Each agent belongs to an avoidance layer. These layers are taken into consideration during collision avoidance calculations to identify which agents to avoid.
In tandem with the layer is the avoidance mask, which is a bitmask representing the layers which this agent should take into consideration during collision avoidance calculations.
This property only sets the agent's avoidance layer. If you want to set the mask, see .
avoidanceMask
A bitmask that represents the layers the navigation mesh agent should avoid colliding with.

Signature
avoidanceMask: HorizonProperty<number>;
Examples
Example 1
enum MyGroups {
  Red = 1 << 1,
  Green = 1 << 2,
  Blue = 1 << 3,
}

agent.avoidanceLayer.set(MyGroups.Red); // Join the Red layer
agent.avoidanceMask.set(MyGroups.Red); // Ignore other Reds

// You can use the bitwise OR operator to combine layers:
agent.avoidanceMask.set(MyGroups.Red | MyGroups.Blue);

// You can use the bitwise AND/NOT operators to remove layers:
const currentMask = agent.avoidanceMask.get();
agent.avoidanceMask.set(currentMask & ~MyGroups.Green); // Remove Green
Example 2
If you change the avoidance mask, be sure to include Constants.LAYER_PLAYERS in the mask. This ensures your agents still avoid human players.
agent.avoidanceMask.set(MyGroups.Red | NavMeshAgent.Constants.LAYER_PLAYERS);
Remarks
Each agent belongs to an avoidance layer. These layers are taken into consideration during collision avoidance calculations, to identify which agents to avoid.
In tandem with the layer is the avoidance mask, a bitmask representing the layers which this agent should take into consideration during collision avoidance calculations.
This method only sets the agent's avoidance mask. If you want to set the layer, see .
avoidanceRadius
The radius used for the agent when calculating collision avoidance.

Signature
avoidanceRadius: HorizonProperty<number>;
Remarks
Default: The attached navigation profile radius.
baseOffset
The distance from the agent's center to the surface of its attached NavMesh, in meters. Use this to produce psuedo-flying agents.

Signature
baseOffset: HorizonProperty<number>;
Remarks
This value affects collision avoidance; agents with higher values will avoid other agents with similar base offsets.
Default: 0
currentSpeed
The agent's current speed, in meters per second.

Signature
currentSpeed: ReadableHorizonProperty<number>;
currentVelocity
The agent's current velocity, in meters per second.

Signature
currentVelocity: ReadableHorizonProperty<Vec3>;
deceleration
The deceleration rate for the agent. This is used to slow the agent as it approaches the final waypoint of its path.

Signature
deceleration: HorizonProperty<number>;
Remarks
This should be a negative number.
Default: -10 m/s^2
destination
The destination of the agent.

Signature
destination: HorizonProperty<Vec3 | null>;
Remarks
In Play Mode, agents move towards their destination until reached. If the position is outside the navigable surface then it sets the closest navigable point as the destination. Overrides any existing destination set.
getNavMesh
A reference to the NavMesh associated with the agent.

Signature
getNavMesh: () => Promise<INavMesh | null>;
getNavProfile
A reference to the navigation profile associated with the agent.

Signature
getNavProfile: () => Promise<NavMeshProfile | null>;
isImmobile
Indicates whether the agent is immobile and unable avoid collisions.

Signature
isImmobile: HorizonProperty<boolean>;
Remarks
By default, an agent attempts to avoid impending collisions with other agents or players. However, if you want your agent to plant itself and not avoid collisions with anything, you can use this property. Other agents will try to navigate around it. However, if the world geometry doesn't allow for it, it's possible other agents will collide with this agent or get stuck trying to move past it.
The agent will not move at all unless isImmobile is set to false, even if the property is set.
Default: false
maxSpeed
The max travel speed for the agent.

Signature
maxSpeed: HorizonProperty<number>;
Remarks
To change how fast the agent reaches its max speed, use the property.
Default: 5 meters per second
nextWaypoint
The agent's next target waypoint.

Signature
nextWaypoint: ReadableHorizonProperty<Vec3 | null>;
path
The agent's current path and the associated information.

Signature
path: ReadableHorizonProperty<Vec3[]>;
profileName
The name of the Navigation Profile attached to the agent.

Signature
profileName: HorizonProperty<string | null>;
Remarks
Setting this value causes the agent to use the new profile's NavMesh for pathfinding operations.
remainingDistance
The agent's remaining distance in its current path.

Signature
remainingDistance: ReadableHorizonProperty<number>;
Remarks
This may not be the same distance to its intended target. For example, if the path to the destination is incomplete or blocked.
requiredForwardAlignment
The required alignment, in degrees, between the agent's destination and the direction they are facing, at which point the agent can start moving towards the target direction.

Signature
requiredForwardAlignment: HorizonProperty<number>;
Remarks
When traveling, it is possible the agent starts to move in a different direction than it is currently facing. For instance, when navigating to a destination behind the agent, it will begin travelling while turning to face the proper direction.
You can leverage this property to ensure that an agent only travels forward when it is generally facing the correct direction. We recommend that you keep this value higher than \~10.
Default: 360 degrees
stoppingDistance
The distance where the agent considers itself within an acceptable range of its destination.

Signature
stoppingDistance: HorizonProperty<number>;
Remarks
Agents automatically decelerate and then stop when reaching this distance.
Default: 0 meters
turnSpeed
The rate in degrees pers second, at which the agent rotates towards its desired orientation.

Signature
turnSpeed: HorizonProperty<number>;
Remarks
The agent's desired orientation is determined by its property.
Default: 120 degrees per second
usePhysicalSurfaceSnapping
The surface snapping setting for the agent, which determines whether the agent uses the navmesh or the world's physical surface to determine its surface position.

Signature
usePhysicalSurfaceSnapping: HorizonProperty<boolean>;
Remarks
By default, the agent uses the navigation mesh to determine its surface position. The surface position is used when moving the agent to ensure it is attached to the navigation mesh at all times.
The navigation mesh is a simplified representation of the world, so it may not be totally accurate, particularly along slopes or curves. In some cases, you'd want the actual physical surface position to be used instead.
This setting allows you to toggle this physical surface snapping on/off.
Enabling this setting icurs a per-frame performance cost for the agent.
Default: false

Methods
clearDestination()
Warning: This API is now obsolete.
Use destination.set(null) instead!
This method is deprecated.

Signature
clearDestination(): void;
Returns
void

 NavMeshHit type
The collision data returned when a raycast is performed on a NavMesh object by the method.
Signature
export declare type NavMeshHit = {
    position: Vec3;
    normal: Vec3;
    distance: number;
    hit: boolean;
    navMesh: INavMesh;
};
References
INavMesh
Remarks
Variables:
position: The ending location where the raycast collided with the NavMesh.
normal: The normal vector at the point of impact for the raycast.
distance: The distance traveled when the raycast was performed.
hit: true if the raycast hit any obstructions or edges during the calculation; otherwise, false.
navMesh: The NavMesh the raycast was performed on.
NavMeshInstanceInfo type
Data about the of a NavMesh instance.
Signature
export declare type NavMeshInstanceInfo = {
    profile: NavMeshProfile;
    currentBake: Promise<boolean> | null;
    state: NavMeshState;
};
References
NavMeshProfile, NavMeshState
Remarks
Variables:
profile: The current navigation profile associated with the navigation mesh.
currentBake: A promise that contains the result of the current rebuild operation of the navigation mesh; otherwise, null.
state: The state of the navigation mesh instance, such as whether it is ready to use or being rebuilt.
NavMeshPath type
Defines the pathfinding calculation results retrieved by the NavMesh.getPath property.
Signature
export declare type NavMeshPath = {
    waypoints: Vec3[];
    startPos: Vec3;
    endPos: Vec3;
    destinationPos: Vec3;
    pathReachesDestination: boolean;
};
Remarks
Variables:
waypoints: The list of waypoints for the generated path.
startPos: The origin point for the generated path.
endPos: The terminal point for the generated path. This might not be the same as the query destination.
destinationPos: The requested terminal point for the generated path. This may not be reachable, and can differ from endPos.
pathReachesDestination: true if the endPos reaches the destinationPos, false if an incomplete path is returned.
NavMeshProfile type
The configuration for a navigation NavMesh.profile.
Signature
export declare type NavMeshProfile = {
    typeId: number;
    name: string;
    color: string;
    agentRadius: number;
    agentMaxSlope: number;
    navMesh: INavMesh;
};
References
INavMesh
Remarks
Variables:
typeId: The Unique ID for this profile type (provided by the backend server).
name: The name of the profile entity in World Builder.
color: The color of the given profile as defined in World Builder.
agentRadius: The radius for the agent's navmesh calculations.
agentMaxSlope: The maximum angle on a slope the agent can traverse.
navMesh: The NavMesh the agent is running a calculation against.
 ApiName Variable
The name of the API.
Signature
ApiName = "navmesh"
CountSampler Class
Warning: This API is now obsolete.
Use HorizonCountSampler instead.
This class is deprecated.
Signature
export declare class CountSampler
Remarks
Creates a sampler that can be used to record an event for focusing on the event frequency.
Constructors
(constructor)(name)
Constructs a new instance of the CountSampler class

Signature
constructor(name: string);
Parameters
name: string

Methods
count(amount)
Warning: This API is now obsolete.
Use HorizonCountSampler.count() instead.
This method is deprecated.

Signature
count(amount: number): void;
Parameters
amount: number
Returns
void

CustomMetricsBuffer Class
A list that contains a buffer of HorizonTraceEvents to send to the event aggregation pipeline for processing.
Signature
export declare class CustomMetricsBuffer
Methods
getBufferContents() static
Gets the trace events that are in the trace event buffer.

Signature
static getBufferContents(): Array<HzTraceEventsBySampler>;
Returns
Array<HzTraceEventsBySampler>An array that contains the elements in the trace event buffer.

CustomMetricsCoordinator Class
Coordinates custom performance metrics behaviors including listening for events from the aggregation pipeline, returning event data, and clearing the event buffer.
Signature
export declare class CustomMetricsCoordinator
Methods
activateMetric(metricConfig) static
Adds a metric to the active metrics list if there isn't already a metric with the provided name. Also, adds any samplers that contribute to the metric so they can be accessed at runtime.

Signature
static activateMetric(metricConfig: HorizonPerformanceMetricConfig): void;
Parameters
metricConfig: HorizonPerformanceMetricConfigThe configuration for new metric to activate.
Returns
void
getActiveMetrics() static
Gets the metrics that are currently being aggregated.

Signature
static getActiveMetrics(): Array<HorizonPerformanceMetricConfig>;
Returns
Array<HorizonPerformanceMetricConfig>An array that contains configurations of the active metrics.
getActiveSamplers() static
Gets the trace samplers that are running.

Signature
static getActiveSamplers(): Array<string>;
Returns
Array<string>An array that contains the active trace samplers.
isTracingActive() static
Indicates whether the trace is running.

Signature
static isTracingActive(): boolean;
Returns
booleantrue if tracing is in progress; false otherwise.

DurationSampler Class
Warning: This API is now obsolete.
Use HorizonDurationSampler instead!
This class is deprecated.
Signature
export declare class DurationSampler
Remarks
Creates a sampler that can be used to record an event that has a duration.
Constructors
(constructor)(name)
Constructs a new instance of the DurationSampler class

Signature
constructor(name: string);
Parameters
name: string

Methods
trace(fn)

Signature
trace(fn: () => void): void;
Parameters
fn: () => void
Returns
void

HorizonCountSampler Class
A trace sampler that tracks the frequency of events.
Signature
export declare class HorizonCountSampler
Constructors
(constructor)(samplerName)
Constructs a new instance of the HorizonCountSampler class

Signature
constructor(samplerName: string);
Parameters
samplerName: string

Methods
count(amount)
Tracks the number of trace events that occured.

Signature
count(amount: number): void;
Parameters
amount: numberThe type of trace event to track.
Returns
void

HorizonDurationSampler Class
A trace sampler that tracks the duration of function calls.
Signature
export declare class HorizonDurationSampler
Constructors
(constructor)(samplerName)
Constructs a new instance of the HorizonDurationSampler class

Signature
constructor(samplerName: string);
Parameters
samplerName: string

Methods
trace(fn)
Tracks the duration of the given function call.

Signature
trace(fn: () => void): void;
Parameters
fn: () => voidThe function call to track.
Returns
void

HorizonMarkerSampler Class
A trace sampler that flags events.
Signature
export declare class HorizonMarkerSampler
Remarks
Events flagged by this sampler aggregate to 1 if invoked and 0 if not.
Constructors
(constructor)(samplerName)
Constructs a new instance of the HorizonMarkerSampler class

Signature
constructor(samplerName: string);
Parameters
samplerName: string

Methods
mark()
Flags an event, which aggregates to 1 if the event is called and 0 if it's not called.

Signature
mark(): void;
Returns
void

HorizonPerformanceMetricConfig Class
A configuration for custom metrics, which allows you to capture data about about your scripts at runtime.
Signature
export declare class HorizonPerformanceMetricConfig
Remarks
For more information about using custom metrics, see the Custom Metrics API guide.
Constructors
(constructor)(metricName, samplersList, intendedTraceEventType, targetValue)
Constructs a new HorizonPerformanceMetricConfig object.

Signature
constructor(metricName: string, samplersList: Array<string>, intendedTraceEventType: HorizonTraceEventType, targetValue: string);
Parameters
metricName: stringThe name of the metric.
samplersList: Array<string>The list of samplers for the metric.
intendedTraceEventType: HorizonTraceEventTypeThe type of trace event for the metric.
targetValue: stringThe value of the metric.

Properties
intendedTraceEventType
[readonly]
The type of trace event for the metric.

Signature
readonly intendedTraceEventType: HorizonTraceEventType;
metricName
[readonly]
The name of the metric.

Signature
readonly metricName: string;
samplersList
[readonly]
The list of samplers that is aggregated to provide the final metric value.

Signature
readonly samplersList: Array<string>;
targetValue
[readonly]
The value of the metric.

Signature
readonly targetValue: string;

HorizonTraceEvent Class
A trace event in Horizon Worlds.
Signature
export declare class HorizonTraceEvent
Constructors
(constructor)(samplerName, type, value)
Constructs a HorizonTraceEvent object.

Signature
constructor(samplerName: string, type: HorizonTraceEventType, value: number);
Parameters
samplerName: string
type: HorizonTraceEventType
value: number

Properties
samplerName
[readonly]
The name of the trace sampler for the event.

Signature
readonly samplerName: string;
timeStamp
[readonly]
The timestamp of event.

Signature
readonly timeStamp: number;
type
[readonly]
The trace event type.

Signature
readonly type: HorizonTraceEventType;
value
[readonly]
The value of the trace.

Signature
readonly value: number;

MarkerSampler Class
Warning: This API is now obsolete.
Use HorizonMarkerSampler instead.
This class is deprecated.
Signature
export declare class MarkerSampler
Remarks
Creates a sampler that can be used to record an event without a duration.
Constructors
(constructor)(name)
Constructs a new instance of the MarkerSampler class

Signature
constructor(name: string);
Parameters
name: string

Methods
mark()
Warning: This API is now obsolete.
Use HorizonMarkerSampler.mark() instead.
This method is deprecated.

Signature
mark(): void;
Returns
void

HorizonMetricSuffixes Enum
The suffixes for custom metric values. These are abbreviated in the tools.
Signature
export declare enum HorizonMetricSuffixes
Enumeration Members
Member
Value
Description
Bytes
8
A value measure in bytes.
Count
2
The sum of a set of values.
Frames
5
A value measure in frames.
FramesPerSecond
4
A value measure in frames per second.
Kilo
3
A value measure in kilos.
Kilobytes
7
A value measure in kilobytes.
Megabytes
6
A value measure in megabytes.
Milliseconds
1
A value measure in milliseconds.
Seconds
0
A value measure in seconds.

HorizonTraceEventType Enum
The types for Horizon trace events, based on the sampler that produces them.
Signature
export declare enum HorizonTraceEventType
Enumeration Members
Member
Value
Description
Counter
2
Produced by .
Duration
0
Produced by HorizonCountSampler.
Marker
1
Produced by HorizonMarkerSampler.

ApiName Variable
Signature
ApiName = "performance"
Animation_2 Class
An animation for an AnimatedBinding.
Signature
export declare abstract class Animation
Remarks
Animations cannot be started on their own; they can only be used inside a AnimatedBinding.set() call.
For information about usage, see Animations for Custom UIs.
Methods
delay(time, animation) static
Sets a delay to apply before the animation starts.

Signature
static delay(time: number, animation: Animation): Animation;
Parameters
time: numberThe length of the delay to apply to the animation.
animation: AnimationThe animation to apply the delay to.
Returns
Animation
repeat(animation, iterations) static
Repeats the animation the given number of times.

Signature
static repeat(animation: Animation, iterations?: number): Animation;
Parameters
animation: AnimationThe animation to repeat.
iterations: number(Optional) The number of times to repeat the animation.
Returns
Animation
sequence(animations) static
Runs a set of animations in sequence.

Signature
static sequence(...animations: Array<Animation>): Animation;
Parameters
animations: Array<Animation>The animations to run in sequence.
Returns
Animation
timing(value, config) static
Applies a timing animation to the binding based on the given easing curve.

Signature
static timing(value: number | ((prev: number) => number), config?: TimingAnimationConfig): Animation;
Parameters
value: number | ((prev: number) => number)The binding value.
config: TimingAnimationConfig(Optional) The animation configuration that specifies the easing curve.
Returns
Animation

UIComponent Class
Extends Component<TComponent, TState>
The base class for a UI panel, and the scripting component to attach to a UI Gizmo. It inherits the methods and properties from its parent Component class, with some UI-specialized additions.
Signature
export declare abstract class UIComponent<TComponent = ComponentWithConstructor<Record<string, unknown>>, TState extends SerializableState = SerializableState> extends Component<TComponent, TState>
Remarks
For information about usage, see the Custom UI Examples tutorial.
Properties
panelHeight
[readonly]
The height of the panel.

Signature
protected readonly panelHeight: number;
panelWidth
[readonly]
The width of the UI panel.

Signature
protected readonly panelWidth: number;

Methods
initializeUI() abstract
Defines the UI and sets up necessary event subscriptions. This method is called before the UIComponent.start() method when the component is started.

Signature
abstract initializeUI(): UINode;
Returns
UINode
Remarks
This method must return a valid UINode.
start()
A default start implementation for classes that inherit from UIComponent.

Signature
start(): void;
Returns
void

ValueBindingBase Class
The base class for value-based bindings, including Binding and DerivedBinding. These bindings are represented as string keys in the data model, and their values are updated in the redux store. These bindings support both global values and player-specific values.
Signature
export declare abstract class ValueBindingBase<T>
AnimatedBinding Class
Extends ValueBindingBase<number>
A binding that supports animations when setting values. Only numbers are supported.
Signature
export declare class AnimatedBinding extends ValueBindingBase<number>
Remarks
For information about usage, see Animations For Custom UIs.
Constructors
(constructor)(value)
Constructs a new instance of the AnimatedBinding class.

Signature
constructor(value: number);
Parameters
value: numberThe value of the binding.

Methods
interpolate(inputRange, outputRange)
Returns and interpolated version of the animated binding.

Signature
interpolate<T extends number | string | Color>(
    inputRange: Array<number>, 
    outputRange: Array<T>): AnimatedInterpolation<T>;
Parameters
inputRange: Array<number>
outputRange: Array<T>
Returns
AnimatedInterpolation<T>
reset(players)
Resets the player-specific value of the binding, if any, back to the global value. Like the method, this method also queues a re-render operation for all UI panels that use this Binding.

Signature
reset(players?: Array<Player>): void;
Parameters
players: Array<Player>(Optional) The players to reset the value for. If not provided, all player-spesific values are cleared. If provided, only value for players in the list are reset and receive the global value.
Returns
void
set(value, onEnd, players)
Updates the value of the binding and queues a re-render operation for all UI panels that use the binding. The UI does not update if the new and old values are the same.

Signature
set(value: number | ((prev: number) => number) | Animation, onEnd?: AnimationOnEndCallback, players?: Array<Player>): void;
Parameters
value: number | ((prev: number) => number) | AnimationThe new value of the binding.
onEnd: AnimationOnEndCallback(Optional) The callback that is triggered when the animation ends.
players: Array<Player>(Optional) The players to apply the updated value to. This is used to determine whether the global value or the player-specific value should be updated. When not provided, all players receive the updated value; the global value is updated, and any player-specific values are cleared. When provided, only those players will get the new value as a new player-specific value, but the global value is unchanged.
Returns
void
stopAnimation(players)
Stops the binding animation for the given players.

Signature
stopAnimation(players?: Array<Player>): void;
Parameters
players: Array<Player>(Optional) The players to stop the animation for.
Returns
void

AnimatedInterpolation Class
Extends ValueBindingBase<T>
A type of animated binding that is interpolated from another animated binding.
Signature
export declare class AnimatedInterpolation<T extends number | string | Color> extends ValueBindingBase<T>
Remarks
For more information, see the developer guide about interpolation.
Binding Class
Extends ValueBindingBase<T>
Represents a container for a variable value used by UI components. It can be passed to the supported props and styles of a component in place of an explicit value. When the value of the Binding is updated at runtime, the UI panels that use it are automatically re-rendered to reflect the change.
Signature
export declare class Binding<T> extends ValueBindingBase<T>
Remarks
There are other types of bindings, but this is the most basic type, where the Binding value is directly controlled in TypeScript.
For detail about usage, see Building Dynamic Custom UIs.
Constructors
(constructor)(value)
Creates a Binding.

Signature
constructor(value: T);
Parameters
value: TThe initial value of the Binding.

Methods
derive(mapFn)
Derives a new value from a list of Bindings with the provided map function.

Signature
static derive<R, A extends unknown[]>(dependencies: [...Dependencies<A>], mapFn: (...args: A) => R): DerivedBinding<R, A>;
Parameters
dependencies: [...Dependencies<A>]The list of Bindings to depend on.
mapFn: (...args: A) => RA function that specifies how the derived value is calculated from the Bindings that it depends on. It takes the values of the dependencies as parameters, and returns the derived value.
Returns
DerivedBinding<R, A>A derived Binding. Just like a Binding, it can be passed to the supported props and styles of a component in place of an explicit value. However, it does not have a set() method; its value is purely derived from the Bindings that it depends on.
derive(dependencies, mapFn) static
Derives a new value from a list of Bindings with the provided map function.

Signature
static derive<R, A extends unknown[]>(dependencies: [...Dependencies<A>], mapFn: (...args: A) => R): DerivedBinding<R, A>;
Parameters
dependencies: [...Dependencies<A>]The list of Bindings to depend on.
mapFn: (...args: A) => RA function that specifies how the derived value is calculated from the Bindings that it depends on. It takes the values of the dependencies as parameters, and returns the derived value.
Returns
DerivedBinding<R, A>A derived Binding. Just like a Binding, it can be passed to the supported props and styles of a component in place of an explicit value. However, it does not have a set() method; its value is purely derived from the Bindings that it depends on.
reset(players)
Resets the player-specific value of the binding, if any, back to the global value. Like the method, this method also queues a re-render operation for all UI panels that use this Binding.

Signature
reset(players?: Array<Player>): void;
Parameters
players: Array<Player>(Optional) The players to reset the value for. If not provided, all player-spesific values are cleared. If provided, only value for players in the list are reset and receive the global value.
Returns
void
set(value, players)
Updates the value of the Binding and queues a re-render operation for all UI panels that use the Binding. The UI does not update if the new and old values are the same.

Signature
set(value: T | ((prev: T) => T), players?: Array<Player>): void;
Parameters
value: T | ((prev: T) => T)The new value of the Binding, or an update function, which receives the previous value, and should return the updated value.
players: Array<Player>(Optional) An optional array of players to send the value update to. It is used to determine whether the global value or the player-specific value should be updated. When not provided, all players receive the updated value; the global value is updated, and any player-specific values are cleared. When provided, only those players will get the new value as a new player-specific value, but the global value is unchanged.
Returns
void

Easing Class
A set of easing functions for configuring timing animations. Easing functions provide physical motion animations.
Signature
export declare class Easing
Properties
back
static
[readonly]
A back easing.

Signature
static get back(): Easing;
bounce
static
[readonly]
An easing that provides a bouncing animation.

Signature
static get bounce(): Easing;
circle
static
[readonly]
A circular easing.

Signature
static get circle(): Easing;
cubic
static
[readonly]
A cubic easing.

Signature
static get cubic(): Easing;
ease
static
[readonly]
An easing that starts slow, accelerates quickly, and then gradually slows down until stopping.

Signature
static get ease(): Easing;
exp
static
[readonly]
An exponential easing.

Signature
static get exp(): Easing;
linear
static
[readonly]
A linear easing.

Signature
static get linear(): Easing;
quad
static
[readonly]
A quadratic easing.

Signature
static get quad(): Easing;
sin
static
[readonly]
A sin easing.

Signature
static get sin(): Easing;

Methods
bezier(x1, y1, x2, y2) static
Returns an easing that uses a cubic bezier curve.

Signature
static bezier(x1: number, y1: number, x2: number, y2: number): Easing;
Parameters
x1: numberThe x coordinate of the first control point of the curve.
y1: numberThe y coordinate of the first control point of the curve.
x2: numberThe x coordinate of the second control point of the curve.
y2: numberThe y coordinate of the second control point of the curve.
Returns
Easing
elastic(bounciness) static
Returns and elastic easing.

Signature
static elastic(bounciness: number): Easing;
Parameters
bounciness: number
Returns
EasingThe updated easing.
in(easing) static
Returns an easing that runs forwards.

Signature
static in(easing: Easing): Easing;
Parameters
easing: EasingThe easing to update.
Returns
EasingThe updated easing.
inOut(easing) static
Returns an easing that runs forwards and then backwards.

Signature
static inOut(easing: Easing): Easing;
Parameters
easing: EasingThe easing to update.
Returns
EasingThe updated easing.
out(easing) static
Returns an easing that runs backwards.

Signature
static out(easing: Easing): Easing;
Parameters
easing: EasingThe easing to update.
Returns
EasingThe updated easing.
poly(n) static
Returns a power easing.

Signature
static poly(n: number): Easing;
Parameters
n: number
Returns
EasingThe updated easing.

ImageSource Class
Represents the source of an image used by an Image component.
Signature
export declare class ImageSource
Remarks
In order to apply an image to an Image component, the image must be uploaded as a PNG to your Asset Library.
For information about usage, see the Image from Asset section of the Custom UI Examples tutorial.
Methods
fromTextureAsset(texture) static
Gets an image based on a texture asset.

Signature
static fromTextureAsset(texture: TextureAsset): ImageSource;
Parameters
texture: TextureAssetThe texture asset to use as the source.
Returns
ImageSourceThe image source for the given texture asset.

UIGizmo Class
Extends Entity
Represents the Custom UI Gizmo used to create custom 2D UI panels containing interactive text, images, and other elements.
Signature
export declare class UIGizmo extends Entity
Remarks
For information about usage, see the Custom UI Examples tutorial.
Methods
toString()
Creates a human-readable representation of the UI Gizmo.

Signature
toString(): string;
Returns
stringA string representation of the gizmo.

UINode Class
Represents a UI element.
Signature
export declare class UINode<T extends UIComponentProps = UIComponentProps>
Methods
if(condition, trueComponent, falseComponent) static
Conditionally renders the UI element.

Signature
static if(condition: Bindable<boolean>, trueComponent?: UIChildren, falseComponent?: UIChildren): UINode<ConditionalProps>;
Parameters
condition: Bindable<boolean>The condition to check. Accepts a boolean or a binding of a boolean.
trueComponent: UIChildren(Optional) The UI element to render when the condition is true. If not provided, nothing is rendered when the condition is true.
falseComponent: UIChildren(Optional) The UI element to render when the condition is false. If not provided, nothing is rendered when the condition is false.
Returns
UINode<ConditionalProps>A UINode that represents the result of the conditional rendering.

DynamicList() Function
Creates a DynamicList component.
Signature
export declare function DynamicList<T>(props: Readonly<DynamicListProps<T>>): UINode<DynamicListProps<T>>;
Parameters
props: Readonly<DynamicListProps<T>>Props of the DynamicList component.
Returns
UINode<DynamicListProps<T>>A UINode representing the DynamicList component.
Image_2() Function
Creates an Image component.
Signature
export declare function Image(props: Readonly<ImageProps>): UINode<ImageProps>;
Parameters
props: Readonly<ImageProps>The props of the Image component.
Returns
UINode<ImageProps>A UINode representing the Image component.
Remarks
You can use the ImageSource class to define the source of an image asset. For information about usage, see the Image from Asset section of the Custom UI Examples tutorial.
Pressable() Function
Creates a Pressable component.
Signature
export declare function Pressable(props: Readonly<PressableProps>): UINode<PressableProps>;
Parameters
props: Readonly<PressableProps>Props of the Pressable component.
Returns
UINode<PressableProps>A UINode representing the Pressable component.
ScrollView() Function
Creates a ScrollView component.
Signature
export declare function ScrollView(props: Readonly<ScrollViewProps>): UINode<ScrollViewProps>;
Parameters
props: Readonly<ScrollViewProps>Props of the ScrollView component.
Returns
UINode<ScrollViewProps>A UINode representing the ScrollView component.
Text_2() Function
Creates a Text component.
For information about usage, see the Text and Fonts section of the Custom UI Examples tutorial.
Signature
export declare function Text(props: Readonly<TextProps>): UINode<TextProps>;
Parameters
props: Readonly<TextProps>The props of the Text component.
Returns
UINode<TextProps>A UINode representing the Text component.
View() Function
Creates a View component.
Signature
export declare function View(props: Readonly<ViewProps>): UINode<ViewProps>;
Parameters
props: Readonly<ViewProps>Props of the View component.
Returns
UINode<ViewProps>A UINode representing the View component.
Bindable type
Represents a type that can bind to a UI element. Bound types are re-rendered when the bound properties change.
Signature
export declare type Bindable<T> = T | AnyBinding<T> | DistributeBindingForUnion<T>;
BindingSet type
Stores a set of bindings (both Binding and DerivedBinding) during data model serialization.
Signature
export declare type BindingSet = Set<ValueBindingBase<unknown>>;
References
ValueBindingBase
BorderStyle type
Represents the styles of a UI element's border.
Signature
export declare type BorderStyle = {
    borderColor?: Bindable<ColorValue>;
    borderRadius?: number;
    borderBottomLeftRadius?: number;
    borderBottomRightRadius?: number;
    borderTopLeftRadius?: number;
    borderTopRightRadius?: number;
    borderWidth?: Bindable<number>;
    borderBottomWidth?: number;
    borderEndWidth?: number;
    borderLeftWidth?: number;
    borderRightWidth?: number;
    borderStartWidth?: number;
    borderTopWidth?: number;
};
References
Bindable, ColorValue
Callback type
Represents a callback function interface for a Player object.
Signature
export declare type Callback = (player: Player) => void;
Remarks
Type Parameters:
player - The player associated with the callback.
CallbackMap type
Stores a map of IDs to callback functions for use during data model serialization.
Signature
export declare type CallbackMap = Map<string, Callback | CallbackWithPayload>;
References
Callback, CallbackWithPayload
CallbackWithPayload type
Represents a callback function interface for a Player object and its associated data.
Signature
export declare type CallbackWithPayload = (player: Player, payload: string) => void;
Remarks
Type Parameters:
player - The player associated with the callback.
payload - The data associated with the player.
ColorValue type
The base type for colors.
Signature
export declare type ColorValue = string | Color;
ConditionalProps type
Represents the props of a UINode.if() node (for conditional rendering).
Signature
export declare type ConditionalProps = {
    condition: Bindable<boolean>;
    true?: UIChildren;
    false?: UIChildren;
};
References
Bindable, UIChildren
DimensionValue type
The base type for dimensions.
Signature
export declare type DimensionValue = number | string;
DynamicListProps type
Represents the props of a creator facing DynamicList component.
Signature
export declare type DynamicListProps<T> = {
    data: Binding<T[]>;
    renderItem: (item: T, index?: number) => UINode;
    style?: ViewStyle;
};
References
Binding, UINode, ViewStyle
FontFamily type
Defines the available fonts for UI element text.
Signature
export declare type FontFamily = 'Anton' | 'Bangers' | 'Kallisto' | 'Optimistic' | 'Oswald' | 'Roboto' | 'Roboto-Mono';
ImageProps type
Represents the props of an Image component.
Signature
export declare type ImageProps = {
    source?: Bindable<ImageSource | null>;
    style?: ImageStyle;
};
References
Bindable, ImageSource, ImageStyle
ImageStyle type
Represents the styles of an Image component.
Signature
export declare type ImageStyle = ViewStyle & {
    resizeMode?: 'cover' | 'contain' | 'stretch' | 'center' | 'repeat';
    tintColor?: Bindable<ColorValue>;
    tintOperation?: 'replace' | 'multiply';
};
References
ViewStyle, Bindable, ColorValue
LayoutStyle type
The base type for a layout.
Signature
export declare type LayoutStyle = {
    display?: Bindable<'none' | 'flex'>;
    width?: Bindable<DimensionValue>;
    height?: Bindable<DimensionValue>;
    bottom?: Bindable<DimensionValue>;
    end?: DimensionValue;
    left?: Bindable<DimensionValue>;
    right?: Bindable<DimensionValue>;
    start?: DimensionValue;
    top?: Bindable<DimensionValue>;
    minWidth?: DimensionValue;
    maxWidth?: DimensionValue;
    minHeight?: DimensionValue;
    maxHeight?: DimensionValue;
    margin?: DimensionValue;
    marginBottom?: DimensionValue;
    marginEnd?: DimensionValue;
    marginHorizontal?: DimensionValue;
    marginLeft?: DimensionValue;
    marginRight?: DimensionValue;
    marginStart?: DimensionValue;
    marginTop?: DimensionValue;
    marginVertical?: DimensionValue;
    padding?: DimensionValue;
    paddingBottom?: DimensionValue;
    paddingEnd?: DimensionValue;
    paddingHorizontal?: DimensionValue;
    paddingLeft?: DimensionValue;
    paddingRight?: DimensionValue;
    paddingStart?: DimensionValue;
    paddingTop?: DimensionValue;
    paddingVertical?: DimensionValue;
    position?: 'absolute' | 'relative';
    flexDirection?: 'row' | 'row-reverse' | 'column' | 'column-reverse';
    flexWrap?: 'nowrap' | 'wrap' | 'wrap-reverse';
    justifyContent?: 'flex-start' | 'flex-end' | 'center' | 'space-between' | 'space-around' | 'space-evenly';
    alignContent?: 'flex-start' | 'flex-end' | 'center' | 'stretch' | 'space-between' | 'space-around';
    alignItems?: 'flex-start' | 'flex-end' | 'center' | 'stretch' | 'baseline';
    alignSelf?: 'auto' | 'flex-start' | 'flex-end' | 'center' | 'stretch' | 'baseline';
    overflow?: 'visible' | 'hidden';
    flex?: number;
    flexGrow?: number;
    flexShrink?: number;
    flexBasis?: DimensionValue;
    aspectRatio?: number;
    zIndex?: number;
    layoutOrigin?: [number, number];
    direction?: 'inherit' | 'ltr' | 'rtl';
};
References
Bindable, DimensionValue
PressableProps type
Represents the props of a Pressable component.
Signature
export declare type PressableProps = {
    children?: UIChildren;
    disabled?: Bindable<boolean>;
    onClick?: Callback;
    onEnter?: Callback;
    onExit?: Callback;
    onPress?: Callback;
    onRelease?: Callback;
    propagateClick?: boolean;
    style?: ViewStyle;
};
References
UIChildren, Bindable, Callback, ViewStyle
ScrollViewProps type
Represents the props of a ScrollView component.
Signature
export declare type ScrollViewProps = ViewProps & {
    contentContainerStyle?: ViewStyle;
    horizontal?: boolean;
};
References
ViewProps, ViewStyle
ShadowStyle type
Represents the style of a UI element's shadow.
Signature
export declare type ShadowStyle = {
    shadowColor?: Bindable<ColorValue>;
    shadowFalloff?: 'linear' | 'sqrt' | 'sigmoid';
    shadowOffset?: [number, number];
    shadowOpacity?: Bindable<number>;
    shadowRadius?: number;
    shadowSpreadRadius?: number;
};
References
Bindable, ColorValue
TextProps type
Represents the props of a Text component.
Signature
export declare type TextProps = {
    text: Bindable<string | LocalizableText>;
    numberOfLines?: number;
    style?: TextStyle;
};
References
Bindable, TextStyle
TextStyle type
Represents the styles of a Text component.
Signature
export declare type TextStyle = ViewStyle & {
    color?: Bindable<ColorValue>;
    fontFamily?: FontFamily;
    fontSize?: Bindable<number>;
    fontWeight?: Bindable<'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'>;
    letterSpacing?: number;
    lineHeight?: number;
    textAlign?: 'auto' | 'left' | 'right' | 'center';
    textAlignVertical?: 'auto' | 'top' | 'bottom' | 'center';
    textDecorationLine?: Bindable<'none' | 'underline' | 'line-through' | 'underline line-through'>;
    textShadowColor?: Bindable<ColorValue>;
    textShadowOffset?: [number, number];
    textShadowRadius?: number;
    whiteSpace?: 'normal' | 'pre-line' | 'pre-wrap';
};
References
ViewStyle, Bindable, ColorValue, FontFamily
TimingAnimationConfig type
Defines how to a value along an easing curve.
Signature
export declare type TimingAnimationConfig = {
    duration?: number;
    easing?: Easing;
};
References
Easing
Remarks
Type Parameters:
duration - The duration of the animation.
easing - The function that defines the easing curve.
TransformStyle type
The styles used to transform a UI element.
Signature
export declare type TransformStyle = {
    transform?: Array<{
        rotate: Bindable<string>;
    } | {
        scale: Bindable<number>;
    } | {
        scaleX: Bindable<number>;
    } | {
        scaleY: Bindable<number>;
    } | {
        translate: [Bindable<number>, Bindable<number>];
    } | {
        translateX: Bindable<number>;
    } | {
        translateY: Bindable<number>;
    } | {
        skewX: Bindable<string>;
    } | {
        skewY: Bindable<string>;
    }>;
    transformOrigin?: [DimensionValue, DimensionValue];
};
References
Bindable, DimensionValue
UIChildren type
The child nodes of a UI element.
Signature
export declare type UIChildren = UINode | UINode[];
References
UINode
ViewProps type
Represents the props of a View component.
Signature
export declare type ViewProps = {
    children?: UIChildren;
    style?: ViewStyle;
};
References
UIChildren, ViewStyle
ViewStyle type
Represents the styles of a View component.
Signature
export declare type ViewStyle = LayoutStyle & BorderStyle & ShadowStyle & TransformStyle & {
    backgroundColor?: Bindable<ColorValue>;
    backgroundClip?: 'border-box' | 'padding-box';
    opacity?: Bindable<number>;
    gradientColorA?: Bindable<ColorValue>;
    gradientColorB?: Bindable<ColorValue>;
    gradientXa?: number | string;
    gradientYa?: number | string;
    gradientXb?: number | string;
    gradientYb?: number | string;
    gradientAngle?: string;
};
References
LayoutStyle, BorderStyle, ShadowStyle, TransformStyle, Bindable, ColorValue
AssetBundleGizmo Class
Extends Entity
Represents a Unity AssetBundle, which is an archive of design assets that Unity can load at runtime.
Signature
export declare class AssetBundleGizmo extends Entity 
Remarks
For more information about AssetBundles, see the Horizon developer guides and the Unity developer guides (external).
Methods
getPrefabNames()
Get the names of all prefabs in the AssetBundle instance.
Signature
getPrefabNames(): string[];
Returns
string[]The names of the prefabs in the AssetBundle instance.
getReference(name, throwIfNotExist)
Gets an AssetBundleInstanceReference for an exposed GameObject in the loaded prefab. These need to be specified at export time in the HorizonUnityAssetReferences MonoBehaviour.
Signature
getReference(name: string, throwIfNotExist: boolean): AssetBundleInstanceReference;
Parameters
name: stringThe name of the GameObject.
throwIfNotExist: booleanIndicates whether to throw an exception if the GameObject does not exist.
Returns
AssetBundleInstanceReferenceA reference to the GameObject.
Exceptions


Thrown if throwIfNotExist is true and the GameObject does not exist.


getRoot()
Gets an AssetBundleInstanceReference for the main GameObject.
Signature
getRoot(): AssetBundleInstanceReference;
Returns
AssetBundleInstanceReferenceA reference to the main GameObject.
isLoaded()
Determines whether a prefab is instantiated and the root reference is ready.
Signature
isLoaded(): boolean;
Returns
booleantrue if a prefab is instantiated and the root reference is ready, false otherwise.
loadPrefab(name)
Loads a prefab from a Unity AssetBundle.
Signature
loadPrefab(name: string): void;
Parameters
name: stringThe name of the prefab to load. The method retrieves the prefab names in the AssetBundle.
Returns
void
Examples
Dynamically load a prefab:
this.entity.as(AssetBundleGizmo).loadPrefab("Prefab01");
Remarks
A prefab is a type of preconfigured Unity GameObject that includes its dependent objects and can be stored as a reusable asset.
To unload a prefab, see .
toString()
Returns the class type and ID of the AssetBundleGizmo.
Signature
toString(): string;
Returns
stringThe class type and ID of the AssetBundleGizmo.
unloadPrefab()
Unloads the in the AssetBundleGizmo.
Signature
unloadPrefab(): void;
Returns
void
Remarks
A prefab is a type of preconfigured Unity GameObject that includes its dependent objects and can be stored as a reusable asset.
AssetBundleInstanceReference Class
Represents a reference to a Unity AssetBundle.
Signature
export declare class AssetBundleInstanceReference
Constructors
(constructor)(entity, referenceName)
Creates an instance of AssetBundleInstanceReference.

Signature
constructor(entity: Entity, referenceName: string);
Parameters
entity: EntityThe parent entity.
referenceName: stringThe name of the reference.

Properties
style
Signature
style: IEntityStyle;

Methods
getAnimationParameters()
Gets the parameters for an animation.

Signature
getAnimationParameters(): {
        [name: string]: string | string;
    };
Returns
{ [name: string]: string | string; }The names and values of the animation parameters.
isLoaded()
Determines whether an AssetBundle is loaded.

Signature
isLoaded(): boolean;
Returns
booleantrue if the AssetBundle is loaded, false otherwise.
resetAnimationParameterTrigger(name, localOnly)
Resets the value of the animation parameter with the given name.

Signature
resetAnimationParameterTrigger(name: string, localOnly?: boolean): void;
Parameters
name: stringThe name of the animation parameter to reset.
localOnly: boolean(Optional)true only resets the local animation; otherwise, resets the global animation.
Returns
void
setAnimationParameterBool(name, value, localOnly)
Sets the value of a boolean animation parameter.

Signature
setAnimationParameterBool(name: string, value: boolean, localOnly?: boolean): void;
Parameters
name: stringThe name of the animation parameter to set.
value: booleanThe value for the animation parameter.
localOnly: boolean(Optional)true only sets the value for the local animation; otherwise, sets the value for the global animation.
Returns
void
setAnimationParameterFloat(name, value, localOnly)
Sets the value of a float animation parameter.

Signature
setAnimationParameterFloat(name: string, value: number, localOnly?: boolean): void;
Parameters
name: stringThe name of the animation parameter to set.
value: numberThe value for the animation parameter.
localOnly: boolean(Optional)true only sets the value for the local animation; otherwise, sets the value for the global animation.
Returns
void
setAnimationParameterInteger(name, value, localOnly)
Sets the value of an integer animation parameter.

Signature
setAnimationParameterInteger(name: string, value: number, localOnly?: boolean): void;
Parameters
name: stringThe name of the animation parameter to set.
value: numberThe value for the animation parameter.
localOnly: boolean(Optional)true only sets the value for the local animation; otherwise, sets the value for the global animation.
Returns
void
setAnimationParameterTrigger(name, localOnly)
Activates an animation trigger.

Signature
setAnimationParameterTrigger(name: string, localOnly?: boolean): void;
Parameters
name: stringThe name of the animation parameter to activate.
localOnly: boolean(Optional)true only activates the local animation trigger; otherwise, activates the global animation trigger.
Returns
void
setMaterial(material, options)
Sets the material of a mesh.

Signature
setMaterial(material: string | MaterialAsset, options?: SetMaterialOptions): void;
Parameters
material: string | MaterialAssetThe material name or material asset to set.
options: SetMaterialOptions(Optional) The slot index options for the material, which are used to specify the material to update when updating meshes with multiple materials.
Returns
void
Examples
class Button extends Component<typeof Button> {
  static propsDefinition = {
    material: {type: PropTypes.Asset},
    materialSlot: {type: PropTypes.Number},
    targetEntity: {type: PropTypes.Entity},
  };

  start() {
    this.connectCodeBlockEvent(this.entity, CodeBlockEvents.OnPlayerEnterTrigger, () => this.onButtonPress());
  }

  onButtonPress() {
    const options = { materialSlot: this.props.materialSlot };
    this.props.targetEntity
      .as(AssetBundleGizmo)!
      .getRoot()
      .setMaterial(this.props.material, options);
  }
}
Remarks
Material names reference materials registered in the SwappableMaterials list in Unity.
setMesh(meshName)
Swaps the mesh of an entity with another mesh registered in the SwappableMesh list in Unity.

Signature
setMesh(meshName: string): void;
Parameters
meshName: stringThe name of the mesh to set.
Returns
void

IEntityStyle Interface
Represents a style for a Unity AssetBundle.
Signature
export interface IEntityStyle
Examples
outColor.rgb = lerp(inColor.rgb, Luminance(inColor.rgb) * tintColor, tintStrength) * brightness;
Properties
brightness
The brightness of the entity. brightness is from 0 - 100, 0 - black, 1 - no adjustment, 100 - very bright, defaults to 1.

Signature
brightness: HorizonProperty<number>;
tintColor
The tint color of the entity. tintColor is in RGB range from 0 - 1, defaults to 1, 1, 1 (no tint color).

Signature
tintColor: HorizonProperty<Color>;
tintStrength
The tint strength of the entity. tintStrength is from 0 - 1, 0 - no tint, 1 - fully tint, defaults to 0.

Signature
tintStrength: HorizonProperty<number>;

SetMaterialOptions type
Options for how is applied.
Signature
export declare type SetMaterialOptions = {
    materialSlot?: number;
};
unityAnimationEvent Variable
An animation event of the NetworkEvent type.
Signature
unityAnimationEvent: NetworkEvent<{
    eventName: string;
    entityId: bigint;
}>
Remarks
You can subscribe to this event using the method.
Parameters:
eventName - The name of the event.
entityId - The ID of the event.
SublevelEntity Class
Extends Entity
A sublevel of a world that you can stream independentaly from the rest of the world at runtime.
Signature
export declare class SublevelEntity extends Entity
Examples
This example demonstrates how to spawn and despawn sublevels at runtime.
import { Component, PropTypes, Entity, CodeBlockEvents } from 'horizon/core';
import { SublevelEntity } from 'horizon/world_streaming';




class TestSublevelAPI extends Component {
  static propsDefinition = {
    sublevel: {type: PropTypes.Entity},
    state: {type: 'number', default: 0}, // States 0 to 4 are:
                                         // Unloaded, Loaded, Active,
                                         // Pause, and Hide (Loaded).
  };


  start() {
    this.connectCodeBlockEvent(this.entity, CodeBlockEvents.OnPlayerEnterTrigger, async (player) = {
      var sublevel = this.props.sublevel?.as(SublevelEntity);
      var state = this.props.state;




      if (sublevel == null || sublevel == undefined) {
        console.log("The sublevel entity was either null or invalid.")
        return;
      }


      console.log("Sublevel Trigger entered. Trying to set sublevel " + sublevel.toString() + " to " + state + ", current sublevel state is " + sublevel.currentState.get() + ", previous target sublevel state is " + sublevel.targetState.get());
      switch(state) {
        case 0: {
          sublevel.unload().then(() = {
            console.log("Sublevel " + sublevel?.toString() + " is now unloaded!");
          });
          break;
        }
        case 1: {
          sublevel.load().then(() = {
            console.log("Sublevel " + sublevel?.toString() + " is now loaded!");
          });
          break;
        }
        case 2: {
          sublevel.activate().then(() = {
            console.log("Sublevel " + sublevel?.toString() + " is now activated!");
          });
          break;
        }
        case 3: {
          sublevel.pause().then(() = {
            console.log("Sublevel " + sublevel?.toString() + " is now paused!");
          });
          break;
        }
        case 4: {
          sublevel.hide().then(() = {
            console.log("Sublevel " + sublevel?.toString() + " is now hidden!");
          });
          break;
        }
        default: {
          console.log("Invalid/Unexpected sublevel state # given: " + state);
          // unexpected state
          break;
        }
      }
    });
  }
}
Component.register(TestSublevelAPI);
Remarks
Sublevels are a way to break up a world into smaller pieces that you can stream separately from other portions of the world. Streaming sublevels can have performance benefits when spawning large amounts of static content that is always spawned at the same location.
For more information about world streaming, see the World Streaming guide.
To spawn smaller sets of dynamic content at runtime, you should use a SpawnController object to spawn and despawn assets. For more information about asset spawning, see the Introduction to Asset Spawning guide.
Properties
currentState
[readonly]
Gets the current state of the sublevel.

Signature
readonly currentState: ReadableHorizonProperty<SublevelStates>;
targetState
[readonly]
Gets the state the sublevel is attempting to reach.

Signature
readonly targetState: ReadableHorizonProperty<SublevelStates>;

Methods
activate()
Loads the sublevel's asset data if not already loaded and makes it active in the world.

Signature
activate(): Promise<void>;
Returns
Promise<void>A promise that resolves when the sublevel is active.
hide()
Despawns the sublevel and preloads the sublevel's asset data so it can be re-activated later.

Signature
hide(): Promise<void>;
Returns
Promise<void>A promise that resolves when the sublevel is loaded.
load()
Preloads the sublevel's asset data so it can be activated later.

Signature
load(): Promise<void>;
Returns
Promise<void>A promise that resolves when the sublevel is loaded.
pause()
Pauses the sublevel's asset data loading.

Signature
pause(): Promise<void>;
Returns
Promise<void>A promise that resolves when the sublevel is paused.
toString()
Creates a human-readable representation of the SublevelEntity.

Signature
toString(): string;
Returns
stringA string representation of the SublevelEntity.
unload()
Despawns the sublevel's asset data.

Signature
unload(): Promise<void>;
Returns
Promise<void>A promise that resolves when the sublevel is unloaded.

SublevelStates Enum
The possible states of a sublevel in a world when using world streaming.
Signature
export declare enum SublevelStates
Enumeration Members
Member
Value
Description
Active
5
The spawn is complete and the sublevel is ready for use.
Loaded
4
The sublevel's loading is complete and ready to be enabled, but does not yet count towards capacity.
Loading
2
The sublevel's asset data is loading.
NotReady
0
The sublevel's asset data is not yet available.
Paused
3
The sublevel's loading is paused.
Unloaded
1
The sublevel's asset data is available but not loaded.
Unloading
6
The sublevel is in the process of unloading.

Remarks


For more information about world streaming, see the World Streaming guide.


Social Class
Manages the friend system and related social functionality between players in a world.
Signature
export declare class Social
Examples
private followerLogging(player1: Player, player2: Player) {
  const socialService = this.world.social;


  // Get the number of followers that the local player has in the current world
  socialService.getPlayerFollowerCountInWorld(player1).then(count => {
    console.log(Player 1 has ${count} followers in this world.);
  });


  // Check whether or not player 1 is following player 2
  socialService.isPlayerFollowing(player1, player2).then(isFollowing => {
    console.log(Player 1 is ${isFollowing ? 'following' : 'not following'} player 2.);


    // If not following, send an invite
    if (!isFollowing) {
      socialService.showFollowRequestModal(player1, player2).then(accepted => {
        console.log(Follow request was ${accepted ? 'accepted' : 'declined'}.);
      });
    }
  });
}
Remarks
You can use this class to send follow requests between players and get follower and following counts for distributing achievements and rewards based on the level of engagement between players in your world.
Methods
areMutuallyFollowing(player1, player2) static
Checks if two players are following each other in Meta Horizon Worlds.
Signature
static areMutuallyFollowing(player1: Player, player2: Player): Promise<boolean>;
Parameters
player1: PlayerThe first player to check.
player2: PlayerThe second player to check.
Returns
Promise<boolean>A promise that resolves to true if both players are following each other; false otherwise.
Exceptions


Throws a TypeError exception if the input is not a valid Player object.
Remarks
This is a convenience method that indicates whether isPlayerFollowing is true for both players. This method is not supported on server scripts. Please change script execution mode to local.
getAvatarImageSource(player, options) static
Gets an image based on the player's avatar.
Signature
static getAvatarImageSource(player: Player, options?: IAvatarImageOptions): Promise<ImageSource>;
Parameters
player: Player
options: IAvatarImageOptions(Optional)
Returns
Promise<ImageSource>The avatar image source for the given player.
Examples
Example 1
Local Player:
import {
   Color,
 } from "horizon/core";
import { Social } from "horizon/social";
import {
 UIComponent,
 View,
 Image,
 ImageSource,
 Binding,
} from "horizon/ui";

class PlayerIcon extends UIComponent<typeof PlayerIcon> {
 static propsDefinition = {};
   panelHeight = 88;
   panelWidth = 88;
   private _image!: Binding<ImageSource>;

 async start() {
   this._image.set(await Social.getAvatarImageSource(this.world.getLocalPlayer()));
 }

 initializeUI() {
   this.initializeBindings();
   var iconStyle = {
     height: this.panelHeight,
     width: this.panelWidth,
     borderRadius: this.panelWidth/2,
     borderWidth: 2,
     borderColor: Color.white,
     backgroundColor: Color.fromHex("#99b4e2")
   };

  return View({
     children: [
       Image({
         source: this._image,
         style: iconStyle,
       }),
     ],
     style: { backgroundColor: "transparent", position: "absolute", bottom: 10, right: 10 },
   });
 }

 initializeBindings() {
   this._image = new Binding<ImageSource>(new ImageSource());
 }
}

UIComponent.register(PlayerIcon);
Example 2
Network Player: Get Avatar for closest player in front of you, remove avatar when player is out of proximity
async start() {
   this.connectNetworkEvent(this.world.getLocalPlayer(), Events.playerProximityEvent, async (data: {player: Player}) => {
    this.visible.set(data.player != undefined)
    if (data.player)
    {
      this._image.set(await Social.getAvatarImageSource(data.player));
    }
  })

  this.connectNetworkEvent(this.world.getLocalPlayer(), Events.noProximityEvent, async (data) => {
    this.visible.set(false)
    this._image.set(new Binding<ImageSource>(new ImageSource()));
  })
 }
Remarks
This method is only available in conjunction with the horizon/ui API Only works on Client. Make sure your Custom UI panel and script is local.
getFollowingStatus(requestor, target) static
Checks the given player's following status for the target player in Meta Horizon Worlds.
Signature
static getFollowingStatus(requestor: Player, target: Player): Promise<FollowStatus>;
Parameters
requestor: PlayerThe player who you are checking the status for.
target: PlayerThe target player that is potentially being followed.
Returns
Promise<FollowStatus>A promise that resolves to a FollowStatus enum value describing the current follow status.
Exceptions


Throws a TypeError if the input is not a valid Player object.
Remarks
This method is not supported on server scripts. Please change script execution mode to local.
getPlayerFollowerCountInWorld(player) static
Gets the total number of players that are following the given player in the world. Note: There can be a delay of up to 12 seconds (or longer) between when a player follows another player and when the count is updated.
Signature
static getPlayerFollowerCountInWorld(player: Player): Promise<number>;
Parameters
player: PlayerThe player to retrieve the follower count for.
Returns
Promise<number>A promise that resolves to the number of retrieved followers.
Remarks
This method is not supported on server scripts. Please change script execution mode to local.
getPlayerFollowingCountInWorld(player) static
Gets the total number of players the given player is following in the world. Note: There can be a delay of up to 12 seconds (or longer) between when a player follows another player and when the count is updated.
Signature
static getPlayerFollowingCountInWorld(player: Player): Promise<number>;
Parameters
player: PlayerThe player to retrieve the following count for.
Returns
Promise<number>A promise that resolves to the number of players the given player is following in the world.
Remarks
This method is not supported on server scripts. Please change script execution mode to local.
getPlayerMutuallyFollowCountInWorld(player) static
Gets the total number of mutual followers in the world for the given player. Note: There can be a delay of up to 12 seconds (or longer) between when a player follows another player and when the count is updated.
Signature
static getPlayerMutuallyFollowCountInWorld(player: Player): Promise<number>;
Parameters
player: PlayerThe player to check the mutual follower count for.
Returns
Promise<number>A promise that resolves to the number of mutual followers the player has.
Exceptions


A TypeError is thrown if the input is not a valid Player object.
Remarks
Mutual followers are players that both follow and are followed by the given player. This method is not supported on server scripts. Please change script execution mode to local.
isPlayerFollowing(requestor, following) static
Checks if the given player is following the target player in Meta Horizon Worlds.
Signature
static isPlayerFollowing(requestor: Player, following: Player): Promise<boolean>;
Parameters
requestor: PlayerThe player that's the potenial follower of the target player.
following: PlayerThe target player that is potentially being followed.
Returns
Promise<boolean>A promise that resolves to true if the given player is following the tartget player; false otherwise.
Exceptions


Throws a TypeError if the input is not a valid Player object.
Remarks
This method is not supported on server scripts. Please change script execution mode to local.
registerFollowersLoadedEvent(callback) static
Subscribe a callback function to be notified when the local player's followers list is loaded or modified. Note: This callback will not be triggered for a player when a mutual follower unfollows them.
Signature
static registerFollowersLoadedEvent(callback: () => void): number;
Parameters
callback: () => voidThe function to call when the local player's follower list is loaded or modified.
Returns
numberAn ID to use to unregister the callback.
removeFollowersLoadedEvent(eventId) static
Unsubscribe a callback for follower notification using the value returned by registerFollowersLoadedEvent.
Signature
static removeFollowersLoadedEvent(eventId: number): void;
Parameters
eventId: numberThe callback ID returned from registerFollowersLoadedEvent.
Returns
void
showFollowRequestModal(requestor, potentialFollow) static
Shows a follow request modal in the UI of the target player.
Signature
static showFollowRequestModal(requestor: Player, potentialFollow: Player): void;
Parameters
requestor: PlayerThe player making the request.
potentialFollow: PlayerThe player to follow.
Returns
void
Exceptions


A TypeError exception is thrown if the input is not a valid Player object.
Remarks
The modal UI dialog asks the target player if they accept the follow request and prompts them to follow back if they haven't already.
showInvitePlayerList(player) static
Shows the invite to world friends list UI.
Signature
static showInvitePlayerList(player: Player): void;
Parameters
player: PlayerA local player to show the invite to world friends list to.
Returns
void



AvatarImageType Enum
Represents the different types of avatar images that can be used by an image component.
Signature
export declare enum AvatarImageType
Enumeration Members
Member
Value
Description
FULL
0
LowRes - 256x512 pixel image of the player's full avatar.
HighRes - 512x1024 pixel image of the player's full avatar. (Default)
HEADSHOT
1
LowRes - 64x64 pixel image of the player's avatar headshot. Ideal for small UI elements. (e.g. small profile icons)
HighRes - 288x288 pixel image of the player's avatar headshot. (Default) Ideal for large UI elements. (e.g. large profile icons)



FollowStatus Enum
Represents the different types of follow status between two players.
Signature
export declare enum FollowStatus
Enumeration Members
Member
Value
Description
FOLLOWING
2
The player is following the target player
MUTUAL_FOLLOWING
3
The player and the target player are following each other
NOT_FOLLOWING
0
The player is not following the target player
PENDING_FOLLOW
1
The player has sent a follow request to the target player



IAvatarImageOptions Interface
Represents options that can be used when creating an Avatar image component.
Signature
export interface IAvatarImageOptions
Properties
highRes?
(Optional)
Signature
highRes?: boolean;
type
[readonly]
Signature
readonly type: AvatarImageType;



ApiName Variable
The name of the API.
Signature
ApiName = "Social"


GestureEvent Class
Extends LocalEvent<T>
Generic gesture event
Signature
export declare class GestureEvent<T extends TouchEventData> extends LocalEvent<T>
Methods
connectLocalEvent(callback)
Signature
connectLocalEvent(callback: (payload: T) => void): EventSubscription;
Parameters
callback: (payload: T) => void
Returns
EventSubscription

Gestures Class
Detects gestures
Signature
export declare class Gestures
Examples
import { Gestures } from 'horizon/mobile_gestures';


class MyComponent extends Component {
  gestures = new Gestures(this);


  start() {
    const player = this.entity.owner.get();
    player.enterFocusedInteractionMode();


    this.gestures.onTap.connectLocalEvent(({ touches }) => {
      console.log('tap', touches[0].current.screenPosition);
    });
    this.gestures.onLongTap.connectLocalEvent(({ touches }) => {
      console.log('long tap', touches[0].current.screenPosition);
    });
    this.gestures.onSwipe.connectLocalEvent(({ swipeDirection }) => {
      console.log('swipe', swipeDirection);
    });
    this.gestures.onPinch.connectLocalEvent(({ scale, rotate }) => {
      console.log('pinch', scale, rotate);
    });
  }
}
Constructors
(constructor)(component, options)
Creates a Gestures helper

Signature
constructor(component: Component, options?: Partial<GesturesOptions>);
Parameters
component: Componentthe component to attach to, must be owned by the local player
options: Partial<GesturesOptions>(Optional)
Remarks
Requires to start processing events.

Properties
onLongTap
Connect to this event for long tap gestures. See Gestures for example usage.
Signature
onLongTap: GestureEvent<LongTapEventData>;
onPan
Connect to this event for pan gestures. See Gestures for example usage.
Signature
onPan: GestureEvent<PanEventData>;
onPinch
Connect to this event for pinch gestures. See Gestures for example usage.
Signature
onPinch: GestureEvent<PinchEventData>;
onSwipe
Connect to this event for swipe gestures. See Gestures for example usage.
Signature
onSwipe: GestureEvent<SwipeEventData>;
onTap
Connect to this event for tap gestures. See Gestures for example usage.
Signature
onTap: GestureEvent<TapEventData>;

Methods
dispose()
Call this to stop processing events, optional.
Signature
dispose(): void;
Returns
void



GesturesOptions Class
Options for gestures detection
Signature
export declare class GesturesOptions
Properties
longTapTimeThresholdMs
How long a touch must be held to trigger a long tap, in milliseconds
Signature
longTapTimeThresholdMs: number;
swipeTimeThresholdMs
How long a swipe must be held before it is cancelled, in milliseconds
Signature
swipeTimeThresholdMs: number;
tapScreenThreshold
How far a tap must move before it is cancelled or becomes a swipe, in screen space
Signature
tapScreenThreshold: number;
tapTimeThresholdMs
How long a tap must be held before it is cancelled, in milliseconds
Signature
tapTimeThresholdMs: number;

SwipeDirection Enum
For swipe events, which direction did it go
Signature
export declare enum SwipeDirection
Enumeration Members



Member
Value
Description
Down
"down"


Left
"left"


None
"none"


Right
"right"


Up
"up"





LongTapEventData type
Payload received by long tap events
Signature
export declare type LongTapEventData = TouchEventData;
References
TouchEventData
PanEventData type
Payload received by pan events
Signature
export declare type PanEventData = TouchEventData & {
    pan: Vec3;
};
PinchEventData type
Payload received by pinch events
Signature
export declare type PinchEventData = TouchEventData & {
    scale: number;
    rotate: number;
};
SwipeEventData type
Payload received by swipe events
Signature
export declare type SwipeEventData = TouchEventData & {
    swipeDirection: SwipeDirection;
};
TapEventData type
Payload received by tap events
Signature
export declare type TapEventData = TouchEventData;
TouchEventData type
List of touches involved in a gesture
Signature
export declare type TouchEventData = {
    touches: TouchState[];
};
TouchInfo type
Extends an $
Signature
export declare type TouchInfo = InteractionInfo & {
    time: number;
};
TouchPhase type
Which phase is the touch in
Signature
export declare type TouchPhase = 'start' | 'move' | 'end';
TouchState type
State of a touch
Signature
export declare type TouchState = {
    phase: TouchPhase;
    start: TouchInfo;
    previous: TouchInfo;
    current: TouchInfo;
    screenDelta: Vec3;
    screenTraveled: number;
};
ApiName Variable
The name of the API.
Signature
ApiName = "mobile_gestures"


Generative AI Assistant Tool
Important
Join the Meta Horizon Creator Program! As a member, you gain:
Access to monetization opportunities including monthly bonuses, in-world purchases and competition cash prizes.
Helpful resources including educational content, technical support and a collaborative creator community.
Important
The desktop editor is in early access and we need your feedback! To report bugs, go to the main menu and select Report a problem. To give us feedback, select Help us improve from the main menu.
When creating a world in Horizon, using Typescript can be a challenge. The Generative AI Assistant Tool can help you learn Typescript by generating code snippets, and even take actions to help accelerate your world building process. The tool is available in the Horizon Desktop Editor and it is an authoritative, AI-powered chat assistant. The tool works like a chat app and is as simple as having a back-and-forth, real-time conversation with someone. In this case, that someone just happens to be an LLM.
Keep in mind there are daily rate limits for using the Generative AI Assistant Tool. You can check the rates limits in in the following section.
Gen AI Tool Availability & Rates
Horizon desktop editor creation tools with Gen AI are currently only available to users in the United States, Canada, and the United Kingdom (UK) aged 13+. Note that there are daily rate limits per user on content created using Gen AI. Additionally, there are daily rate limits per user on content created using Meta AI. These limits are:
Typescript - 1000 requests
Audio SFX/Ambient - 200 requests
Skybox Generation - 50 requests
Mesh Generation - 100 requests
To access the Generative AI Assistant Tool, select Gen AI from the top menu bar. You can then select the Assistant tool to enable the Horizon Generative AI Assistant.


Use the Generative AI Assistant Tool
The Generative AI Assistant Tool can take action in your world handle basic end-to-end processes during the world building process. You can enable this mode by selecting Code and act as the mode for the assistant.
As an example, by entering the prompt Make a door that opens when a button is pressed, the Generative AI Assistant Tool can take the following actions:
Find assets in the Asset Library and place them in your world
Modify entity properties
Create scripts and connect them to your world
Instruct you on additional steps needed to adjust editor settings
You can also regenerate the content by re-submitting your prompt until you get a satisfactory response.
To use the Generative AI Assistant tool, use the following process:
Select Gen AI from the top menu bar, then select the Assistant and set the mode to Code and act. 
Input a prompt into the prompt window. This can be a natural language prompt thats more conversational like Create a platform that floats when I step on it.
Click Generate and the Gen AI Assistant will begin executing on your task. The Assistant will narrate its actions so you can follow along with its process and check its steps. 
Once the process completes, the Assistant will validate its output and then indicate that the process is complete. Any new assets created will appear in the Hierarchy pane on the left side.
Once the process is complete, you can converse with the Gen AI Assistant to make updates to the created content, or other parts of your world. 
Currently the Gen AI Assistant is only capable of tasks focused on basic interactivity and basic system prompts. It cannot autonomously complete complex workflows and is limited to mechanics that Typescript can interact with. Additionally it cannot interact with any of the additional generators in the Gen AI panel.
The following are examples of use cases that the Gen AI Assistant can do and can help as a framework for interacting with the Gen AI Assistant:
As a builder, I can ask a how do I question and retrieve up to date results from Horizon documentation to answer my question:
How do I interact with Unity Asset Bundles?
How do I create my own custom asset?
How do I work with animations in Horizon?
How do I learn Typescript?
How do I implement a Custom UI system in Horizon?
As a builder, I can ask the AI Assistant to implement basic interactivity / basic systems:
Build a floor tile that activates when stepped on.
Create a lever that can be switched on and off.
Generate coins that players can collect for points.
Design a door that requires a key to open.
Make health packs that heal players when picked up.
Construct a pad that teleports players to another location.
Develop a platform that moves back and forth.
Engineer an elevator that goes up and down.
Build a device that launches players into the air.
Design a spinning obstacle that hurts players.
Create platforms that fall or disappear when stepped on.
Establish an area that makes players run faster.
Construct a floor that damages players like lava.
Generate a gun that shoots projectiles.
Make targets that can be shot at.
Create barrels that explode when hit.
Implement a countdown timer for my game.
Design a door that opens when players get close.
Build a puzzle with pressure plates that need specific weights.
Create a combination lock puzzle.
Generate a box that spawns random items.
Implement a randomizer like rolling dice.
Design a system that spawns objects repeatedly.
Construct a dance floor with music.
Generating TypeScript code snippets
Note: The Generative AI Creation Tool can only generate code using version 2 of the Meta Horizon Worlds Typescript API.
The Generative AI Assistant tool can also generate Typescript snippets for you to attach to objects in your world. For best results when generating Typescript APIs, try to keep your scope limited to one API at a time.
Responses will occasionally contain hallucinations. This usually happens when there are no supported APIs available for the given prompt.
If a response doesnt give the expected result, try reframing your prompt to be more clear and specific.
To generate code snippets using the Gen AI Assistant, use the following process:
Select the Assistant icon and set the Mode to Code Only.
Select either the LLama or Specialist model with the Model dropdown.
Enter a prompt into the prompt window and click Generate.
The Gen AI Assistant will create a sample snippet of Typescript code and provide details on how to use it. Note: Because this feature is code only, you will still have to follow the steps provided to use the generated typescript snippet
If you would like to change topics, you must start a new conversation by clicking the New Chat button. 
Specify whether the result was helpful by clicking either Like (thumbs-up), or Dislike (thumbs-down). Meta uses this information to fine-tune the LLM.
View Generative AI tool history
After using the Generative AI Assistant tool, you can view previous chats by selecting the History icon.


After opening the history window you can select a previous conversation. This will restore the selected conversation including the context used to generate content.
Use world level variables
After setting up world level variables, you can use them in your scripts. Reference the following sample scripts to use world level variables in your scripts:
Import required modules
import * as hz from 'horizon/core';
Get a world level variable
const value = this.world.persistentStorageWorld.getWorldVariable<string>(
 "VG:WPVar"
);
console.log("World Variable Value: " + value);
Fetch a world variable
await this.world.persistentStorageWorld.fetchWorldVariableAsync(
 "VG:WPVar"
).then((value) => {
 console.log("World Variable Value: " + value);
});
Set a world variable
await this.world.persistentStorageWorld.setWorldVariableAcrossAllInstancesAsync(
 "VG:WPVar",
 { "key": "value" }
).then((value) => {
 console.log("World Variable Set: " + value);
});
Set world-level counters
After creating a world level variable of type number, you can use it to set world-level counters. The counter APIs can be used to bump certain logic in the game such as make_wish or catch_butteryfly etc.
Reference the following sample scripts to use world level counters in your scripts:
Get world counter
const value = this.world.persistentStorageWorld.getWorldCounter<string>(
 "VG:WPVar"
);
console.log("World Variable Value: " + value);
Increment a world counter
await this.world.persistentStorageWorld.incrementWorldCounter(
 "VG:WPVar",
 10
).then((value) => {
 console.log("World Counter: " + value);
});
AI Speech NPCs Overview
This guide will walk you through the process of creating an AI speech NPC. AI speech NPCs are AI-powered characters that can interact with players in a variety of ways. They are designed to be engaging, responsive, and unpredictable, making them a great addition to any game or application. In this guide, well cover the basics of creating a generative NPC, including how to set up the NPCs background and implement it into your created world. First lets go over the types of NPCs.
Types of NPCs
There are three categories of NPCs, each with its own distinct functionality:
Stock NPC Assets
Stock NPCs can be found in the asset library under the interactive section. These NPCs are high fidelity and have expressive animations that can be controlled through scripts. However, they do not have AI Speech capabilities. Check the NPC Examples world under the Tutorial Worlds section of Creation Home to see examples of stock NPCs in action.
NPC Gizmo: Horizon Avatar (Body Only)
The NPC Gizmo can be configured so it displays like a Horizon avatar. This avatar can be customized and scripts can be added to add behaviors like jumping and navigating around a world. Creators can also play pre-recorded audio clips along with these NPCs. You can learn more in the Scripted Avatar NPC tutorial world.
NPC Gizmo: AI Speech (Voice Only)
The NPC Gizmo can be configured so it can speak as an AI character. This AI Speech can be configured in Character Builder, and is accessible from the Edit Character button. Currently, NPCs configured configured for AI Speech need scripts to trigger speech.
Prerequisites
To create an AI speech NPC youll need to have created a world in the Horizon Desktop Editor.
Set up an AI Speech NPC
To create and configure an NPC, use the following process:
In your world, open the Gizmos menu and drag in a NPC gizmo. You can use the search field if the gizmo is not currently visible.
Once the NPC has been added to your world, select it to open the NPC properties panel.
In the properties panel, you can configure various settings for your NPC. To make your created NPC an AI speech NPC set the NPC Type to AI Speech (Voice Only). 
After setting the NPC Type property to AI Speech (Voice Only), you can select the Edit Character button to open the Character Builder window.
In the character builder window, you can give your NPC a name. Then click Create. 
Once your character is named, you can give your character a backstory. For more information about adding a backstory to your character, check the Backstory section.
After establishing the characters backstory, select the Voice and Speech tab. Try testing some of the preset voices, once you find a voice you like for your character, select it and press Save.
Currently, scripting is required for your created NPC to speak. In your NPCs select Attach script then, Create new script and name your script.
Once your script is named, click Create and attach to attach it to your NPC. Once attached, you can select the script in your NPCs property panel, click the three dots, then select Edit script. 
Your newly created script will open in your linked code editor. This new scripts default behavior will be speaking when the world initially starts. elicitResponse() takes an instruction for the NPC to respond to. You can find more examples of script NPCs in the NPC section of the asset library and in the sample script below.
Next, select Build > Gizmo and drag out a Trigger Zone gizmo. Reposition and scale the gizmo so that it encompasses the NPCs spawn point. This will ensure the OnPlayerEnterTrigger event is dispatched any time your player spawns in the world.
Select your NPC in the hierarchy. Go to the script property panel and point the Trigger property at the Trigger Zone gizmo.
Click the Play button to enter preview mode. You should hear your NPC speak shortly after spawning in the world.
Sample NPC Script
The following is a sample script that configures an AI Speech NPC to introduce itself when a player enters the trigger.
import { CodeBlockEvents, Component, Player, PropTypes, TriggerGizmo } from 'horizon/core';
import { Npc } from 'horizon/npc';




class NPCScript extends Component<typeof NPCScript>{
  static propsDefinition = {
    trigger: { type: PropTypes.Entity },
  };




  start() {
    // Configures the NPC to introduce itself when a player enters the trigger.
    // For more details and examples go to:
    // https://developers.meta.com/horizon-worlds/learn/documentation/desktop-editor/npcs/ai-speech-npcs/ai-speech-npcs-overview
    if (this.props.trigger!) {
      const trigger = this.props.trigger!.as(TriggerGizmo);
      const npc = this.entity.as(Npc);
      if (npc.isConversationEnabled()) {
        this.connectCodeBlockEvent(trigger, CodeBlockEvents.OnPlayerEnterTrigger, (player: Player) => {
          npc.conversation!.elicitResponse('Introduce yourself to player');
        });
      } else {
        console.error('NPC does not have conversation enabled. Please enable conversation in the NPC Gizmo.');
      }
    } else {
      console.error('Trigger property is not set. Please specify the trigger zone you want to trigger the NPC.');
    }
  }
}
Component.register(NPCScript);
The following sections will cover the various settings you can configure and how they impact the performance of your AI speech NPC.
Backstory
The NPCs backstory should be a condensed version of the character that includes core personality traits. It shapes your characters conversation with players and contains its key personality traits. The NPCs backstory is included in its entirety in the prompt for the AI Speech NPC, so its recommended that you keep it simple. Too much detail in the backstory has been shown to water down the characters performance rather than reinforce it, after a certain threshold.
The following is an example of an effective backstory prompt:
Denu is a small, shy Brown-banded Snail with a big heart and a strong sense of self. Despite being timid, Denu is fiercely loyal and determined to make the world a better place. With a passion for kindness, empathy, and environmental protection, Denu embarks on a journey to explore new places and help those in need.
Key Traits -Compassionate: Always willing to lend a listening ear or a helping foot to those in need. -Brave and Determined: Never backing down from a challenge, despite being shy and vulnerable. -Persevering: Possessing unique abilities such as perseverance, patience, and strength, allowing Denu to overcome obstacles and achieve goals. -Environmentally Conscious: Deeply committed to protecting the environment and preserving the beauty of nature.
Voice and Speech
Voice is how your NPC sounds when speaking. There is a collection of preset voices that you can choose from when creating your NPC. You can hear a sample by clicking the speaker icon. You can hear specific lines of text by typing them into Voice Testing and clicking the play icon. You can use the Speed and Pitch sliders to fine tune your NPCs voice.


Conversation
The conversation panel allows you to test responses and emotional indicators from your created NPC. You can type a message into the Message field and click send to see how the character would respond.
When testing conversation responses, its important to note that the character has memory - past messages and responses sent to the NPC will influence what the character says. If youd like to erase the message history click the Reset Session button.


Events
There are several events that you can take advantage of with your NPC. These events give you the opportunity to give some partial embodiment to your NPC. All NPC events are accessible through the NpcEvents object that can be subscribed to with NetworkEvent.
OnNpcEngagementChanged - Triggered when an NPC goes through phases of a conversation. This provides the following engagement states:
Idle - The NPC is idle and can start a conversation anytime. No user is engaged yet. New instructions can be processed by the NPC.
Listening - The NPC is listening to the user. Listening to the user isnt currently supported.
Reacting - The NPC is processing input and formulating a response based on instructions from NpcConversation.elicitResponse() method.
Yielding - The NPC finished speaking and is waiting for further instructions. The {@linkNpcAttentionTarget} is still engaged. The NPC can process new instructions.
Focused Idle - The NPC is idle and can process new instructions. The {@linkNpcAttentionTarget} is still engaged with the NPC.
OnNpcVisemeChanged - Provides the mouth shapes that should be shown while the NPC is speaking. This is great for custom facial animations. You can learn more about Visemes in the Viseme Reference
OnEmoteStart - Triggered when an NPC wants to show an emotion or trigger a quick emote.
OnEmoteStop - Triggered when an emotion or animation state ends.
OnNpcError - Triggered when the NPC experiences an error during a conversation
Connecting Events
The following is a sample of connecting events together for your created NPC:
// Handles grabbing and releasing an item as well as adding the item to Npc's contextual awareness
class NpcEventExample extends Component<typeof NpcGrabbableItem> {
  static propsDefinition = {
    itemName: { type: PropTypes.String },
    npc: { type: PropTypes.Entity },
  };


  // Stored data
  private npc!: Npc; // TODO: Make Multiple
  private contextKey: string = "";
  public isHolding: boolean = false;
  public itemName: string = "";


  start() {
    // Cache Props
    this.grabbable = this.entity.as(GrabbableEntity);
    this.npc = this.props.npc!.as(Npc);


    this.connectNetworkEvent(this.npc, NpcEvents.OnNpcStartedSpeaking, () => {
      console.log("OnNpcStartedSpeaking");
    });
    this.connectNetworkEvent(this.npc, NpcEvents.OnNpcStoppedSpeaking, () => {
      console.log("OnNpcStoppedSpeaking");
    });
  }
}
Component.register(NpcEventExample );
Shop Asset Template


Note
You will need to be a member of MHCP and have accepted the monetization Terms Of Service in the creator portal in order to create in-world items and currency. Find out more about monetization here.
The Shop Asset Template allows users to trade Meta credits and in-world items for other in-world items.
The Shop Asset Template can be configured to display in-world items created in the Systems > Commerce menu. For more information on creating in-world items, visit the In-World Purchase Guide.
Behind the scenes, the world inventory stores how many of each in-world item is owned by each player. While the shop interfaces with the world inventory automatically, you can use World Inventory TypeScript APIs to manually query, grant, and consume in-world items in a players world inventory.
Access the Shop Asset Template
To access the Shop Asset Template: In the desktop editor, enter the Build mode and select Asset Library > Public Assets from the bottom menu bar. Next, search for Shop in the search field. Finally, select the Shop Asset Template and drag it into the scene. You can now edit the new asset template properties in the Properties panel.


Shop Asset Template properties
The Shop Asset Template properties can be configured in the Properties panel or through scripting.
Visual and interaction
Here you can change the following:
Id: Id of the Shop. Used to differentiate between multiple shops in the same world.
Displayed Title: Name of the shop, which is displayed in the top-left corner of the shop UI.
Displayed Title Icon: Select an icon to display next to the shop title.
Soft Currency SKU: The SKU of the soft currency used to purchase items from this shop. This is used to display the amount of soft currency a player has available to purchase items from this shop.
Soft Currency Thumbnail: The thumbnail of the soft currency used to purchase items from this shop. This is used to display the amount of soft currency a player has available to purchase items from this shop.
Item SKU: The SKU of an item you want to sell in this shop.
Item Thumbnail: The thumbnail of an item you want to sell in this shop.
Item Cost SKU: The SKU of the currency used to purchase this item. Leave it blank if you want to sell this item with Meta credits.
Item Cost Quantity: The quantity of the currency used to purchase this item. Leave it blank if you want to sell this item with Meta credits.
Shop items
To use the Shop Asset Template, you will need to create in-world items through the Systems > Commerce menu. Once you have done this, you can add these items to the shop using the Shop Asset Template properties.
You can use the Shop Asset Template properties to configure which in-world items to display, and the cost of items in terms of other items. These are then available for players to swap, and will check the quantity of the item the player has before enabling them to purchase the item.
For example, lets say a world features two in-world items, Apple Pies and Gems, which have been configured. It is possible to enable your player to swap 10 Apple Pies for 1 Gem with the following settings:
Item 1: Gem
Quantity: 1
Cost SKU: Apple Pie
Cost Quantity: 10
Scripting
You can interface with the Shop Asset Template directly through TypeScript and fully customize the shops behavior. Please refer to the World Inventory TypeScript APIs documentation for more information on the economy APIs.
Asset pool gizmo
The asset pool gizmo is a powerful tool for managing objects that should be granted to each player in your World. It automates spawning and assignment of asset template objects to players as they join your World. This is necessary for objects that should have different states per player.
This gizmo is perfect for creating the following in game objects or features on a per player basis:
HUD and UI
Starting items
Particle Effects
Stats
When using something like a HUD asset, the asset pool gizmo to assign a HUD to each player in your world without needing to create a new HUD per player. Implementing the asset pool gizmo allows you to focus on designing gameplay experiences without writing custom code to manage player-specific objects.
Asset pool gizmo overview


Each asset pool gizmo manages a single asset template and pools it to be copied as child objects for players.
You can add additional asset pool gizmos to use additional asset templates for as necessary.
The asset pool gizmo is able to be used within asset templates.
When an asset template is assigned to the gizmo, it will automatically create the pool of prefabs based on the maximum player count setting.


Note: When deploying the asset pool gizmo in a non-FBS world, avoid connecting asset templates that contain scripts. When the asset pool gizmo spawns the asset template, the scripts will be spawned as separate instances that must be maintained.
Use the asset pool gizmo
To get started using the asset pool gizmo you will first need to have an asset template available that you plan to use on a player-specific basis. This can be an asset template you created or one that was shared with you by another creator.
Access the asset pool gizmo via Build Menu > Gizmos > Asset Pool.


Once the asset pool gizmo is added, you can set whether to Auto Assign to Players and set the Asset Reference for the gizmo.


Once the asset pool gizmo is added to your world, use the following process to manage it:
Navigate to Player Settings in the top left menu and adjust the Maximum Player Count slider for your worlds expected max player count.


Drag the Asset Pool gizmo into your scene.
Locate the Asset Template you plan to use in your Asset Library.
Drag and drop the Asset Template into the Asset Reference field of the Asset Pool gizmo.


Use the drop down menu in the Asset Reference field of the Asset Pool gizmos properties window to search for your asset.
The Asset Pool gizmo will automatically create child prefabs equal to the Maximum Player Count setting.
If auto-assign is enabled in the properties window, players entering the world will receive a prefab from the asset pool.
Example scripts and assets
Example #1: UpdateOwnerName.ts This script can be attached to a mesh object with a child Text gizmo. When an owner is assigned to the object, the text gizmo will update with that players name.


// Import the necessary components from the 'horizon/core' module.
import * as hz from 'horizon/core';


// This class will control the behavior of updating the owner's name.
class UpdateOwnerName extends hz.Component<typeof UpdateOwnerName> {


  // Defines the properties, `ownerNameTextEntity` will be set to an Entity.
  static propsDefinition = {
    ownerNameTextEntity: {type: hz.PropTypes.Entity}
  };


  start() {


    // Retrieve the owner of the current entity (the entity this component is attached to).
    let owner = this.entity.owner.get();


    // Get a `TextGizmo` which displays text, associate it with the `ownerNameTextEntity` property.
    let ownerGizmo = this.props.ownerNameTextEntity?.as(hz.TextGizmo);


    // Clear the text in the `TextGizmo`
    ownerGizmo?.text.set("");


    // Check if the current owner is set to a current player or the server.
    if (owner === this.world.getServerPlayer()) {
      // If the owner is the server, clear the text, this occurs if no player owns the object or an owning player drops the object and leaves the session.
      ownerGizmo?.text.set("");
    }
    else {
      // If the owner is not the server, set the text to the owner's name.
      ownerGizmo!.text.set(owner.name.get());
    }


  }
}


// Register the `UpdateOwnerName` component with the Horizon engine.
hz.Component.register(UpdateOwnerName);
Example #2: UI_ShopHud.ts This script can be attached to a custom UI gizmo, and when pooled will display a HUD element with a clickable button and the owning players name. This also sends some logs to Console when ownership is assigned.


// Import necessary components from the Horizon core and UI libraries
import { CodeBlockEvents, Component, Player, World } from 'horizon/core';
import { Binding, Pressable, Text, UIComponent, UINode, View, ViewStyle } from 'horizon/ui';


// Define the class `UI_ShopHud`, which extends `UIComponent` for custom UI in Horizon Worlds
class UI_ShopHud extends UIComponent<typeof UI_ShopHud> {


  // Define props definition
  static propsDefinition = {};


  // Define bindings for UI elements (to make them reactive)
  private titleText!: Binding<string>;  // Title text binding (e.g., shop name)
  private shopText!: Binding<string>;   // Text for the shop label
  private shopTextColor!: Binding<string>; // Binding for the shop text color
  private buttonColor!: Binding<string>; // Binding for the button color


  // Configurations for UI layout and styles
  private readonly featuredTextSize = 36; // Fixed size for featured text
  private debounce: boolean = false; // Flag to prevent multiple button clicks in a short period


  // The `start` method is called when the component is initialized
  start() {
    // Retrieve the server player and local player
    let serverPlayer = World.prototype.getServerPlayer();
    let owner = this.world.getLocalPlayer();


    // Check if the current player is neither the server player nor null
    let currentPlayer = owner === null || owner === serverPlayer ? null : owner;


    // If there is a valid current player, make the shop UI visible
    if (currentPlayer !== null) {
      console.log(`UI_ShopHud CONNECTED to ${currentPlayer.name.get()}`);
      this.entity.visible.set(true);  // Set the UI entity to visible
    }
    else {
      // Otherwise, hide the shop UI
      this.entity.visible.set(false);
    }
  }


  // Method to handle when a slot (button) is clicked
  private onSlotClicked() {
    // Prevent multiple clicks within a short time frame using debounce
    if (!this.debounce) {
      this.debounce = true;  // Set debounce flag to true (no further clicks allowed)


      // Change the button color to grey when pressed
      this.buttonColor.set('grey', [this.world.getLocalPlayer()]);


      console.log("Shop Button Pressed");


      // After a short delay, reset the debounce flag and set the button color back to green
      this.async.setTimeout(() => {
        this.debounce = false;  // Reset debounce flag
        this.buttonColor.set('green', [this.world.getLocalPlayer()]);  // Reset button color
      }, 200); // 200 milliseconds delay
    }
  }


  ////////////////////////////////////////////////////////////////////////
  // UI Formatting Section: This part handles the layout and design of the UI
  ////////////////////////////////////////////////////////////////////////


  // Method to initialize and layout the UI components
  initializeUI() {
    // Skip UI creation if the local player is the server player (since they should not see the UI)
    if (this.world.getLocalPlayer() === this.world.getServerPlayer()) {
      return new UINode();  // Return an empty node if server player
    }


    // Set up bindings for dynamic UI content (e.g., player name, shop name)
    this.titleText = new Binding<string>(this.world.getLocalPlayer().name.get());
    this.shopText = new Binding<string>('Shop');  // Static text for "Shop"
    this.shopTextColor = new Binding<string>('white'); // Default text color for shop text
    this.buttonColor = new Binding<string>('green'); // Default color for the button


    // Define the style for the root panel (container) of the UI
    const rootPanelStyle: ViewStyle = {
      width: "60%",  // Width of the root panel (60% of the screen width)
      height: "80%", // Height of the root panel (80% of the screen height)
      left: "35%",   // Position the panel 35% from the left edge of the screen
      position: "absolute", // Use absolute positioning
      justifyContent: "center", // Vertically center the content inside the panel
      alignContent: "center",
      alignSelf: "center",
      alignItems: "flex-end", // Align content to the bottom (flex-end) horizontally
    };


    // Define the style for the button
    const buttonStyle: ViewStyle = {
      backgroundColor: this.buttonColor,  // Dynamic button color
      borderRadius: 8,  // Rounded corners for the button
      height: 48,       // Button height
      padding: '5%',    // Padding inside the button
      margin: '5%',     // Margin around the button
      width: '80%',     // Button takes up 80% of the panel's width
      justifyContent: 'center',  // Center the button text vertically
      alignContent: "center",
      alignItems: 'center',      // Center the button text horizontally
    };


    // Create a pressable button element with custom styling and text
    const buttonOption = Pressable({
      children: [
        View({
          children: [
            Text({
              text: this.shopText, // Text content for the button (shop name)
              style: {
                fontFamily: "Roboto",   // Font for the button text
                color: this.shopTextColor, // Dynamic text color for the shop name
                fontWeight: "700",      // Bold text
                fontSize: this.featuredTextSize, // Featured text size
                alignItems: "center",   // Center the text vertically
                textAlign: "center",    // Center the text horizontally
              }
            }),
          ],
          style: {
            flexDirection: "row",  // Arrange children in a row
            justifyContent: "center",  // Horizontally center the text
          },
        })
      ],
      style: buttonStyle,  // Apply the defined button style
      onClick: () => this.onSlotClicked(),  // Handle button click event
    });


    // Define and return the root view that contains all UI components
    return View({
      children: [
        // The button container (including title and button)
        View({
          children: [
            Text({
              text: this.titleText, // Display the title text (player's name)
              style: {
                fontFamily: "Roboto", // Font style for the title text
                color: this.shopTextColor, // Dynamic color for the title text
                fontWeight: "700",    // Bold text for the title
                fontSize: this.featuredTextSize, // Set the size of the title text
                alignItems: "center", // Center the title text vertically
                textAlign: "center",  // Center the title text horizontally
              }
            }),
            buttonOption, // Add the button as a child of the root view
          ],
        })
      ],
      style: rootPanelStyle, // Apply the root panel's styles
    });
  }
}


// Register the `UI_ShopHud` component so it can be used in Horizon Worlds
Component.register(UI_ShopHud);
Inventory Asset Template
Note
You will need to be a member of MHCP and have accepted the monetization Terms Of Service in the creator portal in order to create in-world items and currency. Find out more about monetization here.
The Inventory Asset Template allows creators to easily list the items a player owns or can own within a world. The items displayed and their configuration can be set up using the props element of the included Inventory script. An arbitrary number of items can be listed here, and if the content is larger than the screen therell be a scroll bar for the player to navigate through it.
The Inventory Asset Template can be configured to display in-world items created in the Systems > Commerce menu. For more information on creating in-world items, visit the In-World Purchase Guide.
Behind the scenes, the world inventory stores how many of each in-world item is owned by each player. While the Inventory Asset Template interfaces with the world inventory automatically, you can use World Inventory TypeScript APIs to manually query, grant, and consume in-world items in a players world inventory.
Access the Inventory Asset Template
To access the Inventory Asset Template: In the desktop editor, enter the Build mode and select Asset Library > Public Assets from the bottom menu bar. Next, search for Inventory in the search field. Finally, select the Inventory Asset Template and drag it into the scene. You can now edit the new asset template properties in the Properties panel.


Inventory Asset Template properties
The Inventory Asset Template properties can be configured in the Properties panel or through scripting.
Visual and interaction
Here you can change the following:
ID: ID of the Inventory. Used to differentiate between multiple inventories in the same world.
Displayed Title: Name of the Inventory, which is displayed in the top-left corner of the Inventory UI.
Displayed Title Icon: Select an icon to display next to the Inventory title.
Item SKU: The SKU of an item you want to display in this Inventory.
Item Thumbnail: The thumbnail of an item you want to display in this Inventory.
Inventory items
To use the Inventory Asset Template, you will need to create in-world items through the Systems > Commerce menu. Once you have done this, you can add these items to the Inventory using the Inventory Asset Template properties.
You can use the Inventory Asset Template properties to configure which in-world items to display.
Scripting
You can interface with the Inventory Asset Template directly through TypeScript and fully customize the Inventorys behavior. Please refer to the World Inventory TypeScript APIs documentation for more information on the economy APIs.
Daily Rewards Asset Template
Note
You will need to be a member of MHCP and have accepted the monetization Terms Of Service in the creator portal in order to create in-world items and currency. Find out more about monetization here.
The Daily Rewards Asset Template allows users to be granted rewards for each day they log in to your world helping improve retention and engagement.
The Daily Rewards Asset Template can be configured to grant in-world items created in the Systems > Commerce menu. For more information on creating in-world items, visit the In-World Purchase Guide.
Behind the scenes, the world inventory stores how many of each in-world item is owned by each player. While the Daily Rewards Asset Template interfaces with the world inventory automatically, you can use World Inventory TypeScript APIs to manually query, grant, and consume in-world items in a players world inventory.
Access the Daily Rewards Asset Template
To access the Daily Rewards Asset Template: In the desktop editor, enter the Build mode and select Asset Library > Public Assets from the bottom menu bar. Next, search for Daily Rewards in the search field. Finally, select the Daily Rewards Asset Template and drag it into the scene. You can now edit the new asset template properties in the Properties panel.


Daily Rewards Asset Template properties
The Daily Rewards Asset Template properties can be configured in the Properties panel or through scripting.
Note
In order to save the state of the daily rewards for each player, you will need to create a new Persistent Variable of type Object and assign its key under the Daily Rewards Asset Template properties. Find out how to create and use Persistent Variables here.
Visual and interaction
Here you can change the following:
Id: ID of the daily rewards. Used to differentiate between multiple daily rewards in the same world.
Displayed Title: Tile displayed in the top-left corner of the daily rewards UI.
Displayed Title Icon: Select an icon to display next to the daily rewards title.
Persistent Object Variable: Id of the Persistent Variable of type Object used to store the event state. See the note above for details on how to create it.
Daily Rewards Activation: Whether the daily rewards system is active (default true). Set this to false when you prefer to enable it via the TypeScript API.
Auto Repeat: Indicates if the daily rewards automatically restarts after the player has collected all rewards available (default true).
Show Timer: Whether the timer with the remaining time for the next reward to be available should be shown (default true).
Reset Streak If Day Is Missed: Whether missing a day resets the players streak (default false).
Day X Reward SKU: The SKU of an item you want to award the player for logging in on day X.
Day X Reward Quantity: The quantity of the chosen award item to be granted.
Day X Reward Thumbnail: The thumbnail of the chosen award item to be granted.
Daily Rewards items
To use the Daily Rewards Asset Template, you will need to create in-world items through the Systems > Commerce menu. Once you have done this, you can add these items to the awards list using the Daily Rewards Asset Template properties.
You can use the Daily Rewards Asset Template properties to configure which in-world items to grant on each day and their respective quantities.
Scripting
You can interface with the Daily Rewards Asset Template directly through TypeScript and fully customize the features behavior. Please refer to the World Inventory TypeScript APIs documentation for more information on the economy APIs.


