import * as hz from 'horizon/core';
import { AreaSlotSaveStruc, assignPlayer, loadSlotData, reset, levelUpSlot, unlockSlot } from 'PlayerManager';
import { AreaSlotDataStruct, registerSlotData } from 'GameData';

export const assignPlayerSlot = new hz.NetworkEvent<{areaId: number, player: hz.Player}>('assignPlayerSlot');
export const loadPlayerSlotData = new hz.NetworkEvent<{slotSaveData: AreaSlotSaveStruc}>('loadPlayerSlotData');
export const fillSlotGameData = new hz.NetworkEvent<{slotDataEntry: AreaSlotDataStruct}>('fillSlotGameData');
export const resetSlot = new hz.NetworkEvent<{}>('resetSlot');
export const setSlotLevel = new hz.NetworkEvent<{level: number}>('setSlotLevel');

class AreaManager extends hz.Component<typeof AreaManager> {
  static propsDefinition = {
    playerManager: {type: hz.PropTypes.Entity},
    spawnPoint: {type: hz.PropTypes.Entity},
    
    slotManager1: {type: hz.PropTypes.Entity},
    slotManager2: {type: hz.PropTypes.Entity},
    slotManager3: {type: hz.PropTypes.Entity},
    slotManager4: {type: hz.PropTypes.Entity},
    slotManager5: {type: hz.PropTypes.Entity},
    slotManager6: {type: hz.PropTypes.Entity},
    slotManager7: {type: hz.PropTypes.Entity},
    slotManager8: {type: hz.PropTypes.Entity},
    slotManager9: {type: hz.PropTypes.Entity},
    slotManager10: {type: hz.PropTypes.Entity},
    slotManager11: {type: hz.PropTypes.Entity},
    slotManager12: {type: hz.PropTypes.Entity},
    slotManager13: {type: hz.PropTypes.Entity},
    slotManager14: {type: hz.PropTypes.Entity},
    slotManager15: {type: hz.PropTypes.Entity},

  };
  private slots: SlotRef[] = [];
  private assignedPlayer: hz.Player | undefined;
  private areaId: number | undefined;


  preStart() {
    // setting up the slots ready to be assigned
    const slotManagers = [
      this.props.slotManager1,
      this.props.slotManager2,
      this.props.slotManager3,
      this.props.slotManager4,
      this.props.slotManager5,
      this.props.slotManager6,
      this.props.slotManager7,
      this.props.slotManager8,
      this.props.slotManager9,
      this.props.slotManager10,
      this.props.slotManager11,
      this.props.slotManager12,
    ];    
    let i = 1;
    slotManagers.forEach(slot => {
      if (slot !== undefined) {
        const newSlot: SlotRef = {
          slotId: i,
          entity: slot,
          slotData: undefined,
        }
        this.slots.push(newSlot);
        i += 1;
      }});
    //console.log(`AreaManager${this.props.areaId}: Slots setup complete, there are ${this.slots.length} slots`);
    
    this.connectNetworkEvent(
      this.entity,
      assignPlayer,
      (data: {areaId: number, player: hz.Player}) => {
        this.onAssignPlayer(data.areaId, data.player);
    });
    this.connectNetworkEvent(
      this.entity,
      loadSlotData,
      (data: {slotsSaveData: AreaSlotSaveStruc[]}) => {
        this.onLoadSlots(data.slotsSaveData);
    });
    this.connectNetworkEvent(
      this.entity,
      reset,
      () => {
        this.onReset();
    });
    this.connectNetworkBroadcastEvent(
      registerSlotData,
      (data: {slotGameData: AreaSlotDataStruct[]}) => {
        //console.log(`AreaManager${this.areaId}:registerSlotData: Register slot game data`);
        this.registerSlots(data.slotGameData);
    });
    this.connectNetworkEvent(
      this.entity,
      levelUpSlot,
      (data: {slotId: number, level: number}) => {
        console.log(`AreaManager${this.areaId}:levelUpSlot: Set slot ${data.slotId} to level ${data.level}`);
        this.slotSetLevel(data.slotId, data.level);
    });
    this.connectNetworkBroadcastEvent(
      unlockSlot,
      (data: {slotId: number}) => {
        if (data !== undefined) {
          console.log(`AreaManager${this.areaId}:unlockSlot: Unlock slot ${data.slotId}`);
          this.slotSetLevel(data.slotId, 0);
        };
    });
  };

  start() {

  };

  private onAssignPlayer(areaId: number, player: hz.Player): void {
    //console.log(`AreaManager${this.props.areaId}:onAssignPlayer: Assigning player ${player.name.get()}`);
    this.assignedPlayer = player;
    this.areaId = areaId;

    this.slots.forEach(slotEntry => {
      this.sendNetworkEvent(slotEntry.entity,assignPlayerSlot,{areaId, player}); // send assign player to each slot
    });

    // spawn player
    if (this.props.spawnPoint) {
      this.props.spawnPoint.as(hz.SpawnPointGizmo).teleportPlayer(player);
    } else {
      console.log(`AreaManager${this.areaId}:onAssignPlayer: Cannot find spawnpoint!`);
    };
  };

  private onReset(): void {
    console.log(`AreaManager${this.areaId}:onReset: Resetting area`);
    this.assignedPlayer = undefined;
    
    this.slots.forEach(slotEntry => {
      this.sendNetworkEvent(
        slotEntry.entity,
        resetSlot,
        {}
      )
    });

  };

  private registerSlots(slotDataArray: AreaSlotDataStruct[]): void {
    //console.log(`AreaManager${this.areaId}:registerSlots: Filling ${slotDataArray.length} slot game data into ${this.slots.length} slots`);
    this.slots.forEach(slotEntry => {
      const slotDataEntry = slotDataArray.find(data => data.slotId === slotEntry.slotId);
      if (slotDataEntry) {
        //console.log(`AreaManager${this.areaId}:registerSlots: Sending data to slot ${slotEntry.slotId}, ${slotEntry.entity.name.get()}`);
        this.sendNetworkEvent(slotEntry.entity, fillSlotGameData,{slotDataEntry: slotDataEntry});
        slotEntry.slotData = slotDataEntry;
      }
    });
  };

  private onLoadSlots(slotSaveData: AreaSlotSaveStruc[]) {
    //console.log(`AreaManager${this.areaId}:onLoadSlots: Loading ${slotSaveData.length} slot save data into ${this.slots.length} slots`);
    this.slots.forEach(slotEntry => {
      const slotSaveDataEntry = slotSaveData.find(data => data.areaSlotId === slotEntry.slotId);

      if (slotSaveDataEntry) {
        // load the slot data and unlock the slots that need it
        const slotLevel = this.getSlotLevel(slotSaveDataEntry,slotEntry);
        //console.log(`AreaManager${this.areaId}:onLoadSlots: Set slot ${slotEntry.slotId} to level ${slotLevel}`);
        this.slotSetLevel(slotEntry.slotId,slotLevel);
        this.slots.forEach(otherSlotEntry => {
          const otherSlotSaveData = slotSaveData.find(data => data.areaSlotId === otherSlotEntry.slotId);
          const otherSlotUnlockedBySlot = otherSlotEntry.slotData?.unlockedBySlotArray[0];
          const otherSlotUnlockedByLevel = otherSlotEntry.slotData?.unlockedBySlotArray[1];
          if (!otherSlotSaveData && otherSlotUnlockedBySlot && otherSlotUnlockedByLevel) {
            if (otherSlotUnlockedBySlot == slotEntry.slotId && otherSlotUnlockedByLevel >= slotLevel) {
              this.slotSetLevel(otherSlotEntry.slotId,0);
            };
          };
        });
      } else if (slotEntry.slotData?.startsUnlocked) {
        // check if the slot starts unlocked
        this.slotSetLevel(slotEntry.slotId,0);
      };

    });

  };

  private slotSetLevel(slotId: number, level: number) {
    console.log(`AreaManager${this.areaId}:slotSetLevel: Setting slot ${slotId} to level ${level}`);
    const targetSlot = this.slots.find(data => data.slotId === slotId);
    if (targetSlot) {
      this.sendNetworkEvent(targetSlot.entity, setSlotLevel, {level: level});
    };
  };

  private getSlotLevel(slotPlayerData: AreaSlotSaveStruc, slotEntry: SlotRef): number {
    let slotCurrentLevel = 0;
    let slotRequiredUpgrades = 0;
    if (slotEntry.slotData) {
      slotCurrentLevel += 1;
      slotEntry.slotData.upgradesPerLevelArray.forEach(slotLevelRequirement => {
        slotRequiredUpgrades += slotLevelRequirement;
        if (slotRequiredUpgrades <= slotPlayerData.numberOfUpgrades) {
          slotCurrentLevel += 1;
        }
      });
    };
    return slotCurrentLevel;
  };

};

type SlotRef = {
  slotId: number;
  entity: hz.Entity;
  slotData: AreaSlotDataStruct | undefined;
};

hz.Component.register(AreaManager);
import * as hz from 'horizon/core';

export const registerSlotData = new hz.NetworkEvent<{slotGameData: AreaSlotDataStruct[]}>('registerSlotData');
export const registerResourceData = new hz.NetworkEvent<{resourceGameData: ResourceDataStruc[]}>('registerResourceData');
export const registerStatisticsData = new hz.NetworkEvent<{statisiticsGameData: StatisticsDataStruc[]}>('registerStatisticsData');
export const registerTriviaData = new hz.NetworkEvent<{triviaGameData: TriviaDataStruc[]}>('registerTriviaData');
export const registerTutorialData = new hz.NetworkEvent<{tutorialGameData: TutorialDataStruc[]}>('registerTutorialData');
export const registerNotificationData = new hz.NetworkEvent<{notificationGameData: NotificationDataStruc[]}>('registerNotificationData');

class GameData extends hz.Component<typeof GameData> {
  static propsDefinition = {
  };

  private slotDataJSON: AreaSlotDataStruct[] = 
  // ############################                START SLOT DATA                ################################# 
  [

    {
      slotId: 1,
      name: "Logging Camp",
      startsUnlocked: true,
      unlockedBySlotArray: [0,0],
      startsPurchased: false,
      hasWorkers: true,
      upgradesPerLevelArray: [10, 30],
      levelCostResourcesArray: [{requiredLevel: 0, disabledAtLevel: 0,resourceId:1,baseValue:150,multiplierPerUpgrade: 0 ,multiplierPerLevel: 3}, {requiredLevel:1,disabledAtLevel:0,resourceId:6,baseValue:20,multiplierPerUpgrade:0,multiplierPerLevel:5}, {requiredLevel:2,disabledAtLevel:0,resourceId:5,baseValue:20,multiplierPerUpgrade:0,multiplierPerLevel:5}],
      upgradeCostResourcesArray: [{requiredLevel: 1, disabledAtLevel: 0,resourceId:1,baseValue:10,multiplierPerUpgrade: 1,multiplierPerLevel: 10}],
      producedResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:2,baseValue:5,multiplierPerUpgrade:0.1,multiplierPerLevel:0.25}],
      upkeepResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:1,multiplierPerUpgrade:0.1,multiplierPerLevel:10},{requiredLevel:2,disabledAtLevel:2,resourceId:4,baseValue:4,multiplierPerUpgrade:0.1,multiplierPerLevel:0},{requiredLevel:3,disabledAtLevel:0,resourceId:5,baseValue:0.5,multiplierPerUpgrade:0.05,multiplierPerLevel:0}],
      storageResourcesArray: [{requiredLevel: 0, disabledAtLevel: 0,resourceId:2,baseValue:100,multiplierPerUpgrade: 0.1,multiplierPerLevel: 0.5}],
      statsForFunString: "Some string",
      statsForFunValuesArray: [],
      techStringsArray: ["Axes", "Crosscut Saws", "Enhanced Tools"],
    },
  
  
    {
      slotId: 2,
      name: "Sawmill",
      startsUnlocked: false,
      unlockedBySlotArray: [4,1],
      startsPurchased: false,
      hasWorkers: true,
      upgradesPerLevelArray: [10, 30],
      levelCostResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:2000,multiplierPerUpgrade:0,multiplierPerLevel:2},{requiredLevel:0,disabledAtLevel:1,resourceId:2,baseValue:100,multiplierPerUpgrade:0,multiplierPerLevel:0.5},{requiredLevel:1,disabledAtLevel:0,resourceId:5,baseValue:10,multiplierPerUpgrade:0,multiplierPerLevel:2},{requiredLevel:2,disabledAtLevel:0,resourceId:7,baseValue:50,multiplierPerUpgrade:0,multiplierPerLevel:4}],
      upgradeCostResourcesArray: [{requiredLevel:1,disabledAtLevel:0,resourceId:1,baseValue:500,multiplierPerUpgrade:1,multiplierPerLevel:10},{requiredLevel:1,disabledAtLevel:0,resourceId:2,baseValue:1,multiplierPerUpgrade:0.25,multiplierPerLevel:5}],
      producedResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:3,baseValue:3,multiplierPerUpgrade:0.1,multiplierPerLevel:0.25}],
      upkeepResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:2,multiplierPerUpgrade:0.1,multiplierPerLevel:10},{requiredLevel:1,disabledAtLevel:0,resourceId:2,baseValue:3,multiplierPerUpgrade:0.1,multiplierPerLevel:0.25},{requiredLevel:2,disabledAtLevel:0,resourceId:6,baseValue:10,multiplierPerUpgrade:0.25,multiplierPerLevel:1},{requiredLevel:3,disabledAtLevel:0,resourceId:5,baseValue:5,multiplierPerUpgrade:0.25,multiplierPerLevel:1}],
      storageResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:3,baseValue:100,multiplierPerUpgrade:0.01,multiplierPerLevel:0.5}],
      statsForFunString: "Some string",
      statsForFunValuesArray: [],
      techStringsArray: ["Pit Saw", "Creosote", "Mechanical Steam Saw"],
    },
  
  
    {
      slotId: 3,
      name: "Wood Storage",
      startsUnlocked: false,
      unlockedBySlotArray: [2,1],
      startsPurchased: false,
      hasWorkers: false,
      upgradesPerLevelArray: [],
      levelCostResourcesArray: [{requiredLevel: 0, disabledAtLevel: 0,resourceId:1,baseValue:200,multiplierPerUpgrade: 0.1,multiplierPerLevel: 0.5}],
      upgradeCostResourcesArray: [{requiredLevel: 0, disabledAtLevel: 0,resourceId:1,baseValue:200,multiplierPerUpgrade: 0.1,multiplierPerLevel: 0.5}],
      producedResourcesArray: [],
      upkeepResourcesArray: [],
      storageResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:2,baseValue:200,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5},{requiredLevel:0,disabledAtLevel:0,resourceId:3,baseValue:200,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      statsForFunString: "Some string",
      statsForFunValuesArray: [],
      techStringsArray: ["Basic Yard", "Expanded Shed", "Large Warehouse"],
    },
  
  
    {
      slotId: 4,
      name: "Iron Mine",
      startsUnlocked: false,
      unlockedBySlotArray: [10,1],
      startsPurchased: false,
      hasWorkers: true,
      upgradesPerLevelArray: [10, 30],
      levelCostResourcesArray: [{requiredLevel: 0,disabledAtLevel: 0,resourceId: 1,baseValue: 500,multiplierPerUpgrade: 0,multiplierPerLevel: 3},{requiredLevel: 0,disabledAtLevel: 1,resourceId: 2,baseValue: 150,multiplierPerUpgrade: 0,multiplierPerLevel: 4},{requiredLevel: 1,disabledAtLevel: 0,resourceId: 3,baseValue: 5,multiplierPerUpgrade: 0,multiplierPerLevel: 4},{requiredLevel: 2,disabledAtLevel: 0,resourceId: 7,baseValue: 10,multiplierPerUpgrade: 0,multiplierPerLevel: 3}],
      upgradeCostResourcesArray: [{requiredLevel:1,disabledAtLevel:0,resourceId:1,baseValue:75,multiplierPerUpgrade:0.25,multiplierPerLevel:10}],
      producedResourcesArray: [{requiredLevel: 0, disabledAtLevel: 0, resourceId: 4, baseValue: 1.5, multiplierPerUpgrade: 0.2, multiplierPerLevel: 0.5}],
      upkeepResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:1,multiplierPerUpgrade:0.1,multiplierPerLevel:5},{requiredLevel:1,disabledAtLevel:2,resourceId:2,baseValue:5,multiplierPerUpgrade:0.1,multiplierPerLevel:5},{requiredLevel:2,disabledAtLevel:0,resourceId:3,baseValue:1,multiplierPerUpgrade:0.1,multiplierPerLevel:5},{requiredLevel:2,disabledAtLevel:0,resourceId:5,baseValue:1,multiplierPerUpgrade:0.1,multiplierPerLevel:2},{requiredLevel:3,disabledAtLevel:0,resourceId:7,baseValue:3,multiplierPerUpgrade:0.1,multiplierPerLevel:2}],
      storageResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:4,baseValue:100,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      statsForFunString: "#1# tunnel spanning #2#m long, #3#m deep",
      statsForFunValuesArray: [],
      techStringsArray: ["Manual Tools", "Hand Drilling Tools", "Steam Stone Drilling"],
    },
  
  
    {
      slotId: 5,
      name: "Blacksmith",
      startsUnlocked: false,
      unlockedBySlotArray: [2,1],
      startsPurchased: false,
      hasWorkers: true,
      upgradesPerLevelArray: [10, 30],
      levelCostResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:1700,multiplierPerUpgrade:0,multiplierPerLevel:2},{requiredLevel:0,disabledAtLevel:1,resourceId:4,baseValue:20,multiplierPerUpgrade:0,multiplierPerLevel:15},{requiredLevel:1,disabledAtLevel:2,resourceId:7,baseValue:50,multiplierPerUpgrade:0,multiplierPerLevel:4},{requiredLevel:2,disabledAtLevel:0,resourceId:3,baseValue:200,multiplierPerUpgrade:0,multiplierPerLevel:3}],
      upgradeCostResourcesArray: [{requiredLevel:1,disabledAtLevel:0,resourceId:1,baseValue:1250,multiplierPerUpgrade:0.25,multiplierPerLevel:5},{requiredLevel:1,disabledAtLevel:0,resourceId:4,baseValue:5,multiplierPerUpgrade:0.25,multiplierPerLevel:5}],
      producedResourcesArray: [{requiredLevel: 0,disabledAtLevel: 0,resourceId: 5,baseValue: 2.7,multiplierPerUpgrade: 0.5,multiplierPerLevel: 0.5}],
      upkeepResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:2,multiplierPerUpgrade:0.1,multiplierPerLevel:3},{requiredLevel:1,disabledAtLevel:2,resourceId:2,baseValue:6,multiplierPerUpgrade:0.1,multiplierPerLevel:3},{requiredLevel:2,disabledAtLevel:0,resourceId:3,baseValue:8,multiplierPerUpgrade:0.1,multiplierPerLevel:3},{requiredLevel:3,disabledAtLevel:0,resourceId:7,baseValue:14,multiplierPerUpgrade:0.1,multiplierPerLevel:1}],
      storageResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:5,baseValue:100,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      statsForFunString: "Some string",
      statsForFunValuesArray: [],
      techStringsArray: ["Forging", "Workshop & Anvil", "Advanced Tools"],
    },
  
  
    {
      slotId: 6,
      name: "Iron Storage",
      startsUnlocked: false,
      unlockedBySlotArray: [5,1],
      startsPurchased: false,
      hasWorkers: false,
      upgradesPerLevelArray: [],
      levelCostResourcesArray: [],
      upgradeCostResourcesArray: [{requiredLevel: 0, disabledAtLevel: 0,resourceId:1,baseValue:200,multiplierPerUpgrade: 0.1,multiplierPerLevel: 0.5}],
      producedResourcesArray: [],
      upkeepResourcesArray: [],
      storageResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:4,baseValue:200,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5},{requiredLevel:0,disabledAtLevel:0,resourceId:5,baseValue:200,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      statsForFunString: "Some string",
      statsForFunValuesArray: [],
      techStringsArray: ["Ore Bin", "Tool Shed", "Iron Warehouse"],
    },
  
  
    {
      slotId: 7,
      name: "Gold Mine",
      startsUnlocked: false,
      unlockedBySlotArray: [11,1],
      startsPurchased: false,
      hasWorkers: true,
      upgradesPerLevelArray: [10, 30],
      levelCostResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:150,multiplierPerUpgrade:0,multiplierPerLevel:3},{requiredLevel:0,disabledAtLevel:1,resourceId:2,baseValue:10,multiplierPerUpgrade:0,multiplierPerLevel:5},{requiredLevel:0,disabledAtLevel:1,resourceId:4,baseValue:20,multiplierPerUpgrade:0,multiplierPerLevel:5},{requiredLevel:1,disabledAtLevel:0,resourceId:9,baseValue:5,multiplierPerUpgrade:0,multiplierPerLevel:7},{requiredLevel:2,disabledAtLevel:0,resourceId:7,baseValue:10,multiplierPerUpgrade:0,multiplierPerLevel:0}],
      upgradeCostResourcesArray: [{requiredLevel:1,disabledAtLevel:0,resourceId:1,baseValue:200,multiplierPerUpgrade:0.75,multiplierPerLevel:10}],
      producedResourcesArray: [{requiredLevel: 0, disabledAtLevel: 0, resourceId: 8, baseValue: 5, multiplierPerUpgrade: 0.1, multiplierPerLevel: 0.5}],
      upkeepResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:1,multiplierPerUpgrade:0.1,multiplierPerLevel:5},{requiredLevel:1,disabledAtLevel:2,resourceId:2,baseValue:5,multiplierPerUpgrade:0.1,multiplierPerLevel:5},{requiredLevel:2,disabledAtLevel:0,resourceId:3,baseValue:10,multiplierPerUpgrade:0.1,multiplierPerLevel:5},{requiredLevel:2,disabledAtLevel:0,resourceId:5,baseValue:3,multiplierPerUpgrade:0.1,multiplierPerLevel:5},{requiredLevel:3,disabledAtLevel:0,resourceId:7,baseValue:3,multiplierPerUpgrade:0.1,multiplierPerLevel:5}],
      storageResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:8,baseValue:100,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      statsForFunString: "#1# tunnel spanning #2#m long, #3#m deep",
      statsForFunValuesArray: [],
      techStringsArray: ["Panning Dirt", "Tools & Mine Carts", "Advanced Machines"],
    },
  
  
    {
      slotId: 8,
      name: "Smelters",
      startsUnlocked: false,
      unlockedBySlotArray: [7,1],
      startsPurchased: false,
      hasWorkers: true,
      upgradesPerLevelArray: [10, 30],
      levelCostResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:10000,multiplierPerUpgrade:0,multiplierPerLevel:9},{requiredLevel:0,disabledAtLevel:0,resourceId:8,baseValue:150,multiplierPerUpgrade:0,multiplierPerLevel:3},{requiredLevel:1,disabledAtLevel:0,resourceId:5,baseValue:700,multiplierPerUpgrade:0,multiplierPerLevel:2},{requiredLevel:2,disabledAtLevel:0,resourceId:7,baseValue:500,multiplierPerUpgrade:0.5,multiplierPerLevel:6}],
      upgradeCostResourcesArray: [{requiredLevel:1,disabledAtLevel:0,resourceId:1,baseValue:2500,multiplierPerUpgrade:0.25,multiplierPerLevel:5},{requiredLevel:1,disabledAtLevel:0,resourceId:8,baseValue:10,multiplierPerUpgrade:0.25,multiplierPerLevel:5}],
      producedResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:9,baseValue:0.08,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      upkeepResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:40,multiplierPerUpgrade:0.5,multiplierPerLevel:1},{requiredLevel:1,disabledAtLevel:0,resourceId:8,baseValue:25,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5},{requiredLevel:1,disabledAtLevel:0,resourceId:6,baseValue:25,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5},{requiredLevel:1,disabledAtLevel:0,resourceId:4,baseValue:17,multiplierPerUpgrade:0.25,multiplierPerLevel:2},{requiredLevel:3,disabledAtLevel:0,resourceId:5,baseValue:5,multiplierPerUpgrade:1,multiplierPerLevel:3}],
      storageResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:9,baseValue:100,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      statsForFunString: "Some string",
      statsForFunValuesArray: [],
      techStringsArray: ["Smelting Pots", "Enhanced Tools", "Industrial Smelting"],
    },
  
  
    {
      slotId: 9,
      name: "Gold Storage",
      startsUnlocked: false,
      unlockedBySlotArray: [6,1],
      startsPurchased: false,
      hasWorkers: false,
      upgradesPerLevelArray: [],
      levelCostResourcesArray: [],
      upgradeCostResourcesArray: [{requiredLevel: 0, disabledAtLevel: 0,resourceId:1,baseValue:200,multiplierPerUpgrade: 0.1,multiplierPerLevel: 0.5}],
      producedResourcesArray: [],
      upkeepResourcesArray: [],
      storageResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:8,baseValue:200,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5},{requiredLevel:0,disabledAtLevel:0,resourceId:9,baseValue:200,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      statsForFunString: "Some string",
      statsForFunValuesArray: [],
      techStringsArray: ["Gold Sack", "Strongbox", "Vault"],
    },
  
  
    {
      slotId: 10,
      name: "Coal Mine",
      startsUnlocked: false,
      unlockedBySlotArray: [1,1],
      startsPurchased: false,
      hasWorkers: true,
      upgradesPerLevelArray: [10, 30],
      levelCostResourcesArray: [{requiredLevel: 0, disabledAtLevel: 0,resourceId:1,baseValue:300,multiplierPerUpgrade: 0,multiplierPerLevel: 3},{requiredLevel: 1, disabledAtLevel: 0,resourceId:4,baseValue:100,multiplierPerUpgrade: 0,multiplierPerLevel: 3},],
      upgradeCostResourcesArray: [{requiredLevel: 1, disabledAtLevel: 0,resourceId:1,baseValue:40,multiplierPerUpgrade: 1,multiplierPerLevel: 10},],
      producedResourcesArray: [{requiredLevel: 0, disabledAtLevel: 0,resourceId:6,baseValue:1.2,multiplierPerUpgrade: 0.1,multiplierPerLevel: 0.5}],
      upkeepResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:1,multiplierPerUpgrade:0.1,multiplierPerLevel:5},{requiredLevel:1,disabledAtLevel:2,resourceId:2,baseValue:0.8,multiplierPerUpgrade:0.1,multiplierPerLevel:5},{requiredLevel:2,disabledAtLevel:0,resourceId:5,baseValue:10,multiplierPerUpgrade:0.1,multiplierPerLevel:5},{requiredLevel:2,disabledAtLevel:0,resourceId:3,baseValue:3,multiplierPerUpgrade:0.1,multiplierPerLevel:5},{requiredLevel:3,disabledAtLevel:0,resourceId:7,baseValue:3,multiplierPerUpgrade:0.1,multiplierPerLevel:5}],
      storageResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:6,baseValue:100,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      statsForFunString: "#1# tunnel spanning #2#m long, #3#m deep",
      statsForFunValuesArray: [],
      techStringsArray: ["Picks & Shovels", "Mine Carts & Timber Supports", "Steam Mining Tools"],
    },
  
  
    {
      slotId: 11,
      name: "Steel Works",
      startsUnlocked: false,
      unlockedBySlotArray: [5,1],
      startsPurchased: false,
      hasWorkers: true,
      upgradesPerLevelArray: [10, 30],
      levelCostResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:3500,multiplierPerUpgrade:0,multiplierPerLevel:3},{requiredLevel:0,disabledAtLevel:1,resourceId:4,baseValue:250,multiplierPerUpgrade:0,multiplierPerLevel:3},{requiredLevel:0,disabledAtLevel:1,resourceId:6,baseValue:250,multiplierPerUpgrade:0,multiplierPerLevel:2},{requiredLevel:1,disabledAtLevel:0,resourceId:8,baseValue:50,multiplierPerUpgrade:0,multiplierPerLevel:4},{requiredLevel:2,disabledAtLevel:0,resourceId:5,baseValue:75,multiplierPerUpgrade:0,multiplierPerLevel:6}],
      upgradeCostResourcesArray: [{requiredLevel:1,disabledAtLevel:0,resourceId:1,baseValue:750,multiplierPerUpgrade:1.2,multiplierPerLevel:5},{requiredLevel:1,disabledAtLevel:0,resourceId:6,baseValue:2,multiplierPerUpgrade:0.25,multiplierPerLevel:5}],
      producedResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:7,baseValue:0.8,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      upkeepResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:1,baseValue:2,multiplierPerUpgrade:0.1,multiplierPerLevel:10},{requiredLevel:0,disabledAtLevel:0,resourceId:6,baseValue:12,multiplierPerUpgrade:0.1,multiplierPerLevel:2},{requiredLevel:0,disabledAtLevel:0,resourceId:4,baseValue:12,multiplierPerUpgrade:0.1,multiplierPerLevel:2},{requiredLevel:1,disabledAtLevel:0,resourceId:3,baseValue:5,multiplierPerUpgrade:0.25,multiplierPerLevel:4},{requiredLevel:2,disabledAtLevel:0,resourceId:5,baseValue:25,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      storageResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:7,baseValue:100,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      statsForFunString: "Some string",
      statsForFunValuesArray: [],
      techStringsArray: ["Bloomery Furnace", "Bessemer Process", "Open Hearth Process"],
    },
  
  
    {
      slotId: 12,
      name: "Steel Storage",
      startsUnlocked: false,
      unlockedBySlotArray: [11,1],
      startsPurchased: false,
      hasWorkers: false,
      upgradesPerLevelArray: [],
      levelCostResourcesArray: [],
      upgradeCostResourcesArray: [{requiredLevel: 0, disabledAtLevel: 0,resourceId:1,baseValue:200,multiplierPerUpgrade: 0.1,multiplierPerLevel: 0.5}],
      producedResourcesArray: [],
      upkeepResourcesArray: [],
      storageResourcesArray: [{requiredLevel:0,disabledAtLevel:0,resourceId:6,baseValue:200,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5},{requiredLevel:0,disabledAtLevel:0,resourceId:7,baseValue:200,multiplierPerUpgrade:0.1,multiplierPerLevel:0.5}],
      statsForFunString: "Some string",
      statsForFunValuesArray: [],
      techStringsArray: ["Coal Bunker", "Steel Yard", "Industrial Depot"],
    },
  
  
  ]
  
  
  
  // ############################                END SLOT DATA                ################################# 
  ;
  private resourceDataJSON: ResourceDataStruc[] = 
  // ############################                START RESOURCE DATA                ################################# 
  [

    {
      resourceId: 1,
      name: "Coins",
      colour: hz.Color.fromHex("#FFC300"),
      addStatIdArray: [3],
      traderPrice: 0,
      traderMinPrice: 0,
      traderMaxPrice: 0,
      traderPriceInstability: 0,
      traderRefVolume: 0,
      traderPlayerInfluence: 0,
    },
  
  
    {
      resourceId: 2,
      name: "Logs",
      colour: hz.Color.fromHex("#985f38"),
      addStatIdArray: [4],
      traderPrice: 1,
      traderMinPrice: 1,
      traderMaxPrice: 5,
      traderPriceInstability: 0.075,
      traderRefVolume: 50000,
      traderPlayerInfluence: 0.5,
    },
  
  
    {
      resourceId: 3,
      name: "Planks",
      colour: hz.Color.fromHex("#ffe9ab"),
      addStatIdArray: [8],
      traderPrice: 28,
      traderMinPrice: 14,
      traderMaxPrice: 56,
      traderPriceInstability: 0.1,
      traderRefVolume: 40000,
      traderPlayerInfluence: 0.6,
    },
  
  
    {
      resourceId: 4,
      name: "IronOre",
      colour: hz.Color.fromHex("#849495"),
      addStatIdArray: [6],
      traderPrice: 17,
      traderMinPrice: 8,
      traderMaxPrice: 34,
      traderPriceInstability: 0.1,
      traderRefVolume: 30000,
      traderPlayerInfluence: 0.6,
    },
  
  
    {
      resourceId: 5,
      name: "Tools",
      colour: hz.Color.fromHex("#b4c9c4"),
      addStatIdArray: [9],
      traderPrice: 68,
      traderMinPrice: 1,
      traderMaxPrice: 72,
      traderPriceInstability: 0.2,
      traderRefVolume: 20000,
      traderPlayerInfluence: 0.7,
    },
  
  
    {
      resourceId: 6,
      name: "Coal",
      colour: hz.Color.fromHex("#949896"),
      addStatIdArray: [5],
      traderPrice: 4,
      traderMinPrice: 2,
      traderMaxPrice: 8,
      traderPriceInstability: 0.1,
      traderRefVolume: 35000,
      traderPlayerInfluence: 0.5,
    },
  
  
    {
      resourceId: 7,
      name: "Steel",
      colour: hz.Color.fromHex("#c6c3c0"),
      addStatIdArray: [10],
      traderPrice: 92,
      traderMinPrice: 46,
      traderMaxPrice: 184,
      traderPriceInstability: 0.2,
      traderRefVolume: 20000,
      traderPlayerInfluence: 0.7,
    },
  
  
    {
      resourceId: 8,
      name: "GoldNuggets",
      colour: hz.Color.fromHex("#dbb654"),
      addStatIdArray: [7],
      traderPrice: 22,
      traderMinPrice: 11,
      traderMaxPrice: 44,
      traderPriceInstability: 0.2,
      traderRefVolume: 15000,
      traderPlayerInfluence: 0.8,
    },
  
  
    {
      resourceId: 9,
      name: "GoldBars",
      colour: hz.Color.fromHex("#d8a948"),
      addStatIdArray: [11],
      traderPrice: 240,
      traderMinPrice: 120,
      traderMaxPrice: 480,
      traderPriceInstability: 0.3,
      traderRefVolume: 10000,
      traderPlayerInfluence: 1,
    },
  
  
  ]
  
  
  
  // ############################                END RESOURCE DATA                ################################# 
  ;

  private statisticsDataJSON: StatisticsDataStruc[] = 
  // ############################                START STATISTICS DATA                ################################# 
  [

    {
      statId: 1,
      name: "Time Played",
      leaderboard: "Time Played",
    },
  
  
    {
      statId: 2,
      name: "Resources Collected",
      leaderboard: "Total Resources",
    },
  
  
    {
      statId: 3,
      name: "Coins Made",
      leaderboard: "Total Coins",
    },
  
  
    {
      statId: 4,
      name: "Logs Collected",
      leaderboard: "",
    },
  
  
    {
      statId: 5,
      name: "Coal Collected",
      leaderboard: "",
    },
  
  
    {
      statId: 6,
      name: "Iron Ore Collected",
      leaderboard: "",
    },
  
  
    {
      statId: 7,
      name: "Gold Nuggets Collected",
      leaderboard: "",
    },
  
  
    {
      statId: 8,
      name: "Planks Made",
      leaderboard: "",
    },
  
  
    {
      statId: 9,
      name: "Tools Made",
      leaderboard: "",
    },
  
  
    {
      statId: 10,
      name: "Steel Made",
      leaderboard: "",
    },
  
  
    {
      statId: 11,
      name: "Gold Bars Made",
      leaderboard: "",
    },
  
  
    {
      statId: 12,
      name: "Upgrades Purchased",
      leaderboard: "",
    },
  
  
  ]
  
  
  
  // ############################                END STATISTICS DATA                ################################# 
  ;

  private triviaDataJSON: TriviaDataStruc[] = 
  // ############################                START TRIVIA DATA                ################################# 
  [ 
    {
      triviaId: 1,
      categoryId: 1,
      title: "Planks",
      body: "Planks are made from wood",
    },
    {
      triviaId: 2,
      categoryId: 1,
      title: "Wood",
      body: "Wood is tree",
    },
    {
      triviaId: 3,
      categoryId: 1,
      title: "Something else about wood",
      body: "Wood is flamable",
    },
    {
      triviaId: 4,
      categoryId: 2,
      title: "Something about not wood",
      body: "Stone is stoney",
    },
  ]
  
  
  
  // ############################                END TRIVIA DATA                ################################# 
  ;

  private tutorialData: TutorialDataStruc[] = 
  // ############################                START TUTORIAL DATA                ################################# 
  [

    {
      stepId: 2,
      text: "Intro text 2",
      showButton: true,
      action: "Intro text 2",
    },
  
  
    {
      stepId: 3,
      text: "Intro text 3",
      showButton: true,
      action: "Intro text 3",
    },
  
  
    {
      stepId: 4,
      text: "Buy the lumber camp",
      showButton: false,
      action: "Buy the lumber camp",
    },
  
  
    {
      stepId: 5,
      text: "Hire a worker",
      showButton: false,
      action: "Hire a worker",
    },
  
  
    {
      stepId: 6,
      text: "Assign worker to lumber camp",
      showButton: false,
      action: "Assign worker to lumber camp",
    },
  
  
    {
      stepId: 7,
      text: "Collect resources from lumber camp",
      showButton: false,
      action: "Collect resources from lumber camp",
    },
  
  
    {
      stepId: 8,
      text: "Sell resources to train station market",
      showButton: false,
      action: "Sell resources to train station market",
    },
  
  
  ]
  
  
  
  // ############################                END TUTORIAL DATA                ################################# 
  ;

  private notificationsData: NotificationDataStruc[] = 
  // ############################                START NOTIFICATION DATA                ################################# 
  [

    {
      notificationId: 1,
      text: "#1# has joined the game.",
    },
  
  
    {
      notificationId: 2,
      text: "#1# has left the game.",
    },
  
  
    {
      notificationId: 3,
      text: "To unlock #1#, you must purchase #2#.",
    },
  
  
    {
      notificationId: 4,
      text: "You cannot afford that.",
    },
  
  
    {
      notificationId: 5,
      text: "Please wait, still loading offline progress.",
    },
  
  
    {
      notificationId: 6,
      text: "No workers available to hire.",
    },
  
  
    {
      notificationId: 7,
      text: "#1# unlocked!",
    },
  
  
    {
      notificationId: 8,
      text: "#1# purchased!",
    },
  
  
    {
      notificationId: 9,
      text: "#1# is now tier #2#.",
    },
  
  
    {
      notificationId: 10,
      text: "#1# has stopped due to missing upkeep.",
    },
  
  
    {
      notificationId: 11,
      text: "#1# has stopped due to full storage.",
    },
  
  
    {
      notificationId: 12,
      text: "No workers available to assign.",
    },
  
  
    {
      notificationId: 13,
      text: "You cannot unassign the last worker.",
    },
  
  
    {
      notificationId: 14,
      text: "You cannot assign any more workers to this.",
    },
  
  
  ]
  
  
  
  // ############################                END NOTIFICATION DATA                ################################# 
  ;

  

  preStart() {
  }

  start() {
    //console.log(`GameData: resource data stringify length: ${JSON.stringify(this.resourceDataJSON).length}`); 
    //console.log(`GameData: resource data stringify: ${JSON.stringify(this.resourceDataJSON)}`); 
    //console.log(`GameData: Sending resource data for ${this.resourceDataJSON.length} resources`);
    this.sendNetworkBroadcastEvent(registerResourceData,{resourceGameData: this.resourceDataJSON}); // send slot data to area managers
    console.log(`GameData: slot data stringify length: ${JSON.stringify(this.slotDataJSON).length}, est size: ${Math.ceil(JSON.stringify(this.slotDataJSON).length / 1024)} kb`); 
    //console.log(`GameData: slot data stringify: ${JSON.stringify(this.slotDataJSON)}`); 
    //console.log(`GameData: Sending slot data for ${this.slotDataJSON.length} slots`);
    this.sendNetworkBroadcastEvent(registerSlotData,{slotGameData: this.slotDataJSON}); // send slot data to area managers
    this.sendNetworkBroadcastEvent(registerStatisticsData,{statisiticsGameData: this.statisticsDataJSON}); // send stat data to area managers
    this.sendNetworkBroadcastEvent(registerTriviaData,{triviaGameData: this.triviaDataJSON}); // send trivia data to area managers
    this.sendNetworkBroadcastEvent(registerTutorialData,{tutorialGameData: this.tutorialData}); // send tutorial data to area managers
    this.sendNetworkBroadcastEvent(registerNotificationData,{notificationGameData: this.notificationsData}); // send notification data to area managers
  };
};

export type AreaSlotDataStruct = {
  slotId: number,       // 
  name: string,       // the name of the slot (eg. "Lumber Mill")
  startsUnlocked: boolean,      // whether the player starts the game with this slot unlocked
  unlockedBySlotArray: number[],      // ^ if false - purchasing which slot will unlock this slot
  startsPurchased: boolean,     // whether the player starts the game with this slot at level 1
  hasWorkers: boolean,     // the max population allowed to be assigned to this slot
  upgradesPerLevelArray: number[],      // array of how many upgrades are required to reach the next level (eg [1] = 5 means 5 upgrades are required to reach level 2)
  levelCostResourcesArray: SlotResourceStruc[],        // the resource data for purchasing and leveling up
  upgradeCostResourcesArray: SlotResourceStruc[],        // the resource data for upgrading
  //producer
  producedResourcesArray: SlotResourceStruc[],      // the resource data for production
  //upkeep
  upkeepResourcesArray: SlotResourceStruc[],      // the resource data for consumption
  //storage
  storageResourcesArray: SlotResourceStruc[],     // the resource data for storage
  statsForFunString: string,    // for fun string (eg "#1# tunnels extend #2# meters wide and #3# meters deep.")
  statsForFunValuesArray: number[],     // each number surrounded by # in the string is replaced with a calculated number from each array element
  techStringsArray: string[],
};

export type SlotResourceStruc = {
  requiredLevel: number,      // required level of the slot before this array element is considered
  disabledAtLevel: number,
  resourceId: number,     // the id of the resource                     
  baseValue: number,      // the base value before any upgrades or level ups
  multiplierPerUpgrade: number,   // the multiplier per upgrade purchased (including previous levels)
  multiplierPerLevel: number,       // the multiplier per level up
};

export type ResourceDataStruc = {
  resourceId: number,
  name: string,
  colour: hz.Color,
  addStatIdArray: number[],
  traderPrice: number,
  traderMinPrice: number,
  traderMaxPrice: number,
  traderPriceInstability: number,
  traderRefVolume: number,
  traderPlayerInfluence: number,
};

export type StatisticsDataStruc = {
  statId: number,
  name: string,
  leaderboard: string,
};

export type TriviaDataStruc = {
  triviaId: number,
  categoryId: number,
  title: string,
  body: string,
};

export type TutorialDataStruc = {
  stepId: number,
  text: string,
  showButton: boolean,
  action: any, // to do
};

export type NotificationDataStruc = {
  notificationId: number,
  text: string,
};

hz.Component.register(GameData);

import * as hz from 'horizon/core';

import {
  onEnterSlot,
  onExitSlot,
  onInteractWithSlot
} from 'SlotManager';

class OpenSlotUIScript extends hz.Component<typeof OpenSlotUIScript> {
  static propsDefinition = {
    areaId: { type: hz.PropTypes.Number },
    slotId: { type: hz.PropTypes.Number },
    slotUiEntity: { type: hz.PropTypes.Entity },
    focusUITrigger: { type: hz.PropTypes.Entity },
  };

  start() {
    if (this.props.areaId == null || this.props.slotId == null) {
      console.warn(`[OpenSlotUIScript] areaId or slotId not set on ${this.entity.name.get()}`);
      return;
    }

    // updateSlotUITrigger (this.entity)
    this.connectCodeBlockEvent(this.entity, hz.CodeBlockEvents.OnPlayerEnterTrigger, (player: hz.Player) => {
      if (this.props.slotUiEntity) {
        this.sendNetworkBroadcastEvent(onEnterSlot, {
          player,
          areaId: this.props.areaId,
          slotId: this.props.slotId,
          slotUiEntity: this.props.slotUiEntity,
        });
      } else {
        console.warn('slotUiEntity not set!');
      }
    });    

    this.connectCodeBlockEvent(this.entity, hz.CodeBlockEvents.OnPlayerExitTrigger, (player: hz.Player) => {
      this.sendNetworkBroadcastEvent(onExitSlot, {
        player,
        areaId: this.props.areaId,
        slotId: this.props.slotId,
      });
    });

    // focus trigger (optional?)
    if (this.props.focusUITrigger) {
      this.connectCodeBlockEvent(this.props.focusUITrigger, hz.CodeBlockEvents.OnPlayerEnterTrigger, (player: hz.Player) => {
        this.sendNetworkBroadcastEvent(onInteractWithSlot, {
          player,
          areaId: this.props.areaId,
          slotId: this.props.slotId,
        });
      });
    }
  }
}

hz.Component.register(OpenSlotUIScript);

import * as hz from 'horizon/core';
import { onUIReadyForRegistration, sendUIUpdate, spawnUIForPlayer, cleanupUIForPlayer } from 'UIManager';
import { AreaSlotDataStruct, ResourceDataStruc, SlotResourceStruc, NotificationDataStruc, registerResourceData, registerSlotData, registerNotificationData, StatisticsDataStruc, registerStatisticsData } from 'GameData';
import { onEnterSlot, onExitSlot, onInteractWithSlot } from 'SlotManager';
import { onEnterUITrigger, onExitUITrigger, onInteractUITrigger } from 'OpenUIScript';
import { playSound } from 'SoundManager';

export const onUIReady = new hz.NetworkEvent<{ player: hz.Player, uiName: string, uiEntity: hz.Entity }>('onUIReady');
export const onPlayerAcknowledgedWelcome = new hz.NetworkEvent<{ player: hz.Player }>('onPlayerAcknowledgedWelcome');

export const assignPlayer = new hz.NetworkEvent<{areaId: number, player: hz.Player}>('assignPlayer');
export const loadSlotData = new hz.NetworkEvent<{slotsSaveData: AreaSlotSaveStruc[]}>('loadSlotData');
export const unlockSlot = new hz.NetworkEvent<{slotId: number}>('unlockSlot');
export const levelUpSlot = new hz.NetworkEvent<{slotId: number, level: number}>('levelUpSlot');

export const tryBuySlot = new hz.NetworkEvent<{player: hz.Player, areaId: number, slotId: number}>('tryBuySlot');
export const takeFromSlotStorage = new hz.NetworkEvent<{player: hz.Player, areaId: number, slotId: number}>('takeFromSlotStorage');
export const addWorkerToSlot = new hz.NetworkEvent<{player: hz.Player, areaId: number, slotId: number}>('addWorkerToSlot');
export const removeWorkerFromSlot = new hz.NetworkEvent<{player: hz.Player, areaId: number, slotId: number}>('removeWorkerFromSlot');
export const sellResource = new hz.NetworkEvent<{player: hz.Player, resourceId: number, sellAmount: number, sellValue: number}>('sellResource');
export const setSupervisor = new hz.NetworkEvent<{player: hz.Player, areaId: number, slotId: number}>('setSupervisor');
export const tryHireWorker = new hz.NetworkEvent<{player: hz.Player}>('tryHireWorker');

export const onPlayerResourceUpdate = new hz.NetworkEvent<{player: hz.Player, playerResourceData: ResourcesSaveStruc[]}>('onPlayerResourceUpdate');

export const reset = new hz.NetworkEvent<{}>('reset');

export const saveNameMetaData = "PlayerData:MetaData";
export const saveNameSlotData = "PlayerData:SlotSaveData";
export const saveNameResourceData = "PlayerData:ResourcesSaveData";
export const saveNameStatData = "PlayerData:StatisticsSaveData";

type GameSlotStruc = {
  gameSlotId: number,
  player: hz.Player | undefined,
  area: hz.Entity,
};

export type PlayerDataStruc = {
  playerId: number,
  player: hz.Player,
  supervisedSlotId: number,
  visibleSlotUIs: number[],
  isAtTrader: boolean,
  offlineProcess: number,
  saveData: PlayerSavedDataStruc,
  slotsLastCycleWasDry: number[],
};

type PlayerSavedDataStruc = {
  metaData: MetaDataSaveStruc,
  resourcesData: ResourcesSaveStruc[],
  areaSlotData: AreaSlotSaveStruc[],
  statistics: StatisticsSaveStruc[],
};

export type MetaDataSaveStruc = {
  isNewPlayer: boolean,
  tutorialStep: number,
  saveVersion: number,
  lastSaveTime: number,
  offlineTimeAmount: number,
  offlineUpgradeLv: number,
  currentWorkers: number,
  totalWorkers: number,
}

export type AreaSlotSaveStruc = {
  areaSlotId: number,
  numberOfUpgrades: number,
  assignedPop: number,
  storageArray: ResourcesSaveStruc[],
};

export type ResourcesSaveStruc = {
  resourceId: number,
  amount: number,
};

type StatisticsSaveStruc = {
  statId: number,
  value: number,
};

type ResourceProcessData = {
  resourceId: number,
  playerCurrentAmount: number,
  slotsCurrentAmount: number,
  slotsMaxStorage: number,
};

export type TraderResourceStruc = {
  resourceId: number,
  currentPrice: number,
  lastPriceChangePositive: boolean,
  lastEventUnstable: boolean,
};

export type TraderUIDataStruc = {
  visible?: boolean;
  resourceGameData?: ResourceDataStruc[];
  playerResourceData?: ResourcesSaveStruc[];
  currentPricesData?: TraderResourceStruc[];
}

export type ResourceBarUIDataStruc = {
  visible?: boolean;
  resourceGameData?: ResourceDataStruc[];
  playerResourceData?: ResourcesSaveStruc[];
  unassignedWorkers?: number;
};

export type WelcomeUIDataStruc = {
  visible?: boolean;
  playerMetaData?: MetaDataSaveStruc;
};

export type OfflineProgressUIDataStruc = {
  visible?: boolean;
  playerMetaData?: MetaDataSaveStruc;
  offlineTimeInSecs?: number;
  progressPercent?: number;
  wasEarlyCancel?: boolean;
};

export type SlotUIGameDataStruc = {
  name: string;
  techString: string;
  statsForFun: string;
};

export type SlotUISaveDataStruc = {
  level: number;
  upgrades: number;
  curWorkers: number;
  maxWorkers: number;
  nextBuyLvlUp: boolean;
  costResources: ResourcesSaveStruc[];
  upkeepResources: ResourcesSaveStruc[];
  productionResources: ResourcesSaveStruc[];
  currentStorageResources: ResourcesSaveStruc[];
  maxStorageResources: ResourcesSaveStruc[];
};

export type SlotUIDataStruc = {
  visible?: boolean;
  areaId?: number;
  slotId?: number;
  uiPos?: hz.Vec3;
  uiRot?: hz.Quaternion;
  slotGameData?: SlotUIGameDataStruc;
  slotSaveData?: SlotUISaveDataStruc;
  slotMessage?: string;
};

export type SaloonUIDataStruc = {
  visible?: boolean;
  currentWorkers?: number;
  availableWorkers?: number;
  hireCost?: ResourcesSaveStruc[];
};

export type NotificationUIDataStruc = {
  visible?: boolean;
  message?: string;
};

class PlayerManager extends hz.Component<typeof PlayerManager> {
  static propsDefinition = {
    saveVersion: {type: hz.PropTypes.Number},
    autoSaveIntervalSecs: {type: hz.PropTypes.Number},
    traderPriceIntervalSecs: {type: hz.PropTypes.Number},

    startingCoins: {type: hz.PropTypes.Number},

    slotCycleTimeSecs: { type: hz.PropTypes.Number },
    slotMultiPerWorker: { type: hz.PropTypes.Number },
    slotMultiSupervisor: { type: hz.PropTypes.Number },

    offlineCyclesPerInterval: {type: hz.PropTypes.Number },
    numMaxDryCycles: {type: hz.PropTypes.Number},

    workerBasePrice: {type: hz.PropTypes.Number},
    workerPriceExponent: {type: hz.PropTypes.Number},
  };

  private gameSlots: GameSlotStruc[] = []; // stores area entity and player entity for each area
  private players: PlayerDataStruc[] = []; // stores player save data
  private resourceGameDataArray: ResourceDataStruc[] = []; // stores data about each resource, filled by a listener for "registerResourceData"
  private slotGameDataArray: AreaSlotDataStruct[] = []; // stores data about each slot, filled by a listener for "registerSlotData"
  private notificationGameDataArray: NotificationDataStruc[] = [];
  private traderPriceData: TraderResourceStruc[] = []; // stores the resource price data for the trader
  private statisticsGameData: StatisticsDataStruc[] = []; // stores data about each slot

  preStart() {
    // setting up the areas ready to be assigned players
    const areasManagers = this.world.getEntitiesWithTags(['AreaManager']);  

    for (let i = 0; i < areasManagers.length; i++) {
      const area = areasManagers[i];
      if (area) {
        console.log(`PlayerManager:preStart: Setting up game slot ${i+1}`);
        const newSlot: GameSlotStruc = {
          gameSlotId: i+1,
          player: undefined,
          area: area,
        };
        this.gameSlots.push(newSlot);
      };
      
    };

    //console.log(`PlayerManager: Setup complete, there are ${this.gameSlots.length} game slots waiting to be assigned.`);

    // listerners
    // on player enter and exit event listeners
    this.connectCodeBlockEvent(
      this.entity,
      hz.CodeBlockEvents.OnPlayerEnterWorld,
      (player: hz.Player) => {
        //console.log(`PlayerManager:OnPlayerEnterWorld: assign game slot to player`);
        this.handleOnPlayerEnter(player);
    });
    this.connectCodeBlockEvent(
      this.entity,
      hz.CodeBlockEvents.OnPlayerExitWorld,
      (player: hz.Player) => {
        //console.log(`PlayerManager:OnPlayerExitWorld: unassign game slot from player`);
        this.handleOnPlayerExit(player);
    });
    this.connectNetworkBroadcastEvent(
      registerResourceData,
      (data: { resourceGameData: ResourceDataStruc[] }) => {
        if (data.resourceGameData !== undefined) {
          //console.log(`PlayerManager:registerResourceData: Parsing resource data: ${data.resourceGameData}`);
          this.resourceGameDataArray = data.resourceGameData;
          this.initTrader();
        };
    });
    this.connectNetworkBroadcastEvent(
      registerSlotData,
      (data: {slotGameData: AreaSlotDataStruct[]}) => {
        if (data.slotGameData !== undefined) {
          //console.log(`PlayerManager:registerSlotData: Parsing slot data: ${data.slotGameData}`);
          this.slotGameDataArray = data.slotGameData;
        };
    });
    this.connectNetworkBroadcastEvent(
      registerNotificationData,
      (p: {notificationGameData: NotificationDataStruc[]}) => {
        if (p.notificationGameData !== undefined) {
          //console.log(`PlayerManager:registerNotificationData: Parsing notification data: ${p.notificationGameData}`);
          this.notificationGameDataArray = p.notificationGameData;
        };
    });
    this.connectNetworkBroadcastEvent(
      registerStatisticsData,
      (p: {statisiticsGameData: StatisticsDataStruc[]}) => {
        if (p.statisiticsGameData !== undefined) {
          //console.log(`PlayerManager:registerStatisticsData: Parsing statistics data: ${p.statisiticsGameData}`);
          this.statisticsGameData = p.statisiticsGameData;
        };
    });
    this.connectNetworkBroadcastEvent(
      onEnterSlot,
      (p: {player: hz.Player, areaId: number, slotId: number, slotUiEntity: hz.Entity}) => {
        //console.log(`PlayerManager:onEnterSlot: supervise slot`);
        //this.setSupervisorForSlot(data.player,data.areaId,data.slotId);
        const playerData = this.players.find(data => data.player === p.player);
        if (playerData && !playerData.visibleSlotUIs.find(visibleSlotId => visibleSlotId === p.slotId)) {
          playerData.visibleSlotUIs.push(p.slotId);
        };
        this.updateUISlotUI(p.player,p.areaId,p.slotId,p.slotUiEntity);
    });
    this.connectNetworkBroadcastEvent(
      onExitSlot,
      (p: {player: hz.Player, areaId: number, slotId: number}) => {
        //console.log(`PlayerManager:onExitSlot: unset supervise slot`);
        //this.setSupervisorForSlot(data.player,data.areaId,0);
        const playerData = this.players.find(data => data.player === p.player);
        if (playerData && playerData.visibleSlotUIs.find(visibleSlotId => visibleSlotId === p.slotId)) {
          playerData.visibleSlotUIs = playerData.visibleSlotUIs.filter(visibleSlotId => visibleSlotId !== p.slotId);
        };
        this.hideUISlotUIForPlayer(p.player,p.areaId,p.slotId);
    });  
    this.connectNetworkBroadcastEvent(
      onInteractWithSlot,
      (data: {player: hz.Player, areaId: number, slotId: number}) => {
        //console.log(`PlayerManager:onInteractWithSlot: open slot ui`);
        this.focusSlotUI(data.player,data.areaId,data.slotId);
    });   
    this.connectNetworkBroadcastEvent(
      tryBuySlot,
      (data: {player: hz.Player, areaId: number, slotId: number}) => {
        if (data.player !== undefined) {
          //console.log(`PlayerManager:tryBuySlot: trying to buy a slot`);
          this.tryBuySlot(data.player,data.areaId,data.slotId);
        };
    });
    this.connectNetworkBroadcastEvent(
      takeFromSlotStorage,
      (data: {player: hz.Player, areaId: number, slotId: number}) => {
        if (data.player !== undefined) {
          //console.log(`PlayerManager:takeFromSlotStorage: take all resources from slot`);
          this.takeFromSlotStorage(data.player,data.areaId,data.slotId);
        };
    });
    this.connectNetworkBroadcastEvent(
      addWorkerToSlot,
      (data: {player: hz.Player, areaId: number, slotId: number}) => {
        if (data.player !== undefined) {
          //console.log(`PlayerManager:addWorkerToSlot: try assign worker to slot`);
          this.modifySlotWorkers(data.player,data.areaId,data.slotId, 1);
        };
    });
    this.connectNetworkBroadcastEvent(
      removeWorkerFromSlot,
      (data: {player: hz.Player, areaId: number, slotId: number}) => {
        if (data.player !== undefined) {
          //console.log(`PlayerManager:removeWorkerFromSlot: try remove a worker from slot`);
          this.modifySlotWorkers(data.player,data.areaId,data.slotId, -1);
        };
    });
    this.connectNetworkBroadcastEvent(
      sellResource,
      (data: {player: hz.Player, resourceId: number, sellAmount: number, sellValue: number}) => {
        if (data.player !== undefined) {
          //console.log(`PlayerManager:sellResource: sell resource`);
          this.traderSellResource(data.player,data.resourceId,data.sellAmount,data.sellValue);
        };
    });
    this.connectNetworkBroadcastEvent(
      onEnterUITrigger,
      (data: {player: hz.Player, uiName: string}) => {
        //console.log(`PlayerManager:onEnterUITrigger: update ui`);
        if (data.player && data.uiName) {
          if (data.uiName === "trader") {
            //console.log(`PlayerManager:onEnterUITrigger: entered trader zone ${data.player.name.get()}`);
            const playerData = this.players.find(playerdata => playerdata.player === data.player);
            if (playerData) {
              playerData.isAtTrader = true;
              

              this.updateUITraderUI("all", data.player);
            } else {
              // couldnt find player data
            }

          } else if (data.uiName === "saloon") {
            //console.log(`PlayerManager:onEnterUITrigger: entered saloon zone`);
            this.updateUISaloonUI(data.player);
          };
        };
    }); 
    this.connectNetworkBroadcastEvent(
      onExitUITrigger,
      (data: {player: hz.Player, uiName: string}) => {
        //console.log(`PlayerManager:onEnterUITrigger: stop ui`);
        if (data.player && data.uiName) {
          if (data.uiName === "trader") {
            console.log(`PlayerManager:onExitUITrigger: exited trader zone`);
            const playerData = this.players.find(playerdata => playerdata.player === data.player);
            if (playerData) {
              playerData.isAtTrader = false;
            } else {
              // couldnt find player data
            }

          } else if (data.uiName === "saloon") {
            console.log(`PlayerManager:onEnterUITrigger: entered saloon zone`);
          };
        };
    }); 
    this.connectNetworkBroadcastEvent(
      onInteractUITrigger,
      (data: {player: hz.Player, uiName: string}) => {
        //console.log(`PlayerManager:onInteractUITrigger: open ui`);
        if (data.player && data.uiName) {
          if (data.uiName === "trader") {
            //console.log(`PlayerManager:onInteractUITrigger: open trader ui`);
            this.focusTraderUI(data.player);

          } else if (data.uiName === "saloon") {
            //console.log(`PlayerManager:onInteractUITrigger: open saloon ui`);
            this.focusSaloonUI(data.player);
          };
        };
    }); 
    this.connectNetworkBroadcastEvent(
      tryHireWorker,
      (p: {player: hz.Player}) => {
        if (p.player) {
          console.log(`PlayerManager:tryHireWorker: ${p.player.name.get()} is trying to hire a worker`);
          this.tryBuyWorker(p.player);
        };
    }); 
    this.connectNetworkBroadcastEvent(
      onPlayerAcknowledgedWelcome, 
      ({ player }) => {
      //console.log(`Player ${player.name.get()} acknowledged the welcome screen`);
      const playerData = this.players.find(p => p.player === player);
      if (playerData) {
        playerData.saveData.metaData.isNewPlayer = false;
        this.savePlayerData(player);
        this.triggerTutorialStep(playerData);
      }
    });
    this.connectNetworkBroadcastEvent(
      onUIReady,
      ({ player, uiName, uiEntity }) => {
        const playerData = this.players.find(p => p.player === player);
        if (!playerData) {
          console.warn(`onUIReady: No player data found for ${player.name.get()}`);
          return;
        }
    
        this.sendNetworkBroadcastEvent(onUIReadyForRegistration, {
          player,
          uiName,
          uiEntity
        });
        
        // Send data to UI's that are immediately visible to the player as they load into the world
        if (uiName === 'Welcome') {
          this.sendNetworkBroadcastEvent(sendUIUpdate, {
            player,
            uiName,
            eventName: 'updateWelcome',
            payload: {
              visible: true,
              playerMetaData: playerData.saveData.metaData
            }
          });
    
        } else if (uiName === 'OfflineProgress') {
          this.sendNetworkBroadcastEvent(sendUIUpdate, {
            player,
            uiName,
            eventName: 'updateOfflineProgress',
            payload: {
              visible: false,
              playerMetaData: playerData.saveData.metaData
            }
          });
    
        } else if (uiName === 'ResourceBar') {
          this.sendNetworkBroadcastEvent(sendUIUpdate, {
            player,
            uiName,
            eventName: 'updateResourceBar',
            payload: {
              visible: true,
              playerResourceData: playerData.saveData.resourcesData,
              resourceGameData: this.resourceGameDataArray,
              unassignedWorkers: playerData.saveData.metaData.currentWorkers - this.getCountAllAssignedWorkers(playerData.saveData.areaSlotData),
            }
          });
        }
      }
    );
  };        

  start() {
    // auto saving
    if (this.props.autoSaveIntervalSecs && this.props.autoSaveIntervalSecs > 0) {

      console.log(`PlayerManager:start: Enable autosave`);
      this.async.setInterval(() => {

        //console.log(`PlayerManager:start: Saving ${this.gameSlots.length} areas`);
        this.gameSlots.forEach(playerSlotEntry => {
          if (playerSlotEntry.player !== undefined ) {
            const playerSaveDataEntry = this.players.find(data => data.player === playerSlotEntry.player);
            if (playerSaveDataEntry && playerSaveDataEntry.offlineProcess <= 0) {
              //console.log(`PlayerManager:start: Saving player ${playerSlotEntry.player.name.get()} in area ${playerSlotEntry.gameSlotId}`);
              this.modifyPlayerStat(playerSlotEntry.player,1,this.props.autoSaveIntervalSecs);
              this.savePlayerData(playerSlotEntry.player);
            };
          };
        });
      }, this.props.autoSaveIntervalSecs * 1000);
    };

    this.async.setTimeout(() => {

      // processing slots
      this.async.setInterval(() => {
        // loop through game slots and calculate production slot processing
        this.gameSlots.forEach(areaSlot => {
          if (areaSlot.player !== undefined) {        
            const playerSaveDataEntry = this.players.find(data => data.player === areaSlot.player);
            if (playerSaveDataEntry && playerSaveDataEntry.offlineProcess <= 0) {
              this.processSlotsForPlayer(playerSaveDataEntry, true);
            } else {
              console.log(`PlayerManager:processSlotsLoop: Cant find player data for player ${areaSlot.player.name.get()}, or they are still doing offline progress`);
            };
          };
        });
        this.updateUITraderUI("resources",undefined);
        this.updateUISlotUIForAllPlayers();
      }, (this.props.slotCycleTimeSecs != undefined ? this.props.slotCycleTimeSecs * 1000 : 1000) );
      
      // trader price update loop
      this.async.setInterval(() => {

        this.traderPriceData.forEach(traderData => {
          const resourceGameData = this.resourceGameDataArray.find(data => data.resourceId === traderData.resourceId);
          if (resourceGameData) {

            // stability
            const priceStability = Math.random();
            const currentPrice = traderData.currentPrice;
            const maxPrice = resourceGameData.traderMaxPrice;
            const minPrice = resourceGameData.traderMinPrice;

            if (priceStability <= resourceGameData.traderPriceInstability) {
              // unstable event
              const newRandomPrice = Math.random() * (maxPrice - minPrice + 1) + minPrice;
              traderData.currentPrice = hz.clamp(newRandomPrice,minPrice,maxPrice);
              traderData.lastPriceChangePositive = (Math.floor(newRandomPrice) >= Math.floor(currentPrice));
              traderData.lastEventUnstable = true;

              if (traderData.resourceId == 2) {
                //console.log(`PlayerManager:traderPriceLoop: unstable event - resource ${traderData.resourceId} is now price ${traderData.currentPrice}`);
              };
            } else {
              // stable event
              const priceDiff = currentPrice - resourceGameData.traderPrice;
              const randChange = Math.round(Math.random() * 2 - 1);
              const pullFactor = priceDiff * 0.3;
              const priceChange = randChange - pullFactor;
              const newPrice = currentPrice + priceChange;
              traderData.currentPrice = hz.clamp(newPrice,minPrice,maxPrice);
              traderData.lastPriceChangePositive = (newPrice >= currentPrice);
              traderData.lastEventUnstable = false;

              if (traderData.resourceId == 2) {
                //console.log(`PlayerManager:traderPriceLoop: stable event - resource ${traderData.resourceId} is now price ${traderData.currentPrice}`);
              };
            }

          } else {
            console.log(`PlayerManager:traderPriceLoop: Cant find resource data for resource ${traderData.resourceId}`);
          };
          
        });
        this.updateUITraderUI("prices",undefined);
      }, this.props.traderPriceIntervalSecs * 1000);
    }, 5000);

  };

  // Player/area stuff

  private handleOnPlayerExit(player: hz.Player):void {
    // send notification message to all other players
    this.gameSlots.forEach(gameSlot => {
      if (gameSlot.player && player !== gameSlot.player) {
        this.sendPlayerNotification(gameSlot.player,2,[player.name.get()]);
      };
    });
    console.log(`PlayerManager:handleOnPlayerExit: Removing player: ${player.name.get()}`);
    const playerSlot = this.gameSlots.find(data => data.player === player); // get area data entry for player
    if (playerSlot) {
      //console.log(`PlayerManager: Sending player slot reset command for player ${player?.name.get().toString()}`);
      this.sendNetworkEvent(playerSlot.area,reset,{}); // send reset to the area
      playerSlot.player = undefined; // remove player from entry
      this.async.setTimeout(() => {
        this.sendNetworkBroadcastEvent(cleanupUIForPlayer, { player });
      }, 1000);
    } else {
      console.log(`PlayerManager:handleOnPlayerExit: Cant find game slot for player ${player?.name.get().toString()}`);
    };
  };
  
  private handleOnPlayerEnter(player: hz.Player):void {
    //console.log(`PlayerManager:handleOnPlayerEnter: Adding player: ${player.name.get()}`);

    // send notification message to all other players
    this.gameSlots.forEach(gameSlot => {
      if (gameSlot.player && player !== gameSlot.player) {
        this.sendPlayerNotification(gameSlot.player,1,[player.name.get()]);
      };
    });

    // first we'll add the player to an area, then create a playerdata entry for them with loaded or new data, then send that data to the area.
    const playerSlot = this.gameSlots.find(data => data.player === undefined); // get available area data entry for player
    if (playerSlot) {
      console.log(`PlayerManager:handleOnPlayerEnter: Assigning area ${playerSlot.gameSlotId} to player ${player?.name.get().toString()}`);
      
      playerSlot.player = player; // add player to entry
      this.sendNetworkEvent(playerSlot.area,assignPlayer,{areaId: playerSlot.gameSlotId, player: player}); // send assign player to area

      const playerData = this.loadPlayerData(player,playerSlot);

      if (playerData) {
        this.players.push(playerData);
        
        this.sendNetworkBroadcastEvent(spawnUIForPlayer, { player });

        this.async.setTimeout(() => {
          // need to work out how long has passed between now and the player's last save
          playerData.saveData.metaData.offlineTimeAmount = 7200 / this.props.slotCycleTimeSecs; // temp value - always give the player 2 hours

          const nowTime = new Date();
          const timeDiff = nowTime.getTime() - playerData.saveData.metaData.lastSaveTime;
          const offlineTimeSecs = 1000000; //Math.floor(timeDiff / 1000);
          const numOfCycles = Math.floor(Math.min(offlineTimeSecs / this.props.slotCycleTimeSecs,playerData.saveData.metaData.offlineTimeAmount));
          
          
          if (numOfCycles > 0) {
            playerData.offlineProcess = numOfCycles;
            let totalCyclesCompleted = 0;
            let numDryCycles = 0;

            this.sendNetworkBroadcastEvent(sendUIUpdate, {
              player,
              uiName: 'OfflineProgress',
              eventName: 'updateOfflineProgress',
              payload: {
                visible: true,
                offlineTimeInSecs: playerData.offlineProcess * this.props.slotCycleTimeSecs,
                progressPercent: 0
              }
            });

            console.log(`PlayerManager:handleOnPlayerEnter: Player ${player?.name.get().toString()} has been offline for ${offlineTimeSecs} seconds & they have ${playerData.saveData.metaData.offlineTimeAmount} cycles in offline progress. Processing ${numOfCycles} cycles.`);
            const offlineProcessInterval = this.async.setInterval(() => {
              const cyclesToDo = Math.min(playerData.offlineProcess, this.props.offlineCyclesPerInterval);
              if (cyclesToDo > 0) {
                //console.log(`PlayerManager:handleOnPlayerEnter: Do offline batch of ${cyclesToDo}.`);
                for (let i = 0; i < cyclesToDo; i++) {
                  if (numDryCycles < this.props.numMaxDryCycles) {
                    //console.log(`PlayerManager:handleOnPlayerEnter: Doing offline batch cycle ${i} of ${cyclesToDo}`);
                    if (this.processSlotsForPlayer(playerData, false)) {
                      //console.log(`PlayerManager:handleOnPlayerEnter: Cycle success - reset number of dry cycles ${numDryCycles}`);
                      totalCyclesCompleted += 1;
                      playerData.offlineProcess -= 1;
                      numDryCycles = 0;
                    } else {
                      //console.log(`PlayerManager:handleOnPlayerEnter: Dry cycle - current number of dry cycles in a row: ${numDryCycles}`);
                      numDryCycles += 1;
                    };
                  } else {
                    console.log(`PlayerManager:handleOnPlayerEnter: Nothing produced over the last ${numDryCycles} cycles - cancel offline progress. They completed ${totalCyclesCompleted} cycles`);
                    this.async.clearInterval(offlineProcessInterval);
                    playerData.offlineProcess = 0;
                    playerData.saveData.metaData.offlineTimeAmount = hz.clamp(playerData.saveData.metaData.offlineTimeAmount - totalCyclesCompleted,0,Infinity);

                    this.sendNetworkBroadcastEvent(sendUIUpdate, {
                      player,
                      uiName: 'OfflineProgress',
                      eventName: 'updateOfflineProgress',
                      payload: {
                        visible: false,
                        wasEarlyCancel: true,
                        offlineTimeInSecs: 0,
                        progressPercent: 100
                      }
                    });

                    break;
                  };
                };
                
                console.log(`PlayerManager:handleOnPlayerEnter: Completed batch of offline cycles. player has ${playerData.offlineProcess} left to go - ${totalCyclesCompleted / numOfCycles * 100}% complete`);
                
                this.sendNetworkBroadcastEvent(sendUIUpdate, {
                  player,
                  uiName: 'OfflineProgress',
                  eventName: 'updateOfflineProgress',
                  payload: {
                    visible: true,
                    offlineTimeInSecs: playerData.offlineProcess * this.props.slotCycleTimeSecs,
                    progressPercent: totalCyclesCompleted / numOfCycles * 100
                  }
                });

              } else {
                console.log(`PlayerManager:handleOnPlayerEnter: Finished all batches - end of offline progress. They completed ${totalCyclesCompleted} cycles`);
                this.async.clearInterval(offlineProcessInterval);
                playerData.offlineProcess = 0;
                playerData.saveData.metaData.offlineTimeAmount = hz.clamp(playerData.saveData.metaData.offlineTimeAmount - totalCyclesCompleted,0,Infinity);

              
            
                this.sendNetworkBroadcastEvent(sendUIUpdate, {
                  player,
                  uiName: 'OfflineProgress',
                  eventName: 'updateOfflineProgress',
                  payload: {
                    visible: false,
                    wasEarlyCancel: false,
                    offlineTimeInSecs: 0,
                    progressPercent: 100
                  }
                });
              };

              
              this.sendNetworkBroadcastEvent(sendUIUpdate, {
                player,
                uiName: 'ResourceBar',
                eventName: 'updateResourceBar',
                payload: {
                  visible: true,
                  resourceGameData: this.resourceGameDataArray,
                  playerResourceData: playerData.saveData.resourcesData,
                  unassignedWorkers: playerData.saveData.metaData.currentWorkers - this.getCountAllAssignedWorkers(playerData.saveData.areaSlotData),
                },
              });

            }, 500);
          };

          this.sendNetworkEvent(playerSlot.area,loadSlotData,{slotsSaveData: playerData.saveData.areaSlotData}); // send player area slot data to the area for loading into slots
        }, 1000);
      };

    } else {
      console.log(`PlayerManager:handleOnPlayerEnter: Cant find available area or input manager for player ${player?.name.get().toString()}`);
    };
  };

  private loadPlayerData(player: hz.Player, playerSlot: GameSlotStruc): PlayerDataStruc {
    console.log(`PlayerManager:loadPlayerData: Loading savedata for ${player.name.get().toString()}`);
    let defaultData: PlayerDataStruc = {
      playerId: player.id,
      player: player,
      supervisedSlotId: 0,
      visibleSlotUIs: [],
      isAtTrader: false,
      offlineProcess: 0,
      slotsLastCycleWasDry: [],
      saveData: {
        metaData: {
          isNewPlayer: true,
          tutorialStep: 1,
          saveVersion: this.props.saveVersion,
          lastSaveTime: new Date().getTime(),
          offlineTimeAmount: 20,
          offlineUpgradeLv: 0,
          totalWorkers: 5, // starting available workers in the saloon
          currentWorkers: 0, // starting actual workers
        },
        resourcesData: [],
        areaSlotData: [],
        statistics: [],
      },
    };
    // fun, gotta load all the value seperately??
    // first lets check if they have save data
    let metaData: MetaDataSaveStruc | null = this.world.persistentStorage.getPlayerVariable<MetaDataSaveStruc>(
      player,
      saveNameMetaData
    );
    // if save version is 0 then saving is disabled, if there is no metadata, then its a new player, if saveversion from game and from player are not equal - we should not load
    if (this.props.saveVersion == 0 || metaData == null || metaData.saveVersion !== this.props.saveVersion) {
      console.log(`PlayerManager:loadPlayerData: saveVersion is 0 (reset) or no save data or player ${player.name.get().toString()} is on old version.`);
      // no load - give the player default data and save that.
      if (playerSlot) {

        // set timeout to give player starting resources in 1 second then do a save
        this.async.setTimeout(() => {
          this.modifyPlayerResource(player,1,this.props.startingCoins); // give starting coins
          // and save
          this.savePlayerData(player);
          
        }, 1000);

        // starting slots (startsPurchased = TRUE)
        let defaultSlotsPurchased: AreaSlotSaveStruc[]  = [];
        let defaultSlotsUnlocked: number[]  = [];
        this.slotGameDataArray.forEach(slotGameDataEntry => {
          if (slotGameDataEntry.startsPurchased) {

            let defaultSlotSaveEntry: AreaSlotSaveStruc = {
              areaSlotId: slotGameDataEntry.slotId,
              numberOfUpgrades: 0,
              assignedPop: 0,
              storageArray: [],
            };
            slotGameDataEntry.storageResourcesArray.forEach(slotStorage => {
              const existingStorageEntry = defaultSlotSaveEntry.storageArray.find(data => data.resourceId ===  slotStorage.resourceId);
              if (existingStorageEntry === undefined) {
                const slotStorageEntry: ResourcesSaveStruc = {
                  resourceId: slotStorage.resourceId,
                  amount: 0,
                };
                defaultSlotSaveEntry.storageArray.push(slotStorageEntry);
              };
            });
            defaultSlotsPurchased.push(defaultSlotSaveEntry);
            
          } else if (slotGameDataEntry.startsUnlocked) {

            defaultSlotsUnlocked.push(slotGameDataEntry.slotId);

          };
        });
        //console.log(`PlayerManager:loadPlayerData: There are  ${defaultSlotsPurchased.length} slots that start purchased.`);
        defaultData.saveData.areaSlotData = defaultSlotsPurchased;
        // the slot manager needs to know this slot is purchased to update visuals - send in 0.5 secs
        this.async.setTimeout(() => {
          defaultSlotsPurchased.forEach(startsPurchasedSlot => {
            this.onSlotLevelUp(playerSlot,startsPurchasedSlot.areaSlotId, 1);
          });
          
        }, 500);
      };
    } else {

      defaultData.saveData.metaData = metaData;
    
      //console.log(`PlayerManager:loadPlayerData: saveVersion matches! Load ${player.name.get().toString()}'s data.`);

      // resource data
      let resourceSaveData: ResourcesSaveStruc[] | null = this.world.persistentStorage.getPlayerVariable<ResourcesSaveStruc[]>(
        player,
        saveNameResourceData
      );
      if (resourceSaveData == null) {
        console.log(`PlayerManager:loadPlayerData: Failed to get resourceSaveData for ${player.name.get().toString()}`);
      } else {
        defaultData.saveData.resourcesData = resourceSaveData;
      };

      // slot data
      let slotSaveData: AreaSlotSaveStruc[] | null = this.world.persistentStorage.getPlayerVariable<AreaSlotSaveStruc[]>(
        player,
        saveNameSlotData
      );
      if (slotSaveData == null) {
        console.log(`PlayerManager:loadPlayerData: Failed to get slotSaveData for ${player.name.get().toString()}`);
      } else {
        console.log(`PlayerManager:loadPlayerData: Loading ${slotSaveData.length} slots`);
        defaultData.saveData.areaSlotData = slotSaveData;
      };

      // stats data
      let statsSaveData: StatisticsSaveStruc[] | null = this.world.persistentStorage.getPlayerVariable<StatisticsSaveStruc[]>(
        player,
        saveNameSlotData
      );
      if (statsSaveData == null) {
        console.log(`PlayerManager:loadPlayerData: Failed to get statsSaveData for ${player.name.get().toString()}`);
      } else {
        defaultData.saveData.statistics = statsSaveData;
      };

    };

    return defaultData;
  };

  private savePlayerData(player: hz.Player): void {
    const playerData = this.players.find(data => data.player === player); // get game data entry for player
    if (playerData) {

      console.log(`PlayerManager:savePlayerData: Saving savedata for ${player.name.get().toString()}`);
      playerData.saveData.metaData.lastSaveTime = new Date().getTime();

      // save version
      this.world.persistentStorage.setPlayerVariable<MetaDataSaveStruc>(
        player,
        saveNameMetaData,
        playerData.saveData.metaData
      );
      // areaSlotData
      this.world.persistentStorage.setPlayerVariable<AreaSlotSaveStruc[]>(
        player,
        saveNameSlotData,
        playerData.saveData.areaSlotData
      );
      // resource data
      this.world.persistentStorage.setPlayerVariable<ResourcesSaveStruc[]>(
        player,
        saveNameResourceData,
        playerData.saveData.resourcesData
      );
      // stats data
      this.world.persistentStorage.setPlayerVariable<StatisticsSaveStruc[]>(
        player,
        saveNameStatData,
        playerData.saveData.statistics
      );
    } else {
      console.log(`PlayerManager:savePlayerData: Cant find game slot data entry for ${player.name.get().toString()}`);
    };
  };

  private modifyPlayerResource(player: hz.Player, resourceId: number, amount: number): void {
    const resourceToChangeData = this.resourceGameDataArray.find(data => data.resourceId === resourceId); // get resource data entry for the resource id
    if (resourceToChangeData) {
      const playerData = this.players.find(data => data.player === player); // get game data entry for player
      if (playerData) {
        //console.log(`PlayerManager:modifyPlayerResource: Resource change - player ${player?.name.get().toString()} ${amount} ${resourceToChangeData.name}`);
        const playerResourceEntry = playerData.saveData.resourcesData.find(data => data.resourceId === resourceId); // get the resource entry in the player data array
        if (playerResourceEntry) {
          // add the resource
          playerResourceEntry.amount += amount;
          if (playerResourceEntry.amount < 0) {
            playerResourceEntry.amount = 0;
          };
          //console.log(`PlayerManager:modifyPlayerResource: player  ${player?.name.get().toString()} now has ${playerResourceEntry.amount} ${resourceToChangeData.name}`);

        } else {
          // player doesn't own the resource - add it if giving resource
          if (amount > 0) {
            // create a new entry and add the resource
            const newResourceEntry = {
              resourceId: resourceId,
              amount: amount
              };

            playerData.saveData.resourcesData.push(newResourceEntry);
          };
        };
        if (playerData.offlineProcess === 0) {
          this.sendNetworkBroadcastEvent(sendUIUpdate, {
            player,
            uiName: 'ResourceBar',
            eventName: 'updateResourceBar',
            payload: {
              visible: true,
              resourceGameData: this.resourceGameDataArray,
              playerResourceData: playerData.saveData.resourcesData,
              unassignedWorkers: playerData.saveData.metaData.currentWorkers - this.getCountAllAssignedWorkers(playerData.saveData.areaSlotData),
            },
          });
        };
        if (amount > 0 && resourceToChangeData.addStatIdArray.length) {
          resourceToChangeData.addStatIdArray.forEach(addToStatId => {
            this.modifyPlayerStat(player,addToStatId,amount);
          });
        };
      } else {
        console.log(`PlayerManager:modifyPlayerResource: Cant find game data for player ${player?.name.get().toString()}`);
      };
    } else {
      console.log(`PlayerManager:modifyPlayerResource: Cant find resource data entry for resource id ${resourceId}`);
    };

  };

  // Slot stuff

  private setSupervisorForSlot(player: hz.Player, areaId: number, slotId: number) {
    console.log(`PlayerManager:setSupervisorForSlot: Player ${player?.name.get().toString()} is trying to supervise area:slot - ${areaId}:${slotId}`);
    const gameAreaSlot = this.gameSlots.find(data => data.player === player);
    if (gameAreaSlot) {
      if (gameAreaSlot.gameSlotId === areaId) {
        const playerDataEntry = this.players.find(data => data.player === player);
        if (playerDataEntry) {
          playerDataEntry.supervisedSlotId = slotId;
        } else {
          console.log(`PlayerManager:setSupervisorForSlot: Cant find player data entry for player ${player?.name.get().toString()}`);
        };
      } else {
        // player does not own the area the slot is in
      };
    } else {
      console.log(`PlayerManager:setSupervisorForSlot: Cant find game slot for player ${player?.name.get().toString()}`);
    };
  };

  private getSlotLevel(slotPlayerData: AreaSlotSaveStruc): number {
    let slotCurrentLevel = 0;
    let slotRequiredUpgrades = 0;
    const slotGameDataEntry = this.slotGameDataArray.find(data => data.slotId === slotPlayerData.areaSlotId);
    if (slotGameDataEntry) {
      slotCurrentLevel += 1;
      slotGameDataEntry.upgradesPerLevelArray.forEach(slotLevelRequirement => {
        slotRequiredUpgrades += slotLevelRequirement;
        if (slotRequiredUpgrades < slotPlayerData.numberOfUpgrades) {
          slotCurrentLevel += 1;
        }
      });
    };
    return slotCurrentLevel;
  };

  private getSlotUpkeepResources(slotPlayerData: AreaSlotSaveStruc, isSlotSupervised: boolean): ResourcesSaveStruc[] {
    let upkeepResourcesArray: ResourcesSaveStruc[] = [];
    const slotLevel = this.getSlotLevel(slotPlayerData);
    if (slotLevel > 0) {
      const slotGameDataEntry = this.slotGameDataArray.find(data => data.slotId === slotPlayerData.areaSlotId);
      if (slotGameDataEntry) {
        slotGameDataEntry.upkeepResourcesArray.forEach(upkeepEntry => {
          if (slotLevel >= upkeepEntry.requiredLevel && (upkeepEntry.disabledAtLevel === 0 || slotLevel < upkeepEntry.disabledAtLevel)) {
            const valueUpgradesLevel = upkeepEntry.baseValue * ( 1 + (slotPlayerData.numberOfUpgrades * upkeepEntry.multiplierPerUpgrade) + ((slotLevel - 1) * upkeepEntry.multiplierPerLevel) );
            const totalValue = valueUpgradesLevel + (valueUpgradesLevel * ((isSlotSupervised ? this.props.slotMultiSupervisor : 0) + (slotPlayerData.assignedPop * this.props.slotMultiPerWorker)));
            const upkeepReqEntry: ResourcesSaveStruc = {
              resourceId: upkeepEntry.resourceId,
              amount: hz.clamp(Math.round(totalValue),1,Infinity),
            }
            upkeepResourcesArray.push(upkeepReqEntry);
          };
        });
      };
    };
    return upkeepResourcesArray;
  };

  private getSlotProducedResources(slotPlayerData: AreaSlotSaveStruc, isSlotSupervised: boolean): ResourcesSaveStruc[] {
    let producedResourcesArray: ResourcesSaveStruc[] = [];
    const slotLevel = this.getSlotLevel(slotPlayerData);
    if (slotLevel > 0) {
      const slotGameDataEntry = this.slotGameDataArray.find(data => data.slotId === slotPlayerData.areaSlotId);
      if (slotGameDataEntry) {
        slotGameDataEntry.producedResourcesArray.forEach(productionEntry => {
          if (slotLevel >= productionEntry.requiredLevel && (productionEntry.disabledAtLevel === 0 || slotLevel < productionEntry.disabledAtLevel)) {
            const valueUpgradesLevel = productionEntry.baseValue * ( 1 + (slotPlayerData.numberOfUpgrades * productionEntry.multiplierPerUpgrade) + ((slotLevel - 1) * productionEntry.multiplierPerLevel) );
            const totalValue = valueUpgradesLevel + (valueUpgradesLevel * ((isSlotSupervised ? this.props.slotMultiSupervisor : 0) + (slotPlayerData.assignedPop * this.props.slotMultiPerWorker)));
            const producedResourceEntry: ResourcesSaveStruc = {
              resourceId: productionEntry.resourceId,
              amount: hz.clamp(Math.round(totalValue),1,Infinity),
            }
            producedResourcesArray.push(producedResourceEntry);
          };
        });
      };
    };
    return producedResourcesArray;
  };

  private getSlotInitialCost(slotId: number): ResourcesSaveStruc[] {
    let result: ResourcesSaveStruc[] = [];

    const slotGameData = this.slotGameDataArray.find(data => data.slotId === slotId);
    if (slotGameData) {
      slotGameData.levelCostResourcesArray.forEach(levelCostResourceEntry => {
        if (levelCostResourceEntry.requiredLevel === 0) {
          // level applies to this levelCostResourceEntry
          const resultResourceEntry = result.find(data => data.resourceId === levelCostResourceEntry.resourceId);
          const amountOfResource = levelCostResourceEntry.baseValue;
          if (resultResourceEntry) {
            // resource is already in the result array - update it
            resultResourceEntry.amount += amountOfResource;
          } else {
            // resource doesn't exist in result - add it
            const resultNewEntry: ResourcesSaveStruc = {
              resourceId: levelCostResourceEntry.resourceId,
              amount: amountOfResource,
            };
            result.push(resultNewEntry);
          };
        } else {
          // either too low or too high level for levelCostResourceEntry to apply - skip
        };
      });
    } else {
      console.log(`PlayerManager:getSlotInitialCost: Cant find slot game data for slot ${slotId}`);
    };

    return result;
  };

  private getSlotLevelCost(slotPlayerData: AreaSlotSaveStruc): ResourcesSaveStruc[] {
    let result: ResourcesSaveStruc[] = [];

    const slotGameData = this.slotGameDataArray.find(data => data.slotId === slotPlayerData.areaSlotId);
    if (slotGameData) {
      slotGameData.levelCostResourcesArray.forEach(levelCostResourceEntry => {
        const slotLevel = this.getSlotLevel(slotPlayerData);
        if (slotLevel >= levelCostResourceEntry.requiredLevel && (levelCostResourceEntry.disabledAtLevel === 0 || slotLevel < levelCostResourceEntry.disabledAtLevel)) {
          // level applies to this levelCostResourceEntry
          const resultResourceEntry = result.find(data => data.resourceId === levelCostResourceEntry.resourceId);
          const amountOfResource = Math.round(hz.clamp(
            levelCostResourceEntry.baseValue * (1 + (slotPlayerData.numberOfUpgrades * levelCostResourceEntry.multiplierPerUpgrade) + (slotLevel * levelCostResourceEntry.multiplierPerLevel))
          ,0,Infinity));
          if (resultResourceEntry) {
            // resource is already in the result array - update it
            resultResourceEntry.amount += amountOfResource;
          } else {
            // resource doesn't exist in result - add it
            const resultNewEntry: ResourcesSaveStruc = {
              resourceId: levelCostResourceEntry.resourceId,
              amount: amountOfResource,
            };
            result.push(resultNewEntry);
          };
        } else {
          // either too low or too high level for levelCostResourceEntry to apply - skip
        };
      });
    } else {
      console.log(`PlayerManager:getSlotLevelCost: Cant find slot game data for slot ${slotPlayerData.areaSlotId}`);
    };

    return result;
  };
  
  private getSlotUpgradeCost(slotPlayerData: AreaSlotSaveStruc): ResourcesSaveStruc[] {
    let result: ResourcesSaveStruc[] = [];

    const slotGameData = this.slotGameDataArray.find(data => data.slotId === slotPlayerData.areaSlotId);
    if (slotGameData) {
      slotGameData.upgradeCostResourcesArray.forEach(upgradeCostResourceEntry => {
        const slotLevel = this.getSlotLevel(slotPlayerData);
        if (slotLevel >= upgradeCostResourceEntry.requiredLevel && (upgradeCostResourceEntry.disabledAtLevel === 0 || slotLevel < upgradeCostResourceEntry.disabledAtLevel)) {
          // level applies to this levelCostResourceEntry
          const resultResourceEntry = result.find(data => data.resourceId === upgradeCostResourceEntry.resourceId);
          const amountOfResource = Math.round(hz.clamp(
            upgradeCostResourceEntry.baseValue * (1 + (slotPlayerData.numberOfUpgrades * upgradeCostResourceEntry.multiplierPerUpgrade) + (slotLevel * upgradeCostResourceEntry.multiplierPerLevel))
          ,0,Infinity));
          if (resultResourceEntry) {
            // resource is already in the result array - update it
            resultResourceEntry.amount += amountOfResource;
          } else {
            // resource doesn't exist in result - add it
            const resultNewEntry: ResourcesSaveStruc = {
              resourceId: upgradeCostResourceEntry.resourceId,
              amount: amountOfResource,
            };
            result.push(resultNewEntry);
          };
        } else {
          // either too low or too high level for upgradeCostResourceEntry to apply - skip
        };
      });
    } else {
      console.log(`PlayerManager:getSlotUpgradeCost: Cant find slot game data for slot ${slotPlayerData.areaSlotId}`);
    };

    return result;
  };

  private getSlotMaxWorkers(slotLevel: number): number {
    let maxWorkers = 0;
    for (let i = 1; i <= slotLevel; i++) {
      maxWorkers += i;
    };
    return maxWorkers;
  };

  private getCountAllAssignedWorkers(slotPlayerDataArray: AreaSlotSaveStruc[]): number {
    let assignedWorkers = 0;

    slotPlayerDataArray.forEach(slotPlayerData => {
      assignedWorkers += slotPlayerData.assignedPop;
    });

    return assignedWorkers;
  }

  private getSlotMaxStorage(slotPlayerData: AreaSlotSaveStruc): ResourcesSaveStruc[] {
    let result: ResourcesSaveStruc[] = [];

    const slotGameData = this.slotGameDataArray.find(data => data.slotId === slotPlayerData.areaSlotId);
    if (slotGameData) {
      slotGameData.storageResourcesArray.forEach(storageResourceEntry => {
        const slotLevel = this.getSlotLevel(slotPlayerData);
        if (slotLevel >= storageResourceEntry.requiredLevel && (storageResourceEntry.disabledAtLevel === 0 || slotLevel < storageResourceEntry.disabledAtLevel)) {
          // level applies to this storageResourceEntry
          const resultResourceEntry = result.find(data => data.resourceId === storageResourceEntry.resourceId);
          const amountOfResource = Math.round(hz.clamp(
            storageResourceEntry.baseValue * (1 + (slotPlayerData.numberOfUpgrades * storageResourceEntry.multiplierPerUpgrade) + (slotLevel * storageResourceEntry.multiplierPerLevel))
          ,0,Infinity));
          if (resultResourceEntry) {
            // resource is already in the result array - update it
            resultResourceEntry.amount += amountOfResource;
          } else {
            // resource doesn't exist in result - add it
            const resultNewEntry: ResourcesSaveStruc = {
              resourceId: storageResourceEntry.resourceId,
              amount: amountOfResource,
            };
            result.push(resultNewEntry);
          };
        } else {
          // either too low or too high level for storageResourceEntry to apply - skip
        };
      });
    } else {
      console.log(`PlayerManager:getSlotMaxStorage: Cant find slot game data for slot ${slotPlayerData.areaSlotId}`);
    };

    return result;
  };

  private modifySlotsResource(slotPlayerDataArray: AreaSlotSaveStruc[], resourceId: number, amount: number): number {
    let remainingAmount = amount;
    const supportedSlots: { playerData: AreaSlotSaveStruc; gameData: AreaSlotDataStruct; storageInfo: SlotResourceStruc }[] = [];

    // Identify slots that support the resource and get their storage info
    for (const playerData of slotPlayerDataArray) {
        const gameData = this.slotGameDataArray.find(data => data.slotId === playerData.areaSlotId);
        if (gameData) {
            const storageInfo = gameData.storageResourcesArray.find(data => data.resourceId === resourceId);
            if (storageInfo) {
                supportedSlots.push({ playerData, gameData, storageInfo });
            }
        }
    }
    //console.log(`PlayerManager:modifySlotsResource: modifying ${amount} of resource to ${supportedSlots.length} slots`);
    if (amount > 0) {
        // Prioritize "empty" slots
        const emptySlots = supportedSlots.filter(slot =>
            slot.playerData.storageArray.find(item => item.resourceId === resourceId)?.amount === 0 ||
            !slot.playerData.storageArray.some(item => item.resourceId === resourceId)
        );
        //console.log(`PlayerManager:modifySlotsResource: adding ${remainingAmount} of resource to ${emptySlots.length} empty slots first`);
        for (const slot of emptySlots) {
            if (remainingAmount <= 0) break;

            const currentLevel = this.getSlotLevel(slot.playerData);
            const maxStorage = Math.round(hz.clamp(
              slot.storageInfo.baseValue * (1 + (slot.playerData.numberOfUpgrades * slot.storageInfo.multiplierPerUpgrade) + (currentLevel * slot.storageInfo.multiplierPerLevel))
            ,0,Infinity));

            let currentAmount = slot.playerData.storageArray.find(item => item.resourceId === resourceId)?.amount || 0;
            const canAdd = Math.min(remainingAmount, maxStorage - currentAmount);

            //console.log(`PlayerManager:modifySlotsResource: slot ${slot.gameData.slotId} try add ${remainingAmount} to storage ${currentAmount} with a max of ${maxStorage}. Can add ${canAdd}`);
            if (canAdd > 0) {
                const existingResource = slot.playerData.storageArray.find(item => item.resourceId === resourceId);
                if (existingResource) {
                    existingResource.amount += canAdd;
                } else {
                    slot.playerData.storageArray.push({ resourceId, amount: canAdd });
                }
                remainingAmount -= canAdd;
            }
        }
        // Distribute remaining amount to other supported slots
        const nonFullSlots = supportedSlots.filter(slot => !emptySlots.includes(slot));
        //console.log(`PlayerManager:modifySlotsResource: adding ${remainingAmount} of resource to ${nonFullSlots.length} non-empty slots second`);

        for (const slot of nonFullSlots) {
            if (remainingAmount <= 0) break;

            const currentLevel = this.getSlotLevel(slot.playerData);
            const maxStorage = Math.round(hz.clamp(
              slot.storageInfo.baseValue * (1 + (slot.playerData.numberOfUpgrades * slot.storageInfo.multiplierPerUpgrade) + (currentLevel * slot.storageInfo.multiplierPerLevel))
            ,0,Infinity));

            let currentAmount = slot.playerData.storageArray.find(item => item.resourceId === resourceId)?.amount || 0;
            const canAdd = Math.min(remainingAmount, maxStorage - currentAmount);
            //console.log(`PlayerManager:modifySlotsResource: slot ${slot.gameData.slotId} try add ${remainingAmount} to storage ${currentAmount} with a max of ${maxStorage}. Can add ${canAdd}`);
            if (canAdd > 0) {
                const existingResource = slot.playerData.storageArray.find(item => item.resourceId === resourceId);
                if (existingResource) {
                    existingResource.amount += canAdd;
                    //console.log(`PlayerManager:modifySlotsResource: Slot ${slot.gameData.slotId} has ${existingResource?.amount} of resource ${existingResource?.resourceId}`);
                } else {
                    slot.playerData.storageArray.push({ resourceId, amount: canAdd });
                }
                remainingAmount -= canAdd;
            }
            
        }
    } else if (amount < 0) {
        const amountToRemove = Math.abs(amount);

        // Prioritize slots with the resource
        const slotsWithResource = supportedSlots.filter(slot =>
            slot.playerData.storageArray.some(item => item.resourceId === resourceId && item.amount > 0)
        );
        // Try to remove from slots that have the full amount (or more than needed) first
        for (const slot of slotsWithResource) {
            if (amountToRemove <= 0) break;

            const existingResource = slot.playerData.storageArray.find(item => item.resourceId === resourceId);
            if (existingResource && existingResource.amount >= amountToRemove) {
                existingResource.amount -= amountToRemove;
                remainingAmount += amountToRemove;
                break; // Removed enough, exit loop
            }
            
        }

        // If not fully removed, remove from other slots with the resource
        if (Math.abs(remainingAmount) < amountToRemove) {
            for (const slot of slotsWithResource) {
                if (amountToRemove <= Math.abs(remainingAmount)) break;

                const existingResource = slot.playerData.storageArray.find(item => item.resourceId === resourceId);
                if (existingResource && existingResource.amount > 0) {
                    const canRemove = Math.min(amountToRemove - Math.abs(remainingAmount), existingResource.amount);
                    existingResource.amount -= canRemove;
                    remainingAmount += canRemove;
                }
            }
        }
    }

    return remainingAmount > 0 ? remainingAmount : Math.abs(remainingAmount);
  };

  private modifySlotWorkers(player: hz.Player, areaId: number, slotId: number, modAmount: number) {
    
    const gameAreaSlot = this.gameSlots.find(data => data.player === player);
    if (gameAreaSlot && gameAreaSlot.gameSlotId == areaId) {
      const playerDataEntry = this.players.find(data => data.player === player);
      if (playerDataEntry && playerDataEntry.offlineProcess <= 0) {
        // are we removing or adding a worker?
        if (modAmount > 0) {
          // adding worker
          // first check if the player has enough unassigned workers
          // get count of all workers assigned already
          let numAssignedWorkers = 0;
          playerDataEntry.saveData.areaSlotData.forEach(slotSaveDataEntry => {
            numAssignedWorkers += slotSaveDataEntry.assignedPop;
          });
          // check if player has unassigned workers
          if (numAssignedWorkers < playerDataEntry.saveData.metaData.currentWorkers) {
            // player has unassigned workers
            const slotPlayerData = playerDataEntry.saveData.areaSlotData.find(data => data.areaSlotId === slotId);
            // does slot have space for a worker
            if (slotPlayerData) {
              const slotGameData = this.slotGameDataArray.find(data => data.slotId === slotId);
              if (slotGameData) {
                const slotLevel = this.getSlotLevel(slotPlayerData);
                if (slotPlayerData.assignedPop < this.getSlotMaxWorkers(slotLevel)) {
                  // slot has space for a worker - add one
                  slotPlayerData.assignedPop += 1;
                } else {
                  // slot doesn't have space for a worker
                  this.sendPlayerNotification(player,14,[],true);
                  this.playSound(2,player);
                }
              } else {
                // error - cant find game config for slot
                this.playSound(2,player);
              };
            } else {
              // error - cant find save data for the slot to mod workers for
              this.playSound(2,player);
            };

          } else {
            // player has no unassigned workers
            this.sendPlayerNotification(player,12,[],true);
            this.playSound(2,player);
          };
        } else {
          // removing worker
          const slotPlayerData = playerDataEntry.saveData.areaSlotData.find(data => data.areaSlotId === slotId);
          if (slotPlayerData) {
            // does slot have assigned workers
            if (slotPlayerData.assignedPop > 0) {
              // slot has workers - remove one
              slotPlayerData.assignedPop -= 1;
            } else {
              // slot has no workers
              this.sendPlayerNotification(player,13,[],true);
              this.playSound(2,player);
            }
          } else {
            // cant find slot player data - does player own the slot?
            this.playSound(2,player);
          }
        };
        this.updateUISlotUIForPlayer(player);
      } else {
        // error - cant find player save data
        this.playSound(2,player);
      };
    } else {
      // cant find game area, or player doesn't own the area
      this.playSound(2,player);
    };
  };

  private onSlotUnlocked(gameAreaSlot: GameSlotStruc, slotId: number) {
    this.sendNetworkEvent( gameAreaSlot.area, unlockSlot, {slotId: slotId} );
    const slotGameData = this.slotGameDataArray.find(data => data.slotId === slotId);
    if (gameAreaSlot.player && slotGameData) {
      this.sendPlayerNotification(gameAreaSlot.player,7,[slotGameData.name],true);
    };
  };

  private onSlotLevelUp(gameAreaSlot: GameSlotStruc, slotId: number, slotLevel: number) {
    console.log(`PlayerManager:onSlotLevelUp - slot ${slotId} is level ${slotLevel}`);

    this.sendNetworkEvent( gameAreaSlot.area, levelUpSlot, {slotId: slotId, level: slotLevel} );
    const slotGameData = this.slotGameDataArray.find(data => data.slotId === slotId);
    if (gameAreaSlot.player && slotGameData) {
      if (slotLevel === 1) {
        this.sendPlayerNotification(gameAreaSlot.player,8,[slotGameData.name],true);
      } else {
        this.sendPlayerNotification(gameAreaSlot.player,9,[slotGameData.name, slotLevel.toString()],true);
      };
    };

    // check if any other slot needs to be unlocked
    let slotsToUnlock: number[] = [];
    const playerSaveData = this.players.find(data => data.player === gameAreaSlot.player);
    if (playerSaveData) {
      this.slotGameDataArray.forEach(slotGameDataEntry => {
        if (!slotGameDataEntry.startsUnlocked && !slotGameDataEntry.startsPurchased && slotGameDataEntry.unlockedBySlotArray.length === 2) {
          if (slotGameDataEntry.unlockedBySlotArray[0] === slotId && slotGameDataEntry.unlockedBySlotArray[1] <= slotLevel) {
            slotsToUnlock.push(slotGameDataEntry.slotId);
          };
        } else {
          // slot starts unlocked/purchased or has invalid unlockedBySlotArray
        };
      });
    } else {
      // cant find player save data
      console.log(`PlayerManager:onSlotLevelUp: Cant find player save data for player ${gameAreaSlot.player?.name.get()}`);
    };

    slotsToUnlock.forEach(slotToUnlock => {
      this.onSlotUnlocked(gameAreaSlot, slotToUnlock);
    });
  };

  private tryBuySlot(player: hz.Player, areaId: number, slotId: number): boolean {
    // "trybuy" should be used for everything - initial purchase/upgrading/levelling up
    console.log(`PlayerManager:tryBuySlot: Player ${player?.name.get().toString()} is buying or upgrading area:slot - ${areaId}:${slotId}`);
    const isUnlockedData = this.isSlotUnlocked(player,slotId);
    const slotGameDataEntry = this.slotGameDataArray.find(data => data.slotId === slotId);
    if (isUnlockedData && isUnlockedData[0] === false) {
      if (slotGameDataEntry) {
        const unlockedBySlotGameDataEntry = this.slotGameDataArray.find(data => data.slotId === isUnlockedData[1]);
        if (unlockedBySlotGameDataEntry){
          this.sendPlayerNotification(player,3,[slotGameDataEntry.name,unlockedBySlotGameDataEntry.name],true);
          this.playSound(2,player);
        };
      };
      return false;
    };
    let success = false;

    const gameAreaSlot = this.gameSlots.find(data => data.player === player);
    if (gameAreaSlot && gameAreaSlot.gameSlotId == areaId) {
      const playerDataEntry = this.players.find(data => data.player === player);
      if (playerDataEntry && playerDataEntry.offlineProcess <= 0) {
        const slotPlayerData = playerDataEntry.saveData.areaSlotData.find(data => data.areaSlotId === slotId);
        let tryBuyIsLevelUp = false; // boolean to track if this is a level up or not

        // first get the cost of the try buy action

        let resourceCostArray: ResourcesSaveStruc[] = [];
        if (slotPlayerData === undefined) {
          // try buy the initial slot purchase
          resourceCostArray = this.getSlotInitialCost(slotId);
          tryBuyIsLevelUp = true;
        } else {
          if (slotGameDataEntry) {
            const slotLevel = this.getSlotLevel(slotPlayerData);
            //console.log(`PlayerManager:tryBuySlot: resource cost calc - slot ${slotId} - level ${slotLevel} number of upgrades current ${slotPlayerData.numberOfUpgrades}`);
            if (slotLevel > slotGameDataEntry.upgradesPerLevelArray.length) {
              resourceCostArray = this.getSlotUpgradeCost(slotPlayerData);
              //console.log(`PlayerManager:tryBuySlot: resource cost calc - over max level - try buy is upgrade ${slotId}`);

            } else {
              let numUpgradesReqForLevelUp = 0;
              for (let i = 0; i < slotLevel; i++) {
                numUpgradesReqForLevelUp += slotGameDataEntry.upgradesPerLevelArray[i] ? slotGameDataEntry.upgradesPerLevelArray[i] : 0;
              };
              if (numUpgradesReqForLevelUp > slotPlayerData.numberOfUpgrades) {
                // there isn't enough upgrades to level up or the slot is past max level - try buy is an upgrade
                resourceCostArray = this.getSlotUpgradeCost(slotPlayerData);
                //console.log(`PlayerManager:tryBuySlot: resource cost calc - need ${numUpgradesReqForLevelUp} upgrades to lvl - not enough upgrades to level - try buy is upgrade ${slotId}`);
              } else {
                // there is enough upgrades to level up - try buy is a level up
                resourceCostArray = this.getSlotLevelCost(slotPlayerData);
                tryBuyIsLevelUp = true;
                
                //console.log(`PlayerManager:tryBuySlot: resource cost calc - try buy is level up ${slotId}`);
              };
            };
          } else {
            //console.log(`PlayerManager:tryBuySlot: 1 Cant find slot game data entry for slot ${slotId}`);
          };
        };

        // now check if the player has enough resources to do the try buy action

        let hasAllResourcesForTryBuy = false;
        for (let i = 0; i < resourceCostArray.length; i++) {
          const resourceCostEntry = resourceCostArray[i];
          if (resourceCostEntry) {
            const playerResourceEntry = playerDataEntry.saveData.resourcesData.find(data => data.resourceId === resourceCostEntry.resourceId);
            if (playerResourceEntry) {
              // player owns the resource - check if they have enough
              if (playerResourceEntry.amount >= resourceCostEntry.amount) {
                // player has enough of this resource
                hasAllResourcesForTryBuy = true;
              } else {
                // player doesn't have enough of this resource
                hasAllResourcesForTryBuy = false;
                break;
              };

            } else {
              // player doesn't own the resource
              hasAllResourcesForTryBuy = false;
              break;
            };
          };
        };

        if (hasAllResourcesForTryBuy) {
          // remove resources
          resourceCostArray.forEach(resourceCostEntry => {
            this.modifyPlayerResource(player,resourceCostEntry.resourceId,-resourceCostEntry.amount);
          });

          // now do the try buy
          if (tryBuyIsLevelUp) {
            if (slotPlayerData === undefined) {
              // initial buy - add default data
              console.log(`PlayerManager:tryBuySlot: slot initial buy ${slotId}`);
              let initialSlotData: AreaSlotSaveStruc = {
                areaSlotId: slotId,
                numberOfUpgrades: 0,
                assignedPop: 0,
                storageArray: [],
              }
              const slotGameDataEntry = this.slotGameDataArray.find(data => data.slotId === slotId);
              if (slotGameDataEntry) {
                slotGameDataEntry.storageResourcesArray.forEach(slotStorage => {
                  const existingStorageEntry = initialSlotData.storageArray.find(data => data.resourceId ===  slotStorage.resourceId);
                  if (existingStorageEntry === undefined) {
                    const slotStorageEntry: ResourcesSaveStruc = {
                      resourceId: slotStorage.resourceId,
                      amount: 0,
                    }
                    initialSlotData.storageArray.push(slotStorageEntry);
                  };
                });
                playerDataEntry.saveData.areaSlotData.push(initialSlotData);
                this.onSlotLevelUp(gameAreaSlot, slotId, 1);
                this.playSound(3,player);
                this.modifyPlayerStat(player,12,1);
              } else {
                // cant find slot game data
                console.log(`PlayerManager:tryBuySlot: Cant find slot game data entry to initial buy slot ${slotId}`);
                this.playSound(2,player);
              }
            } else {
              // levelling up - edit existing data
              slotPlayerData.numberOfUpgrades += 1;
              const slotLevel = this.getSlotLevel(slotPlayerData);
              console.log(`PlayerManager:tryBuySlot: slot level up slotid:numUpgrades:level ${slotId}:${slotPlayerData.numberOfUpgrades}:${slotLevel}`);
              this.onSlotLevelUp(gameAreaSlot, slotId, slotLevel);
              this.playSound(5,player);
              this.modifyPlayerStat(player,12,1);
            };

          } else {
            // upgrading
            if (slotPlayerData) {
              slotPlayerData.numberOfUpgrades += 1;
              this.playSound(4,player);
              console.log(`PlayerManager:tryBuySlot: slot upgrade ${slotId}:${slotPlayerData.numberOfUpgrades}`);
              this.modifyPlayerStat(player,12,1);
            } else {
              console.log(`PlayerManager:tryBuySlot: Cant find slot player data entry to upgrade slot ${slotId}`);
              this.playSound(2,player);
            };
          };
          this.updateUISlotUIForPlayer(player);
        } else {
          console.log(`PlayerManager:tryBuySlot: Cant afford trybuy ${slotId}`);
          this.sendPlayerNotification(player,4,[],true);
          this.playSound(2,player);
        };

      } else {
        console.log(`PlayerManager:tryBuySlot: Cant find player data entry for player ${player?.name.get().toString()} or they are still processing offline`);
        this.sendPlayerNotification(player,5,[],true);
        this.playSound(2,player);
      };
    } else {
      console.log(`PlayerManager:tryBuySlot: Cant find game slot for player ${player?.name.get().toString()} or player doesn't own this area.`);
      this.playSound(2,player);
    };
    return success;
  };

  private takeFromSlotStorage(player: hz.Player, areaId: number, slotId: number) {
    console.log(`PlayerManager:takeFromSlotStorage: ${player.name.get()} wants to take from slot ${slotId}`)
    const gameSlotEntry = this.gameSlots.find(data => data.player === player);
    if (gameSlotEntry && gameSlotEntry.gameSlotId === areaId) {
      const playerDataEntry = this.players.find(data => data.player === player);
      if (playerDataEntry && playerDataEntry.offlineProcess <= 0) {
        const playerSlotDataEntry = playerDataEntry.saveData.areaSlotData.find(data => data.areaSlotId === slotId);
        if (playerSlotDataEntry) {
          const resourcesToTake: ResourcesSaveStruc[] = [];
          playerSlotDataEntry.storageArray.forEach(storageEntry => {
            const existingResourceEntry = resourcesToTake.find(data => data.resourceId === storageEntry.resourceId);
            if (existingResourceEntry) {
              // resource entry exists - update it
              existingResourceEntry.amount += storageEntry.amount;
            } else {
              // resource entry doesn't exist - add a new one
              const newResourceEntry: ResourcesSaveStruc = {
                resourceId: storageEntry.resourceId,
                amount: storageEntry.amount,
              };
              resourcesToTake.push(newResourceEntry);
            };
            storageEntry.amount = 0;
          });

          resourcesToTake.forEach(resourceToTakeEntry => {
            this.modifyPlayerResource(player,resourceToTakeEntry.resourceId,resourceToTakeEntry.amount);
          });

          this.updateUISlotUIForPlayer(player);
        } else {
          // cant find slot data for player - they havent purchased it yet?
        };
      } else {
        // cant find player save data
      };
    } else {
      // cant find game slot for player, or player does not own the area
    };
  };

  private isSlotUnlocked(player: hz.Player, slotId: number): [boolean, number] {
    let isUnlocked = false;
    let unlockedBySlotId = 0;

    const playerSaveData = this.players.find(data => data.player === player);
    if (playerSaveData) {
      const testSlotGameData = this.slotGameDataArray.find(data => data.slotId === slotId);
      if (testSlotGameData) {
        if (!testSlotGameData.startsUnlocked && !testSlotGameData.startsPurchased && testSlotGameData.unlockedBySlotArray.length === 2) {
          const _unlockedBySlotId = testSlotGameData.unlockedBySlotArray[0], unlockedAtLevel = testSlotGameData.unlockedBySlotArray[1];
          const unlockedBySlotSaveData = playerSaveData.saveData.areaSlotData.find(data => data.areaSlotId === _unlockedBySlotId);
          if (unlockedBySlotSaveData) {
            const targetSlotLevel = this.getSlotLevel(unlockedBySlotSaveData);
            if (targetSlotLevel >= unlockedAtLevel) {
              isUnlocked = true;
            };
          } else {
            // player doesn't have savedata for the required slot - so return false
            isUnlocked = false;
            unlockedBySlotId = _unlockedBySlotId;
          };
        } else {
          // slot starts unlocked or purchased - or it has invalid unlockedBySlotArray - return true
          isUnlocked = true;
        };
      } else {
        console.log(`PlayerManager:isSlotUnlocked: Cant find slot game data for slot ${slotId}`);
      };
    } else {
      // cant find player save data
      console.log(`PlayerManager:isSlotUnlocked: Cant find player save data for player ${player?.name.get()}`);
    };

    return [isUnlocked, unlockedBySlotId];
  };

  private processSlotsForPlayer(playerSaveDataEntry: PlayerDataStruc, usePlayerResource: boolean): boolean {
    let anythingProduced = false;
    let availableResources: ResourceProcessData[] = [];
    // to process slots, first we need to get the total number of resources available for the slots to use & we need to get the total storages the slots can deposit into
    // we have a dedicated type for this - ResourceProcessData - first lets loop through the resource game data and grab the values the player and slots have
    this.resourceGameDataArray.forEach(resourceGameDataEntry => {
      let availableResourceEntry: ResourceProcessData = {
        resourceId: resourceGameDataEntry.resourceId,
        playerCurrentAmount: 0,
        slotsCurrentAmount: 0,
        slotsMaxStorage: 0,
      };
      // now get player resources
      const playerCurrentResource = playerSaveDataEntry.saveData.resourcesData.find(data => data.resourceId === resourceGameDataEntry.resourceId);
      if (playerCurrentResource && (playerCurrentResource.resourceId == 1 || usePlayerResource)) {
        availableResourceEntry.playerCurrentAmount = playerCurrentResource.amount;
      } else {
        // no resource entry in player data
        //console.log(`PlayerManager:processSlotsForPlayer: Player ${areaSlot.player?.name.get()} has no entry for resource ${resourceGameDataEntry.resourceId}`);
      };
      // now get slot resources
      playerSaveDataEntry.saveData.areaSlotData.forEach(slotSaveDataEntry => {
        const slotCurrentResource = slotSaveDataEntry.storageArray.find(data => data.resourceId === resourceGameDataEntry.resourceId);
        if (slotCurrentResource) {
          availableResourceEntry.slotsCurrentAmount += slotCurrentResource.amount;
        } else {
          // no resource entry in slot data
          //console.log(`PlayerManager:processSlotsForPlayer: Slot ${slotSaveDataEntry.areaSlotId} has no entry for resource ${resourceGameDataEntry.resourceId}`);
        }
        // and slot storages - first get the slot game data
        const slotGameDataEntry = this.slotGameDataArray.find(data => data.slotId === slotSaveDataEntry.areaSlotId);
        if (slotGameDataEntry) {
          // now get the slot's current level (numUpgrades against upgrades per level array)
          let slotCurrentLevel = this.getSlotLevel(slotSaveDataEntry);
          // now get the storage entry for this resource
          const slotStorageEntry = slotGameDataEntry.storageResourcesArray.find(data => data.resourceId === resourceGameDataEntry.resourceId);
          if (slotStorageEntry) {
            // if the slot meets the level requirement to enable this storage
            //console.log(`PlayerManager:processSlotsForPlayer: Slot ${slotGameDataEntry.slotId} is at level ${slotCurrentLevel}`);
            if (slotStorageEntry.requiredLevel <= slotCurrentLevel) {
              // add the max storage value to the ResourceProcessData entry
              const addAmount = Math.round(hz.clamp(
                slotStorageEntry.baseValue * (1 + (slotSaveDataEntry.numberOfUpgrades * slotStorageEntry.multiplierPerUpgrade) + (slotCurrentLevel * slotStorageEntry.multiplierPerLevel))
              ,0,Infinity));
              //console.log(`PlayerManager:processSlotsForPlayer: Slot ${slotGameDataEntry.slotId} is at level ${slotCurrentLevel} and can store ${addAmount} of resource ${resourceGameDataEntry.resourceId}`);
              availableResourceEntry.slotsMaxStorage += addAmount;
            } else {
              //console.log(`PlayerManager:processSlotsForPlayer: Slot ${slotSaveDataEntry.areaSlotId} has storage for resource ${resourceGameDataEntry.resourceId}, but is not high enough level`);
            }
          } else {
            //console.log(`PlayerManager:processSlotsForPlayer: Slot ${slotSaveDataEntry.areaSlotId} has no storage for resource ${resourceGameDataEntry.resourceId}`);
          }
        } else {
          console.log(`PlayerManager:processSlotsForPlayer: 1 Cant find slot game data for slot ${slotSaveDataEntry.areaSlotId}`);
        }
      });

      // end of loop - add the ResourceProcessData entry to the array
      availableResources.push(availableResourceEntry);
    });
    // now we have an array of ResourceProcessData that lists the players resources, the slots current resources, and the slots max storages
    //console.log(`PlayerManager:processSlotsForPlayer: Processing ${availableResources.length} resources in ${playerSaveDataEntry.saveData.areaSlotData.length} slots`);
    // go through each slot again
    playerSaveDataEntry.saveData.areaSlotData.forEach(slotSaveDataEntry => {
      const slotGameDataEntry = this.slotGameDataArray.find(data => data.slotId === slotSaveDataEntry.areaSlotId);
      if (slotGameDataEntry) {
        const slotCurrentLevel = this.getSlotLevel(slotSaveDataEntry);
        // does this slot produce resources?
        if (slotGameDataEntry.producedResourcesArray.length > 0) {
          const isSlotSupervised = playerSaveDataEntry.supervisedSlotId === slotSaveDataEntry.areaSlotId ? true : false;
          const upkeepReqArray = this.getSlotUpkeepResources(slotSaveDataEntry,isSlotSupervised);
          const producedResourcesArray = this.getSlotProducedResources(slotSaveDataEntry,isSlotSupervised);
          let canProduce = true;

          // do upkeep check
          for (let index = 0; index < upkeepReqArray.length; index++) {
            const upkeepReqEntry = upkeepReqArray[index];
            const availableResourceEntry = availableResources.find(data => data.resourceId === upkeepReqEntry.resourceId);
            if (availableResourceEntry) {
              if (upkeepReqEntry.amount > availableResourceEntry.slotsCurrentAmount + availableResourceEntry.playerCurrentAmount) {
                // player & slots don't have enough resources to produce this slot's output
                //console.log(`PlayerManager:processSlotsForPlayer: Slot ${slotGameDataEntry.slotId} doesn't have the upkeep to produce`);
                canProduce = false;
                if (!playerSaveDataEntry.slotsLastCycleWasDry.find(drySlotId => drySlotId === slotSaveDataEntry.areaSlotId)) {
                  this.sendPlayerNotification(playerSaveDataEntry.player,10,[slotGameDataEntry.name]);
                  playerSaveDataEntry.slotsLastCycleWasDry.push(slotSaveDataEntry.areaSlotId);
                };
                break; // break because we cant produce anyway
              } else {
                // slot storage has enough resources for upkeep to produce this slot's output
              };
            } else {
              console.log(`PlayerManager:processSlotsForPlayer: 1 Cant find available resource for resource ${upkeepReqEntry.resourceId}`);
            };
          };

          // do storage check
          if (canProduce) {
            for (let index = 0; index < producedResourcesArray.length; index++) {
              const producedResourceEntry = producedResourcesArray[index];
              const availableResourceEntry = availableResources.find(data => data.resourceId === producedResourceEntry.resourceId);
              if (availableResourceEntry) {
                //console.log(`PlayerManager:processSlotsForPlayer: Slot storage resource ${producedResourceEntry.resourceId} - ${availableResourceEntry.slotsCurrentAmount}/${availableResourceEntry.slotsMaxStorage}`);
                if (availableResourceEntry.slotsMaxStorage <= availableResourceEntry.slotsCurrentAmount) {
                  // slot storage is full
                  //console.log(`PlayerManager:processSlotsForPlayer: Slot ${slotGameDataEntry.slotId} cant produce due to no storage space`);
                  canProduce = false;
                  if (!playerSaveDataEntry.slotsLastCycleWasDry.find(drySlotId => drySlotId === slotSaveDataEntry.areaSlotId)) {
                    this.sendPlayerNotification(playerSaveDataEntry.player,11,[slotGameDataEntry.name]);
                    playerSaveDataEntry.slotsLastCycleWasDry.push(slotSaveDataEntry.areaSlotId);
                  };
                  break; // break because we cant produce anyway
                } else {
                  // slot storage has enough space to produce this slot's output
                };
              } else {
                console.log(`PlayerManager:processSlotsForPlayer: 2 Cant find available resource for resource ${producedResourceEntry.resourceId}`);
              };
            };
          };

          // if we can produce, then update values
          if (canProduce) {
            //console.log(`PlayerManager:processSlotsForPlayer: Slot ${slotGameDataEntry.slotId} can produce resources`);
            // remove upkeep resources from slot & player storage
            if (upkeepReqArray.length > 0) {
              upkeepReqArray.forEach(upkeepReqEntry => {
                // remove from slots
                const remainderToRemove = this.modifySlotsResource(playerSaveDataEntry.saveData.areaSlotData,upkeepReqEntry.resourceId,-upkeepReqEntry.amount);
                if (remainderToRemove > 0 && (upkeepReqEntry.resourceId == 1 || usePlayerResource)) {
                  // remove remainder from player
                  this.modifyPlayerResource(playerSaveDataEntry.player,upkeepReqEntry.resourceId,-remainderToRemove);
                };
              });
            };

            // add produced resources to slot storage
            producedResourcesArray.forEach(producedResourceEntry => {
              //console.log(`PlayerManager:processSlotsForPlayer: Adding ${producedResourceEntry.amount} of resource ${producedResourceEntry.resourceId} to slot storages`);
              this.modifySlotsResource(playerSaveDataEntry.saveData.areaSlotData,producedResourceEntry.resourceId,producedResourceEntry.amount);
            });
            anythingProduced = true;
            if (playerSaveDataEntry.slotsLastCycleWasDry.find(drySlotId => drySlotId === slotSaveDataEntry.areaSlotId)) {
              playerSaveDataEntry.slotsLastCycleWasDry = playerSaveDataEntry.slotsLastCycleWasDry.filter(drySlotId => drySlotId !== slotSaveDataEntry.areaSlotId);
            };
            //console.log(`PlayerManager:processSlotsForPlayer: Slot ${slotGameDataEntry.slotId} was able to produce`);
          } else {
            // slot is not able to produce - skip the slot
            //console.log(`PlayerManager:processSlotsForPlayer: Slot ${slotGameDataEntry.slotId} didn't produce`);
          };

        } else {
          // slot doesn't produce resources - skip the slot
        };
      } else {
        console.log(`PlayerManager:processSlotsForPlayer: 2 Cant find slot game data for slot ${slotSaveDataEntry.areaSlotId}`);
      };
    });
    return anythingProduced;
  };

  // Tutorial stuff

  private triggerTutorialStep(playerData: PlayerDataStruc) {
    console.log(`PlayerManager:doTutorialStep: Do tutorial at step ${playerData.saveData.metaData.tutorialStep} ${playerData.player.name.get().toString()}`);
  };

  // Trader stuff

  private initTrader() {
    console.log(`PlayerManager:initTrader: Setup trader`);

    // setup trader prices
    this.resourceGameDataArray.forEach(resourceData => {
      if (resourceData.traderPrice && resourceData.traderPrice > 0) {
        const traderPriceEntry: TraderResourceStruc = {
          resourceId: resourceData.resourceId,
          currentPrice: resourceData.traderPrice,
          lastPriceChangePositive: true,
          lastEventUnstable: false,
        };
        this.traderPriceData.push(traderPriceEntry);
      } else {
        // resource does not have a trader price
      };
    });

  };

  private traderSellResource(player: hz.Player, resourceId: number, sellAmount: number, sellValue: number) {
    console.log(`PlayerManager:traderSellResourceByPercent: Player ${player.name.get()} wants to sell ${sellAmount} of resource ${resourceId} at ${sellValue}`);

    const playerData = this.players.find(data => data.player === player) ;
    if (playerData && playerData.offlineProcess <= 0) {
      const playerResource = playerData.saveData.resourcesData.find(data => data.resourceId === resourceId);
      if (playerResource) {
        console.log(`PlayerManager:traderSellResource: ${player.name.get()} has ${playerResource.amount} in total available`);
        if (sellAmount > 0 && playerResource.amount > 0 && sellValue > 0) {
          const amountToSell = Math.floor((playerResource.amount < sellAmount) ? playerResource.amount : sellAmount);
          const totalValue = Math.floor(amountToSell * sellValue);

          this.modifyPlayerResource(player,resourceId,-amountToSell);
          this.modifyPlayerResource(player,1,totalValue);

          this.modifyTraderPriceForResource(resourceId,amountToSell);

          this.updateUITraderUI("prices",undefined);
          this.updateUITraderUI("resources",player);
          this.playSound(6,player);

        } else {
          // player tried to sell 0 or has 0 in their resource pool
          console.log(`PlayerManager:traderSellResource: ${player.name.get()} tried to sell 0, or at 0, or has 0`);
          this.playSound(2,player);
        };
      } else {
        // player doesnt own the resource
        console.log(`PlayerManager:traderSellResource: Player doesnt own resource to sell ${player.name.get()}`);
        this.playSound(2,player);
      };
    } else {
      // cant find player data
      console.log(`PlayerManager:traderSellResource: Cant find player data for player ${player.name.get()}`);
      this.playSound(2,player);
    };

  };

  private getPlayersAtTrader(): hz.Player[] {
    let playersAtTrader: hz.Player[] = [];

    this.players.forEach(playerData => {
      if (playerData.isAtTrader) {
        playersAtTrader.push(playerData.player);
      };
    });

    return playersAtTrader;
  };

  private modifyTraderPriceForResource(resourceId: number, volumeChange: number) {
    const traderPriceEntry = this.traderPriceData.find(data => data.resourceId === resourceId);
    if (traderPriceEntry) {
      const resourceGameDataEntry = this.resourceGameDataArray.find(data => data.resourceId === resourceId);
      if (resourceGameDataEntry) {
        const newPrice = hz.clamp(
          traderPriceEntry.currentPrice / (1 + (volumeChange / resourceGameDataEntry.traderRefVolume) * resourceGameDataEntry.traderPlayerInfluence),
          resourceGameDataEntry.traderMinPrice,
          resourceGameDataEntry.traderMaxPrice
        );

        traderPriceEntry.currentPrice = newPrice;
        traderPriceEntry.lastPriceChangePositive = false;
      } else {
        // cant find resource game data
      };
      
    } else {
      // couldn't find resource in trader prices array
    };
  };

  // Saloon stuff

  private tryBuyWorker(player: hz.Player): boolean {
    let success = false;
    const playerDataEntry = this.players.find(data => data.player === player);
    if (playerDataEntry && playerDataEntry.offlineProcess <= 0) {
      const availableWorkers = playerDataEntry.saveData.metaData.totalWorkers - playerDataEntry.saveData.metaData.currentWorkers;
      if (availableWorkers > 0) {
        const hireCost = Math.floor(this.props.workerBasePrice * (this.props.workerPriceExponent ** playerDataEntry.saveData.metaData.currentWorkers));
        const playerCoinsEntry = playerDataEntry.saveData.resourcesData.find(data => data.resourceId === 1);
        if (playerCoinsEntry) {
          if (playerCoinsEntry.amount >= hireCost) {
            this.modifyPlayerResource(player,1,-hireCost);
            playerDataEntry.saveData.metaData.currentWorkers += 1;
            this.updateUISaloonUI(player);
            this.playSound(7,player);
            console.log(`PlayerManager:tryBuyWorker: ${player.name.get()} hired a worker for ${hireCost} coins, they now have ${playerDataEntry.saveData.metaData.currentWorkers} workers.`);
          } else {
            // player has coins, but not enough
            this.sendPlayerNotification(player,4,[]);
            this.playSound(2,player);
          }
        } else {
          // player has no coins
          this.sendPlayerNotification(player,4,[]);
          this.playSound(2,player);
        };
      } else {
        // no workers available
        console.log(`PlayerManager:tryBuyWorker: ${player.name.get()} has no available workers to hire.`);
        this.sendPlayerNotification(player,6,[]);
        this.playSound(2,player);
      };
    } else {
      // cant find player data entry
      this.playSound(2,player);
    };
    return success;
  };

  // Statistics
  private modifyPlayerStat(player: hz.Player, statId: number, modifyAmount: number) {
    const playerData = this.players.find(data => data.player === player);
    if (playerData) {
      const statGameData = this.statisticsGameData.find(data => data.statId === statId);
      if (statGameData) {
        let playerStatData = playerData.saveData.statistics.find(data => data.statId === statId);
        if (playerStatData) {
          // stat exists, update it
          playerStatData.value = playerStatData.value + modifyAmount;
        } else {
          // stat doesn't exist, add it
          playerStatData = {
            statId: statId,
            value: modifyAmount,
          };
          playerData.saveData.statistics.push(playerStatData);
        };
        if (statGameData.leaderboard) {
          this.updateLeaderboardPlayerValue(player,statGameData.leaderboard,playerStatData.value);
        };
      } else {
        // cant find stat game data
      };
    } else {
      // cant find player data
    };
  };

  private updateLeaderboardPlayerValue(player: hz.Player, leaderboard: string, newValue: number) {
    console.log(`PlayerManager:updateLeaderboardPlayerValue: Set leaderboard ${leaderboard} to ${newValue} for ${player.name.get()}.`);
    this.world.leaderboards.setScoreForPlayer(leaderboard, player, newValue, true);
  };

  // Sound

  private playSound(soundId: number, player?: hz.Player) {
    this.sendNetworkBroadcastEvent(playSound, {
      soundId,
      player,
    });
  };

  // UI outgoing events

  // // Slots UI

  private updateUISlotUIForAllPlayers() {
    this.gameSlots.forEach(gameSlot => {
      if (gameSlot.player !== undefined) {
        const playerData = this.players.find(data => data.player === gameSlot.player);
        if (playerData) {
          if (playerData.visibleSlotUIs.length > 0) {
            playerData.visibleSlotUIs.forEach(slotId => {
              if (gameSlot.player !== undefined) {
                this.updateUISlotUI(gameSlot.player, gameSlot.gameSlotId, slotId, undefined);
              };
            });
          };
        } else {
          // cant find player data
        };
      };
    });
  };

  private updateUISlotUIForPlayer(player: hz.Player) {
    const gameSlot = this.gameSlots.find(data => data.player === player);
    if (gameSlot) {
      const playerData = this.players.find(data => data.player === player);
      if (playerData) {
        if (playerData.visibleSlotUIs.length > 0) {
          playerData.visibleSlotUIs.forEach(slotId => {
            if (gameSlot.player !== undefined) {
              this.updateUISlotUI(player, gameSlot.gameSlotId, slotId, undefined);
            };
          });
        };
      } else {
        // cant find player's data
      };
    } else {
      // cant find player's game slot
    };
  };

  private updateUISlotUI(player: hz.Player, areaId: number, slotId: number, uiPosEntity: hz.Entity | undefined) {
    
    const areaSlot = this.gameSlots.find(data => data.player === player);

    if (areaSlot && areaSlot.gameSlotId === areaId) {
      const playerData = this.players.find(data => data.player === player);
      if (playerData) {
        const slotGameData = this.slotGameDataArray.find(data => data.slotId === slotId);
        if (slotGameData) {
          let slotSaveData = playerData.saveData.areaSlotData.find(data => data.areaSlotId === slotId);
          //console.log(`PlayerManager:updateUISlotUI:sendUIUpdate:updateSlot${slotId}: show slot ui`);
          let slotSaveDataUI: SlotUISaveDataStruc = {
            level: 0,
            upgrades: 0,
            curWorkers: 0,
            maxWorkers: 0,
            nextBuyLvlUp: true,
            costResources: [],
            upkeepResources: [],
            productionResources: [],
            currentStorageResources: [],
            maxStorageResources: [],

          };

          const slotGameDataUI: SlotUIGameDataStruc = {
            name: slotGameData.name,
            techString: "",
            statsForFun: "",
          };

          let slotLevel = 0
          if (slotSaveData) {
            
            slotLevel = this.getSlotLevel(slotSaveData);
            let nextBuyIsLevelUp = true;
            if (slotLevel > slotGameData.upgradesPerLevelArray.length) {
              nextBuyIsLevelUp = false;
            } else {
              let numUpgradesReqForLevelUp = 0;
              for (let i = 0; i < slotLevel; i++) {
                numUpgradesReqForLevelUp += slotGameData.upgradesPerLevelArray[i] ? slotGameData.upgradesPerLevelArray[i] : 0;
              };
              if (numUpgradesReqForLevelUp > slotSaveData.numberOfUpgrades) {
                nextBuyIsLevelUp = false;
              } else {
                nextBuyIsLevelUp = true;
              };
            };
            slotSaveDataUI.level = slotLevel;
            slotSaveDataUI.upgrades = slotSaveData.numberOfUpgrades;
            slotSaveDataUI.curWorkers = slotSaveData.assignedPop;
            slotSaveDataUI.maxWorkers = this.getSlotMaxWorkers(slotLevel);
            slotSaveDataUI.nextBuyLvlUp = nextBuyIsLevelUp;
            slotSaveDataUI.costResources = nextBuyIsLevelUp ? this.getSlotLevelCost(slotSaveData) : this.getSlotUpgradeCost(slotSaveData);
            slotSaveDataUI.currentStorageResources = slotSaveData.storageArray;

            
            slotGameDataUI.techString = slotGameData.techStringsArray?.[slotLevel - 1];
            slotGameDataUI.statsForFun = slotGameData.statsForFunString.replace(/#(\d+)#/g, (match, index) => {
              const i = parseInt(index, 10);
              const statValue = slotGameData.statsForFunValuesArray[i-1]
              return (statValue !== undefined && slotSaveData?.numberOfUpgrades !== undefined) ? (statValue * slotSaveData.numberOfUpgrades).toString() : match;
            });
            //console.log(`PlayerManager:updateUISlotUI: ${slotGameDataUI.statsForFun}`);
          } else {
            //console.log(`PlayerManager:updateUISlotUI: Cant find save data for slot ${slotId}`);
            // cant find slot save data in player data
            slotSaveData = {
              areaSlotId: slotId,
              numberOfUpgrades: 0,
              assignedPop: 0,
              storageArray: [],
            };
            slotSaveDataUI.costResources = this.getSlotInitialCost(slotId);
          };

          const isSupervised = (playerData.supervisedSlotId === slotId);
          slotSaveDataUI.upkeepResources = this.getSlotUpkeepResources(slotSaveData, isSupervised);
          slotSaveDataUI.productionResources = this.getSlotProducedResources(slotSaveData, isSupervised);
          slotSaveDataUI.maxStorageResources = this.getSlotMaxStorage(slotSaveData);
            
          let slotUIData: SlotUIDataStruc = {
            visible: true,
            areaId: areaId,
            slotId: slotId,
            uiPos: uiPosEntity?.position.get(),
            uiRot: uiPosEntity?.rotation.get(),
            slotGameData: slotGameDataUI,
            slotSaveData: slotSaveDataUI,
          }
          this.sendNetworkBroadcastEvent(sendUIUpdate, {
            player,
            uiName: 'Slot',
            eventName: 'updateSlot',
            payload: slotUIData,
          });

        } else {
          console.log(`PlayerManager:updateUISlotUI: Cant find game data for slot ${slotId}`);
          // cant find slot game data
        };
      } else {
        console.log(`PlayerManager:updateUISlotUI: Cant find save data for player ${player.name.get()}`);
        // cant find player data
      };
    } else {
      console.log(`PlayerManager:updateUISlotUI: Cant find are or player doesn't own area`);
      // cant find game area or player doesn't own it
    };
  };

  private hideUISlotUIForPlayer(player: hz.Player, areaId: number, slotId: number) {
    
    const areaSlot = this.gameSlots.find(data => data.player === player);

    if (areaSlot && areaSlot.gameSlotId === areaId) {

      let slotUIData: SlotUIDataStruc = {
        visible: false,
        areaId: areaId,
        slotId: slotId,
      };
      this.sendNetworkBroadcastEvent(sendUIUpdate, {
        player,
        uiName: 'Slot',
        eventName: 'updateSlot',
        payload: slotUIData,
      });
    };
  };

  private focusSlotUI(player: hz.Player, areaId: number, slotId: number) {
    console.log(`PlayerManager:focusSlotUI: Player ${player?.name.get().toString()} interacted with area:slot - ${areaId}:${slotId}`);
    
  };

  // // Trader UI

  private updateUITraderUI(dataSet: string, player: hz.Player | undefined) {
    // update trader ui for everyone at trader if player is undefined, or just player if it is
    const playersAtTrader = this.getPlayersAtTrader();
    if (playersAtTrader.length > 0 ) {
      // prices only need to be done once because they are the same for everyone
      let traderUIData:TraderUIDataStruc = {}
      if (dataSet === "prices" || dataSet === "all") {
        // floor prices
        traderUIData.currentPricesData = [];
        this.traderPriceData.forEach(traderPrice => {
          const flooredPrice: TraderResourceStruc = {
            resourceId: traderPrice.resourceId,
            currentPrice: Math.floor(traderPrice.currentPrice),
            lastEventUnstable: traderPrice.lastEventUnstable,
            lastPriceChangePositive: traderPrice.lastPriceChangePositive
          };
          traderUIData.currentPricesData?.push(flooredPrice);
        });
      };

      if (player && playersAtTrader.includes(player)) {
        this.updateUITraderUIForPlayer(player, dataSet, traderUIData);
      } else {
        playersAtTrader.forEach(toPlayer => {
          // update trader ui for player
          this.updateUITraderUIForPlayer(toPlayer, dataSet, traderUIData);
        });
      };
    } else {
      // no players at the trader, dont update
    };
  };

  private updateUITraderUIForPlayer(player: hz.Player, dataSet: string, traderUIData: TraderUIDataStruc) {
    if (dataSet === "resources" || dataSet === "all") {
      // get player data
      const playerData = this.players.find(data => data.player === player);
      if (playerData) {
        traderUIData.playerResourceData = playerData.saveData.resourcesData;
      } else {
        // couldnt find player data
      };
    };

    traderUIData.resourceGameData = this.resourceGameDataArray;

    console.log(`PlayerManager:updateUITraderUIForPlayer: Update trader ui data for player ${player?.name.get().toString()}`);
    this.sendNetworkBroadcastEvent(sendUIUpdate, {
      player,
      uiName: 'Trader',
      eventName: 'updateTrader',
      payload: traderUIData,
    });
  };

  private focusTraderUI(player: hz.Player) {
    console.log(`PlayerManager:focusTraderUI: Player ${player?.name.get().toString()} interacted with the trader`);

    const playerData = this.players.find(data => data.player === player);
    if (playerData) {
            
      let traderUIData: TraderUIDataStruc = {
        visible: true,
      }
      
      this.sendNetworkBroadcastEvent(sendUIUpdate, {
        player,
        uiName: 'Trader',
        eventName: 'updateTrader',
        payload: traderUIData,
      });
    } else {
      // cant find player data
    }
  };

  // // Saloon UI

  private updateUISaloonUI(player: hz.Player) {
    const playerDataEntry = this.players.find(data => data.player === player);
    if (playerDataEntry) {
      let saloonUIData: SaloonUIDataStruc = {
        currentWorkers: playerDataEntry.saveData.metaData.currentWorkers,
        availableWorkers: playerDataEntry.saveData.metaData.totalWorkers - playerDataEntry.saveData.metaData.currentWorkers,
        hireCost: [{resourceId: 1, amount: Math.floor(this.props.workerBasePrice * (this.props.workerPriceExponent ** playerDataEntry.saveData.metaData.currentWorkers))}],
      };

      console.log(`PlayerManager:updateUISaloonUI: Update saloon ui data for player ${player?.name.get().toString()}`);


      this.sendNetworkBroadcastEvent(sendUIUpdate, {
        player,
        uiName: 'Saloon',
        eventName: 'updateSaloon',
        payload: saloonUIData,
      });
    } else {
      // cant find player data entry
    };
  }

  private focusSaloonUI(player: hz.Player) {
    console.log(`PlayerManager:focusSaloonUI: Player ${player?.name.get().toString()} interacted with the saloon`);
    let saloonUIData: SaloonUIDataStruc = {
      visible: true,
    };

    this.sendNetworkBroadcastEvent(sendUIUpdate, {
      player,
      uiName: 'Saloon',
      eventName: 'updateSaloon',
      payload: saloonUIData,
    });
  };

  // // Notifications
  private sendPlayerNotification(player: hz.Player, notificationId: number, msgArgs: string[], sendToSlotUI: boolean = false) {
    console.log(`PlayerManager:sendPlayerNotification: Sending ${notificationId} to ${player.name.get()} with ${msgArgs}`);
    const notificationData = this.notificationGameDataArray.find(data => data.notificationId === notificationId);
    
    if (notificationData) {
      const message = notificationData.text.replace(/#(\d+)#/g, (match, index) => {
        const i = parseInt(index, 10);
        return msgArgs[i - 1] ? msgArgs[i - 1].toString() : match;
      });
  
      console.log(`PlayerManager:sendPlayerNotification: ${message}`);
  
      if (sendToSlotUI) {
        this.sendNetworkBroadcastEvent(sendUIUpdate, {
          player,
          uiName: 'Slot',
          eventName: 'updateSlot',
          payload: {
            slotMessage: message
          }
        });
      } else {
        const notificationUIData: NotificationUIDataStruc = {
          visible: true,
          message,
        };
  
        this.sendNetworkBroadcastEvent(sendUIUpdate, {
          player,
          uiName: 'Notification',
          eventName: 'updateNotification',
          payload: notificationUIData,
        });
      }
  
    } else {
      console.log(`PlayerManager:sendPlayerNotification: Cant find notification ${notificationId} in game data`);
    }
  };
  
};



hz.Component.register(PlayerManager);

import * as hz from 'horizon/core';
import { assignPlayerSlot, fillSlotGameData, resetSlot, loadPlayerSlotData, setSlotLevel } from 'AreaManager';
import { AreaSlotDataStruct } from 'GameData';
import { ResourcesSaveStruc, AreaSlotSaveStruc, onPlayerResourceUpdate } from 'PlayerManager';

// The event to grant resource - to be replaced with opening a ui
export const onEnterSlot = new hz.NetworkEvent<{ player: hz.Player, areaId: number, slotId: number, slotUiEntity: hz.Entity }>('onEnterSlot');
export const onExitSlot = new hz.NetworkEvent<{ player: hz.Player, areaId: number, slotId: number }>('onExitSlot');
export const onInteractWithSlot = new hz.NetworkEvent<{ player: hz.Player, areaId: number, slotId: number }>('onInteractWithSlot');

type SlotAssetsStruc = {
  static: hz.Entity,
  dynamic: hz.Entity
};

class SlotManager extends hz.Component<typeof SlotManager> {
  static propsDefinition = {
    // ### Entities
    uiEntity: {type: hz.PropTypes.Entity},
    triggerEntity: {type: hz.PropTypes.Entity},
    uiInteractTriggerEntity: {type: hz.PropTypes.Entity},
    positionEntity: {type: hz.PropTypes.Entity},

    lockedEntityStatic: {type: hz.PropTypes.Entity},
    lockedEntityDynamic: {type: hz.PropTypes.Entity},

    level0EntityStatic: {type: hz.PropTypes.Entity},
    level0EntityDynamic: {type: hz.PropTypes.Entity},

    level1EntityStatic: {type: hz.PropTypes.Entity},
    level1EntityDynamic: {type: hz.PropTypes.Entity},

    level2EntityStatic: {type: hz.PropTypes.Entity},
    level2EntityDynamic: {type: hz.PropTypes.Entity},

    level3EntityStatic: {type: hz.PropTypes.Entity},
    level3EntityDynamic: {type: hz.PropTypes.Entity},
  };
  private areaId: number | undefined;
  private slotData: AreaSlotDataStruct | undefined;
  private slotLevelAssets: SlotAssetsStruc[] = [];

  private assignedPlayer: hz.Player | undefined;
  private playerResources: ResourcesSaveStruc[] = [];
  private slotSaveData: AreaSlotSaveStruc | undefined;

  preStart() {
    const slotLevelAssets = [
      { static: this.props.level0EntityStatic, dynamic: this.props.level0EntityDynamic },
      { static: this.props.level1EntityStatic, dynamic: this.props.level1EntityDynamic },
      { static: this.props.level2EntityStatic, dynamic: this.props.level2EntityDynamic },
      { static: this.props.level3EntityStatic, dynamic: this.props.level3EntityDynamic },
    ];
    slotLevelAssets.forEach(slotAsset => {
      if (slotAsset && slotAsset.static && slotAsset.dynamic) {
        const slotAssets: SlotAssetsStruc = {
          static: slotAsset.static,
          dynamic: slotAsset.dynamic,
        }
        this.slotLevelAssets.push(slotAssets);
        slotAsset.static.position.set(new hz.Vec3(0,-5000,0));
        slotAsset.dynamic.position.set(new hz.Vec3(0,-5000,0));
      };
    });
    if (this.props.lockedEntityStatic && this.props.lockedEntityDynamic && this.props.positionEntity) {
      const slotAssetPos = this.props.positionEntity.position.get();
      this.props.lockedEntityStatic.position.set(slotAssetPos);
      this.props.lockedEntityDynamic.position.set(slotAssetPos);
    };
    
  };

  start() {

    this.connectNetworkEvent(
      this.entity,
      assignPlayerSlot,
      (data: {areaId: number, player: hz.Player}) => {
        this.onAssignPlayer(data.areaId, data.player);
      }
    );
    this.connectNetworkEvent(
      this.entity,
      resetSlot,
      () => {
        this.onReset();
      }
    );
    this.connectNetworkEvent(
      this.entity,
      fillSlotGameData,
      (data: {slotDataEntry: AreaSlotDataStruct}) => {
        if (data.slotDataEntry !== undefined) {
          //console.log(`SlotManager:fillSlotGameData: Filling game data`);
          this.fillSlotGameData(data.slotDataEntry);
        };
      }
    );
    this.connectNetworkEvent(
      this.entity,
      setSlotLevel,
      (data: {level: number}) => {
        if (data.level !== undefined) {
          console.log(`SlotManager:setSlotLevel: Setting slot to level ${data.level}`);
          this.setLevel(data.level);
        };
      }
    );
    this.connectNetworkEvent(
      this.entity,
      loadPlayerSlotData,
      (data: {timeSinceLastSave: number, slotSaveData: AreaSlotSaveStruc}) => {
        if (data.slotSaveData !== undefined) {
          //console.log(`SlotManager:fillSlotGameData: Loading player data`);
          this.loadSlotPlayerData(data.timeSinceLastSave, data.slotSaveData);
        };
      }
    );
    // 
    if (this.props.triggerEntity) {
      this.connectCodeBlockEvent(this.props.triggerEntity, hz.CodeBlockEvents.OnPlayerEnterTrigger, (player: hz.Player) => {
        console.log(`SlotManager:${this.entity.name.get()}: player ${player.name.get()} entered area:slot ${this.areaId}:${this.slotData?.slotId}`);
        if (player && this.areaId != null && this.slotData) {
          // Send a local broadcast event back to the PlayerManager with the slot information
          this.sendNetworkBroadcastEvent(onEnterSlot, {
            player: player,
            areaId: this.areaId,
            slotId: this.slotData.slotId,
            slotUiEntity: this.props.uiEntity ? this.props.uiEntity: this.entity,
          });
        };
      });
      // 
      this.connectCodeBlockEvent(this.props.triggerEntity, hz.CodeBlockEvents.OnPlayerExitTrigger, (player: hz.Player) => {
        if (player && this.areaId && this.slotData) {
          console.log(`SlotManager:${this.entity.name.get()}: player ${player.name.get()} exited area:slot ${this.areaId}:${this.slotData.slotId}`);
          // Send a local broadcast event back to the PlayerManager with the slot information
          this.sendNetworkBroadcastEvent(onExitSlot, {
            player: player,
            areaId: this.areaId,
            slotId: this.slotData.slotId,
          });
        };
      });
    };
    if (this.props.uiInteractTriggerEntity) {
      this.connectCodeBlockEvent(this.props.uiInteractTriggerEntity, hz.CodeBlockEvents.OnPlayerEnterTrigger, (player: hz.Player) => {
        if (player && this.areaId && this.slotData) {
          console.log(`SlotManager:${this.entity.name.get()}: player ${player.name.get()} has interacted with area:slot ${this.areaId}:${this.slotData.slotId}`);
          // Send a broadcast event back to the PlayerManager with the slot information
          this.sendNetworkBroadcastEvent(onInteractWithSlot, {
            player: player,
            areaId: this.areaId,
            slotId: this.slotData.slotId,
          });
        };
      });
    };
  };
  
  private onAssignPlayer(areaId: number, player: hz.Player): void {
    //console.log(`SlotManager:onAssignPlayer: Assigned to ${player.name.get().toString()}`);
    this.assignedPlayer = player;
    this.areaId = areaId;


    this.connectNetworkBroadcastEvent(
      onPlayerResourceUpdate,
      (data: {player: hz.Player, resourceData: ResourcesSaveStruc[]}) => {
        if (this.assignedPlayer == this.assignedPlayer) {
          this.playerResources = data.resourceData ?? [];
        };
      });
  };
  
  private onReset(): void {
    this.assignedPlayer = undefined;

  };

  private fillSlotGameData(slotGameData: AreaSlotDataStruct): void {
    //console.log(`SlotManager${slotGameData.slotId}:fillSlotGameData: My name is ${slotGameData.name}`);
    this.slotData = slotGameData;
  };

  private loadSlotPlayerData(timeSinceLastSave: number, slotSaveData: AreaSlotSaveStruc): void {
    //console.log(`SlotManager${this.slotData?.slotId}:loadSlotPlayerData: Loading data`);

    this.slotSaveData = slotSaveData;
  };

  private setLevel(level: number) {
    if (this.props.positionEntity) {
      const slotAssetPos = this.props.positionEntity.position.get();
      const slotAssetAwayPos = new hz.Vec3(0,-5000,0);
      for (let i = 0; i <= level; i++) {
        const levelAssets = this.slotLevelAssets[i];
        if (levelAssets) {
          if (level > i) {
            // level is greater = move in static, move out dynamic
            levelAssets.static.position.set(slotAssetPos);
            levelAssets.dynamic.position.set(slotAssetAwayPos);
          };
          if (level == i) {
            // level is same = move in static and dynamic
            levelAssets.static.position.set(slotAssetPos);
            levelAssets.dynamic.position.set(slotAssetPos);
          };
        };
      };
      const lockedDynamicAssets = this.props.lockedEntityDynamic;
      if (lockedDynamicAssets) {
        lockedDynamicAssets.position.set(slotAssetAwayPos);
      };
    } else {
      console.log(`SlotManager${this.slotData?.slotId}:setLevel: Tried to set to level ${level}, but position entity is not defined.`);
    };
  };
}
hz.Component.register(SlotManager);
import * as hz from 'horizon/core';

export const playSound = new hz.NetworkEvent<{soundId: number, player?: hz.Player}>('playSound');

class SoundManager extends hz.Component<typeof SoundManager> {
  static propsDefinition = {
    sound1: {type: hz.PropTypes.Entity},
    sound2: {type: hz.PropTypes.Entity},
    sound3: {type: hz.PropTypes.Entity},
    sound4: {type: hz.PropTypes.Entity},
    sound5: {type: hz.PropTypes.Entity},
    sound6: {type: hz.PropTypes.Entity},
    sound7: {type: hz.PropTypes.Entity},
    sound8: {type: hz.PropTypes.Entity},
  };
  private sounds: hz.AudioGizmo[] = [];

  preStart(): void {
    this.sounds = [
      this.props.sound1?.as(hz.AudioGizmo),
      this.props.sound2?.as(hz.AudioGizmo),
      this.props.sound3?.as(hz.AudioGizmo),
      this.props.sound4?.as(hz.AudioGizmo),
      this.props.sound5?.as(hz.AudioGizmo),
      this.props.sound6?.as(hz.AudioGizmo),
      this.props.sound7?.as(hz.AudioGizmo),
      this.props.sound8?.as(hz.AudioGizmo),
    ].filter((sound): sound is hz.AudioGizmo => sound !== undefined);


    this.connectNetworkBroadcastEvent(
      playSound,
      (p: { soundId: number, player?: hz.Player }) => {
        const soundToPlay = this.sounds[p.soundId - 1];
        if (!soundToPlay) { console.log(`SoundManager:playSound: Cant find sound ${p.soundId}.`); return; };
        this.PlaySound(soundToPlay,p.player);
    });
  };

  start() {

  };

  PlaySound(audioGizmo: hz.AudioGizmo, player?: hz.Player): void {
    if (!audioGizmo) return;
    console.log(`SoundManager:PlaySound: Playing sound ${audioGizmo.name.get()}.`);
    const options: hz.AudioOptions = {
      fade: 0.5,
      ...(player ? { players: [player] } : {}),
    };
  
    audioGizmo.play(options);
  };
};
hz.Component.register(SoundManager);

import { 
  TextStyle, 
  ViewStyle 
} from 'horizon/ui';

import * as hz from 'horizon/core';

export const textStyle: TextStyle = {
  textAlign: 'center',
  color: '#ead2b0',
};

export const extraLargeText: TextStyle = {
  fontSize: 46,
};

export const largeText: TextStyle = {
  fontSize: 34,
};

export const regularText: TextStyle = {
  fontSize: 24,
};

export const smallText: TextStyle = {
  fontSize: 16,
};

export const extraSmallText: TextStyle = {
  fontSize: 13,
};

export const panelStyle: ViewStyle = {
  justifyContent: 'center',
  alignItems: 'center',
  backgroundColor: hz.Color.fromHex("#5C4033"), // dark rustic brown
  opacity: 0.9,
  borderWidth: 3,
  borderRadius: 8,
  borderColor: hz.Color.fromHex("#a05f3b") // slightly deeper dark rustic
};

export const fullscreenCenterStyle: ViewStyle = {
  position: 'absolute',
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  justifyContent: 'center',
  alignItems: 'center',
  paddingTop: 60
};

export const buttonStyle: ViewStyle = {
  alignItems: 'center',
  justifyContent: 'center',
  backgroundColor: "#8B2500", // rust red
  padding: 10,
  borderColor: "#DAA520", // faded gold
  borderWidth: 2,
  borderRadius: 8,
};

export const defaultButtonColor = hz.Color.fromHex("#8e452f");
export const hoverButtonColor = hz.Color.fromHex("#9c4e34"); // sienna-ish
export const pressedButtonColor = hz.Color.fromHex("#7B3F00"); // darker brown

export const resourceIconStyle = {
  width: 48,
  height: 48,
  //marginLeft: 4,
  //marginRight: 2,
};

export const backgroundStyle: ViewStyle = {
  position: 'absolute',
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  //opacity: 0.9,
  borderRadius: 3,
};

import * as hz from 'horizon/core';
import {
  UIComponent,
  Binding,
  Image,
  ImageSource,
  UINode
} from 'horizon/ui';

export const onImagesReady = new hz.NetworkEvent<{}>('onIconsReady');

class UI_ImagePreloader extends UIComponent<typeof UI_ImagePreloader> {
  static propsDefinition = {
    Background: { type: hz.PropTypes.Asset },

    Logs: { type: hz.PropTypes.Asset },
    Planks: { type: hz.PropTypes.Asset },
    // Stone: { type: hz.PropTypes.Asset },
    // Concrete: { type: hz.PropTypes.Asset },
    IronOre: { type: hz.PropTypes.Asset },
    Tools: { type: hz.PropTypes.Asset },
    Coal: { type: hz.PropTypes.Asset },
    Steel: { type: hz.PropTypes.Asset },
    GoldNuggets: { type: hz.PropTypes.Asset },
    GoldBars: { type: hz.PropTypes.Asset },
  };

  private hasBroadcastReady = false;
  private loadedImage: Binding<ImageSource> = new Binding(new ImageSource());
  private imageSources: ImageSource[] = [];
  private index: number = 0;
  private tick: number = 0;

  private iconPreloadIntervalMs = 100;
  private preloadStartTime = 0;
  private preloadComplete = false;
  
  preStart(): void {
    this.imageSources = Object.values(this.props)
      .filter((asset): asset is hz.TextureAsset => asset !== undefined)
      .map((asset) => ImageSource.fromTextureAsset(asset));
  
    this.connectLocalBroadcastEvent(hz.World.onUpdate, (payload) => {
      if (this.preloadComplete || this.imageSources.length === 0) return;
  
      this.tick += payload.deltaTime;
  
      if (this.tick > this.iconPreloadIntervalMs / 1000) {
        this.tick = 0;
  
        this.loadedImage.set(this.imageSources[this.index]);
        this.index++;
  
        if (this.index >= this.imageSources.length) {
          this.preloadComplete = true;
  
          this.sendNetworkBroadcastEvent(onImagesReady, {});
        }
      }
    });
  }

  initializeUI(): UINode {
    return Image({
      source: this.loadedImage,
      style: {
        width: '100%',
        height: '100%',
        position: 'absolute',
        top: -1000,
        left: -1000,
      },
    });
  }
}

UIComponent.register(UI_ImagePreloader);

import * as hz from 'horizon/core';

import {
  UIComponent,
  Binding,
  UINode,
  View,
  Text,
  Image,
  ImageSource
} from 'horizon/ui';

import {
  panelStyle,
  textStyle,
  regularText,
  smallText,
  backgroundStyle,
  extraSmallText
} from './UI_CommonStyles';

import { onUIReady, updateNotification } from 'UIManager';
import { NotificationUIDataStruc } from 'PlayerManager';

export class UI_Notification extends UIComponent {
  static propsDefinition = {
    Background: { type: hz.PropTypes.Asset },
  };

  private notiMsgBindings: Binding<string>[] = [
    new Binding<string>(''),
    new Binding<string>(''),
    new Binding<string>(''),
    new Binding<string>(''),
    new Binding<string>(''),
  ];

  private notiMsgStrings: string[] = ['', '', '', '', ''];
  private notiMsgIds: number[] = [0, 0, 0, 0, 0];
  private nextMsgId = 1;

  receiveOwnership(
    state: any,
    fromPlayer: hz.Player,
    toPlayer: hz.Player
  ): void {
    console.log(`UI_Notification: receiveOwnership from server to ${toPlayer?.name.get()}`);

    this.sendNetworkBroadcastEvent(onUIReady, {
      player: toPlayer,
      uiName: 'Notification',
      uiEntity: this.entity,
    });
  }

  initializeUI(): UINode {
    this.entity.visible.set(true);

    this.connectNetworkEvent(
      this.entity,
      updateNotification,
      (data) => this.handleUI(data)
    );

    return this.renderUI();
  }

  private renderUI(): UINode {
    return View({
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        justifyContent: 'center',
        alignItems: 'flex-end',
        paddingRight: 5,
      },
      children: [
        View({
          style: {
            //...panelStyle,
            //width: 400,
            //alignSelf: 'flex-start',
            maxWidth: 500,
            padding: 20,
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'flex-end',
          },
          children: [
            // Image({
            //   source: ImageSource.fromTextureAsset(this.props.Background),
            //   style: backgroundStyle,
            // }),
          
            ...this.notiMsgBindings.map(binding =>
              Text({
                text: binding,
                style: {
                  ...textStyle,
                  //...regularText,
                  fontSize: 20,
                  marginBottom: 6,
                  textShadowColor: hz.Color.black,
                  textShadowOffset: [2, 2],
                  textAlign: 'right'
                }
              })
            )
          ]          
        })
      ]
    });
  }  

  private handleUI(data: NotificationUIDataStruc): void {
    const { visible, message } = data;
  
    if (visible !== undefined) {
      this.entity.visible.set(visible);
    }
  
    const msg = data.message ?? '';
  
    // Shift messages and IDs down one slot
    for (let i = this.notiMsgStrings.length - 1; i > 0; i--) {
      this.notiMsgStrings[i] = this.notiMsgStrings[i - 1];
      this.notiMsgIds[i] = this.notiMsgIds[i - 1];
    }
  
    // Insert new message and assign a unique ID
    const msgId = this.nextMsgId++;
    this.notiMsgStrings[0] = msg;
    this.notiMsgIds[0] = msgId;
  
    // Update all bindings
    for (let i = 0; i < this.notiMsgStrings.length; i++) {
      this.notiMsgBindings[i].set(this.notiMsgStrings[i]);
    }
  
    // Schedule clearing for this specific message ID
    this.async.setTimeout(() => {
      for (let i = 0; i < this.notiMsgStrings.length; i++) {
        if (this.notiMsgIds[i] === msgId) {
          this.notiMsgStrings[i] = '';
          this.notiMsgBindings[i].set('');
          this.notiMsgIds[i] = 0;
        }
      }
    }, 5000);
  }
  
}  

hz.Component.register(UI_Notification);
import * as hz from 'horizon/core';

import {
  View,
  Text,
  Image,
  Binding,
  UIComponent,
  UINode,
  ImageSource,
} from 'horizon/ui';

import { 
  textStyle,
  regularText, 
  smallText,
  panelStyle, 
  resourceIconStyle,
  backgroundStyle
} from 'UI_CommonStyles';

import { onUIReady, updateResourceBar } from 'UIManager';
import { ResourceBarUIDataStruc } from 'PlayerManager';

type ResourceWithBindings = {
  resourceId: number;
  nameBinding: Binding<string>;
  colourBinding: Binding<hz.Color>;
  amountBinding: Binding<string>;
  iconBinding: Binding<ImageSource>;
  visibleBinding: Binding<boolean>;
};

const emptyImageSource = new ImageSource();

class UI_ResourceBar extends UIComponent {
  static propsDefinition = {
    Background: { type: hz.PropTypes.Asset },

    Coins: { type: hz.PropTypes.Asset },
    Logs: { type: hz.PropTypes.Asset },
    Planks: { type: hz.PropTypes.Asset },
    // Stone: { type: hz.PropTypes.Asset },
    // Concrete: { type: hz.PropTypes.Asset },
    IronOre: { type: hz.PropTypes.Asset },
    Tools: { type: hz.PropTypes.Asset },
    Coal: { type: hz.PropTypes.Asset },
    Steel: { type: hz.PropTypes.Asset },
    GoldNuggets: { type: hz.PropTypes.Asset },
    GoldBars: { type: hz.PropTypes.Asset },

    showResourceName: { type: hz.PropTypes.Boolean },
    showResourceIcon: { type: hz.PropTypes.Boolean },
  };

  private resourceCount = 9;

  private resources: ResourceWithBindings[] = Array.from(
    { length: this.resourceCount },
    (_, i) => ({
      resourceId: i + 1,
      nameBinding: new Binding(`Resource ${i + 1}`),
      colourBinding: new Binding(hz.Color.white),
      amountBinding: new Binding('0'),
      iconBinding: new Binding<ImageSource>(emptyImageSource),
      visibleBinding: new Binding<boolean>(false),
    })
  );

  private isBarVisible = new Binding<boolean>(false);
  
  receiveOwnership(
    state: any,
    fromPlayer: hz.Player,
    toPlayer: hz.Player
  ): void {
    console.log(`UI_ResourceBar: receiveOwnership from server to ${toPlayer?.name.get()}`);

    // Tell UIManager we're initialized and ready for binding updates
    this.sendNetworkBroadcastEvent(onUIReady, {
      player: toPlayer,
      uiName: 'ResourceBar',
      uiEntity: this.entity
    });
  }  

  initializeUI(): UINode {
    // Start hidden; only visible when set via updateUIName event
    this.entity.visible.set(false);
    
    const showResourceName = this.props.showResourceName !== false;
    const showResourceIcon = this.props.showResourceIcon !== false;

    this.connectNetworkEvent(
      this.entity,
      updateResourceBar,
      (data) => this.handleUI(data)
    );

    return this.renderUI(showResourceName, showResourceIcon);
  }

  private renderUI(showResourceName: boolean, showResourceIcon: boolean): UINode {
    const resourceViews: UINode[] = this.resources.map((resource) =>
      UINode.if(resource.visibleBinding, View({
        style: {
          flexDirection: 'row',
          alignItems: 'center',
          paddingVertical: 0,
          paddingHorizontal: 4,
          borderRadius: 6,
        },
        children: [
          ...(showResourceIcon ? [
            Image({
              source: resource.iconBinding,
              style: resourceIconStyle,
            })
          ] : []),
          ...(showResourceName ? [
            Text({
              text: resource.nameBinding,
              style: {
                ...textStyle,
                ...smallText,
                color: resource.colourBinding,
                marginRight: 6,
              },
            })
          ] : []),
          Text({
            text: resource.amountBinding,
            style: {
              ...textStyle,
              ...smallText,
            },
          }),
        ],
      }))
    );
  
    return UINode.if(this.isBarVisible, View({
      style: {
        ...panelStyle,
        flexDirection: 'row',
        alignItems: 'center',
        alignSelf: 'center',
        top: 0,
        padding: 1,
        paddingRight: 9,
        borderTopWidth: 0,
        borderTopLeftRadius: 0,
        borderTopRightRadius: 0,
        position: 'relative',
        overflow: 'hidden',
      },
      children: [
        Image({
          source: ImageSource.fromTextureAsset(this.props.Background),
          style: backgroundStyle,
        }),
        ...resourceViews
      ],
    }));
  }  

  private handleUI(data: ResourceBarUIDataStruc): void {

    const { visible, resourceGameData, playerResourceData } = data;
  
    // Initial setup (only happens once)
    if (resourceGameData) {
      resourceGameData.forEach((incoming) => {
        const match = this.resources.find(r => r.resourceId === incoming.resourceId);
        if (match) {
          match.nameBinding.set(incoming.name.replace(/([a-z])([A-Z])/g, '$1 $2'));
          match.colourBinding.set(incoming.colour);
  
          const asset = this.props[incoming.name];
          if (asset) {
            const source = ImageSource.fromTextureAsset(asset);
            match.iconBinding.set(source);
          }
        } else {
          console.warn(`UI_ResourceBar: handleUI - No match for resourceId ${incoming.resourceId}`);
        }
      });
  
      // Show UI after initial setup, can be overridden below
      this.entity.visible.set(true);
    }
  
    // UI changes
    if (playerResourceData) {
      playerResourceData.forEach((res) => {
        const resource = this.resources.find((r) => r.resourceId === res.resourceId);
        if (resource) {
          //resource.amountBinding.set(res.amount.toString());
          resource.amountBinding.set(this.formatCompactNumber(res.amount));
          resource.visibleBinding.set(res.amount > 0);
        } else {
          console.warn(`UI_ResourceBar: handleUI - No match for resourceId ${res.resourceId}`);
        }

        const hasVisibleResource = playerResourceData.some(res => res.amount > 0);
        this.isBarVisible.set(hasVisibleResource);
      });
    }
  
    if (visible !== undefined) {
      this.entity.visible.set(visible);
    }
  }  

  private formatCompactNumber(value: number): string {
    if (value >= 1_000_000_000_000_000_000_000) {
      return (value / 1_000_000_000_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'S';
    } else if (value >= 1_000_000_000_000_000) {
      return (value / 1_000_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'Q';
    } else if (value >= 1_000_000_000_000) {
      return (value / 1_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'T';
    } else if (value >= 1_000_000_000) {
      return (value / 1_000_000_000).toFixed(1).replace(/\.0$/, '') + 'B';
    } else if (value >= 1_000_000) {
      return (value / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
    } else if (value >= 1_000) {
      return (value / 1_000).toFixed(1).replace(/\.0$/, '') + 'K';
    } else {
      return value.toString();
    }
  }
}

UIComponent.register(UI_ResourceBar);
import * as hz from 'horizon/core';

import {
  UIComponent,
  Binding,
  UINode,
  View,
  Text,
  Image,
  ImageSource,
  Pressable
} from 'horizon/ui';

import {
  panelStyle,
  textStyle,
  smallText,
  backgroundStyle,
  buttonStyle,
  resourceIconStyle,
  regularText,
  largeText,
  extraLargeText
} from './UI_CommonStyles';

import { onUIReady, updateSaloon } from 'UIManager';
import { SaloonUIDataStruc, tryHireWorker } from 'PlayerManager';

export class UI_Saloon extends UIComponent {
  static propsDefinition = {
    Background: { type: hz.PropTypes.Asset },

    Coins: { type: hz.PropTypes.Asset },
  };

  private currentWorkersValueBinding = new Binding<string>('');
  private availableWorkersValueBinding = new Binding<string>('');
  private hireCostValueBinding = new Binding<string>('');
  private hireTextBinding = new Binding<string>('Hire worker for');

  private hireButtonColorBinding = new Binding<hz.Color>(hz.Color.fromHex('#8B5E3C'));
  private defaultHireButtonColor = hz.Color.fromHex('#8B5E3C');
  private hoverHireButtonColor = hz.Color.fromHex('#A1744D');
  
  private defaultCloseButtonColor = hz.Color.fromHex('#A33E2D');
  private hoverCloseButtonColor = hz.Color.fromHex('#C75033');
  private closeButtonColor = new Binding(this.defaultCloseButtonColor);

  private canHireBinding = new Binding<boolean>(false);

  receiveOwnership(
    state: any,
    fromPlayer: hz.Player,
    toPlayer: hz.Player
  ): void {
    console.log(`UI_Saloon: receiveOwnership from server to ${toPlayer?.name.get()}`);

    this.sendNetworkBroadcastEvent(onUIReady, {
      player: toPlayer,
      uiName: 'Saloon',
      uiEntity: this.entity,
    });
  }

  initializeUI(): UINode {
    this.entity.visible.set(false);

    this.connectNetworkEvent(
      this.entity,
      updateSaloon,
      (data) => this.handleUI(data)
    );

    return this.renderUI();
  }

  private handleUI(data: SaloonUIDataStruc): void {
    if (data.visible !== undefined) {
      this.entity.visible.set(data.visible);
    }

    if (data.currentWorkers !== undefined) {
      this.currentWorkersValueBinding.set(`${data.currentWorkers}`);
    }

    if (data.availableWorkers !== undefined) {
      this.availableWorkersValueBinding.set(`${data.availableWorkers}`);

      const canHire = (data.availableWorkers ?? 0) > 0;
      this.canHireBinding.set(canHire);

      if (canHire) {
        this.hireTextBinding.set('Hire worker for');
      } else {
        this.hireTextBinding.set('No workers to hire');
      }
    }

    if (data.hireCost?.length) {
      const cost = data.hireCost[0]?.amount ?? 0;
      this.hireCostValueBinding.set(this.formatCompactNumber(cost));
    }
  }

  private renderUI(): UINode {
    return View({
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        justifyContent: 'center',
        alignItems: 'center',
      },
      children: [
        View({
          style: {
            ...panelStyle,
            padding: 10,
            borderRadius: 8,
            width: 300,
            position: 'relative',
            overflow: 'hidden',
            //alignItems: 'center',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: backgroundStyle,
            }),

            View({
              style: {
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                height: 40,
                zIndex: 10,
              },
              children: [this.renderCloseButton()],
            }),        
            
            // View({
            //   style: {
            //     flexDirection: 'row',
            //     justifyContent: 'flex-end',
            //     width: '100%',
            //     marginBottom: 8, // spacing below the close button
            //   },
            //   children: [ this.renderCloseButton() ]
            // }),     
            
            Text({
              text: 'Saloon',
              style: {
                ...textStyle,
                fontSize: 36,
                fontWeight: 'bold',
                marginBottom: 12,
                textAlign: 'center',
              },
            }),

            this.renderDivider(),
  
            // Current workers
            View({
              style: { flexDirection: 'row', marginBottom: 4 },
              children: [
                Text({
                  text: new Binding('Current workers:'),
                  style: {
                    ...textStyle,
                    ...smallText,
                    //fontWeight: 'bold',
                    marginRight: 4,
                  }
                }),
                Text({
                  text: this.currentWorkersValueBinding,
                  style: {
                    ...textStyle,
                    ...smallText,
                    fontWeight: 'bold',
                  }
                }),
              ]
            }),
  
            // Available workers
            View({
              style: { flexDirection: 'row', marginBottom: 4 },
              children: [
                Text({
                  text: new Binding('Available workers:'),
                  style: {
                    ...textStyle,
                    ...smallText,
                    //fontWeight: 'bold',
                    marginRight: 4,
                  }
                }),
                Text({
                  text: this.availableWorkersValueBinding,
                  style: {
                    ...textStyle,
                    ...smallText,
                    fontWeight: 'bold',
                  }
                }),
              ]
            }),
  
            // Conditional button
            UINode.if(
              this.canHireBinding,
              this.renderHireButton(true),
              this.renderHireButton(false)
            )
          ]
        })
      ]
    });
  }  

  private renderDivider(): UINode {
    return View({
      style: {
        height: 2,
        width: '100%',
        backgroundColor: hz.Color.fromHex('#cca678'),
        //marginTop: 2,
        marginBottom: 8,
      }
    });
  }

  private renderCloseButton(): UINode {
    return Pressable({
      onPress: () => {
        this.closeButtonColor.set(this.defaultCloseButtonColor);
        this.entity.visible.set(false);
      },
      onEnter: () => this.closeButtonColor.set(this.hoverCloseButtonColor),
      onExit: () => this.closeButtonColor.set(this.defaultCloseButtonColor),
      children: [
        View({
          style: {
            ...buttonStyle,
            width: 70,
            height: 47,
            padding: 2,
            borderRadius: 8,
            backgroundColor: this.closeButtonColor,
            alignItems: 'center',
            justifyContent: 'center',
            borderWidth: 2,
            borderColor: hz.Color.fromHex('#A5673E'),
            position: 'absolute',
            top: 10,
            right: 10,
            zIndex: 10,
            overflow: 'hidden'
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: { ...backgroundStyle, opacity: 0.7, borderRadius: 6, position: 'absolute' }
            }),
            Text({
              text: 'X',
              style: {
                ...textStyle,
                ...regularText,
              },
            }),
          ],
        }),
      ],
    });
  }  

  private renderHireButton(isEnabled: boolean): UINode {
    return Pressable({
      style: {
        ...buttonStyle,
        backgroundColor: this.hireButtonColorBinding,
        borderColor: hz.Color.fromHex('#9e722b'),
        marginTop: 8,
        padding: 0,
        opacity: isEnabled ? 1 : 0.4,
        overflow: 'hidden',
      },
      onPress: isEnabled ? (player) => this.handleHireClick(player) : undefined,
      onEnter: isEnabled ? () => this.hireButtonColorBinding.set(this.hoverHireButtonColor) : undefined,
      onExit: isEnabled ? () => this.hireButtonColorBinding.set(this.defaultHireButtonColor) : undefined,
      children: [
        View({
          style: {
            flexDirection: 'row',
            alignItems: 'center',
            justifyContent: 'center',
            paddingVertical: 2,
            paddingHorizontal: 6,
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: { ...backgroundStyle, borderRadius: 6 }
            }),
            ...(isEnabled
              ? [
                  Text({
                    text: this.hireTextBinding,
                    style: {
                      ...textStyle,
                      ...smallText,
                      marginLeft: 4,
                    }
                  }),
                  Image({
                    source: ImageSource.fromTextureAsset(this.props.Coins),
                    style: {
                      ...resourceIconStyle,
                    }
                  }),
                  Text({
                    text: this.hireCostValueBinding,
                    style: {
                      ...textStyle,
                      ...smallText,
                      marginRight: 4,
                    }
                  }),
                ]
              : [
                  Text({
                    text: this.hireTextBinding,
                    style: {
                      ...textStyle,
                      ...smallText,
                      textAlign: 'center',
                    }
                  })
                ])
          ]
        })
      ]
    });
  }  

  private handleHireClick(player: hz.Player): void {
    this.sendNetworkBroadcastEvent(tryHireWorker, { player });
  }  
  
  private formatCompactNumber(value: number): string {
    if (value >= 1_000_000_000_000_000_000_000) {
      return (value / 1_000_000_000_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'S';
    } else if (value >= 1_000_000_000_000_000) {
      return (value / 1_000_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'Q';
    } else if (value >= 1_000_000_000_000) {
      return (value / 1_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'T';
    } else if (value >= 1_000_000_000) {
      return (value / 1_000_000_000).toFixed(1).replace(/\.0$/, '') + 'B';
    } else if (value >= 1_000_000) {
      return (value / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
    } else if (value >= 1_000) {
      return (value / 1_000).toFixed(1).replace(/\.0$/, '') + 'K';
    } else {
      return value.toString();import * as hz from 'horizon/core';

import {
  UIComponent,
  Binding,
  UINode,
  View,
  Text,
  ViewStyle,
  Pressable,
  Image,
  ImageSource
} from 'horizon/ui';

import {
  textStyle,
  extraLargeText,
  largeText, 
  regularText, 
  panelStyle,
  buttonStyle, 
  defaultButtonColor,
  hoverButtonColor,
  pressedButtonColor,
  backgroundStyle,
  resourceIconStyle,
  smallText
} from './UI_CommonStyles';

import { onUIReady, updateSlot } from 'UIManager';
import { SlotUIDataStruc, tryBuySlot, takeFromSlotStorage, addWorkerToSlot, removeWorkerFromSlot } from 'PlayerManager';

const resourceNames: Record<number, string> = {
  1: 'Coins',
  2: 'Logs',
  3: 'Planks',
  4: 'IronOre',
  5: 'Tools',
  6: 'Coal',
  7: 'Steel',
  8: 'GoldNuggets',
  9: 'GoldBars',
};

const topColumnStyle: ViewStyle = {
  //width: 275,
  flex: 1
};

const buttonRowContainerStyle: ViewStyle = {
  flexDirection: 'row',
  justifyContent: 'flex-start',
  marginTop: 8
};

const statRowContainerStyle: ViewStyle = {
  flexDirection: 'row',
  justifyContent: 'flex-start',
  marginTop: 8,
  marginBottom: 8
};

const statBoxContainerStyle: ViewStyle = {
  flex: 1,
  flexDirection: 'column',
  alignSelf: 'center',
};

const statBoxStyle: ViewStyle = {
  width: 387,
  minHeight: 40,
  padding: 4,
  borderWidth: 2,
};

const statBoxHeaderStyle: ViewStyle = {
  ...statBoxStyle,
  borderTopLeftRadius: 8,
  borderTopRightRadius: 8,
  borderBottomWidth: 0,
  overflow: 'hidden'
};

const statBoxContentStyle: ViewStyle = {
  ...statBoxStyle,
  borderBottomLeftRadius: 8,
  borderBottomRightRadius: 8,
  borderTopWidth: 0,
};

const plusMinusButtonStyle: ViewStyle = {
  width: 44,
  //height: 34,
  alignItems: 'center',
  justifyContent: 'center',
  padding: 0
};

const slotBackgroundStyle: ViewStyle = {
  ...backgroundStyle,
  borderRadius: 6,
  borderBottomLeftRadius: 0,
  borderBottomRightRadius: 0,
  opacity: 0.9,
  position: 'absolute',
};

const slotButtonStyle: ViewStyle = {
  ...buttonStyle,
  width: 185,
  alignItems: 'center',
  justifyContent: 'center',
  //borderWidth: 0,
  //borderColor: hz.Color.fromHex('#5a6675'),
  overflow: 'hidden',
};

const buttonBgStyle: ViewStyle = {
  ...backgroundStyle,
  borderRadius: 6,
  opacity: 0.4,
};

type ResourceWithBindings = {
  iconBinding: Binding<ImageSource>;
  nameBinding: Binding<string>;
  amountBinding: Binding<string>;
  showNameBinding: Binding<boolean>;
};

class UI_Slot extends UIComponent {
  static propsDefinition = {
    Background: { type: hz.PropTypes.Asset },

    Coins: { type: hz.PropTypes.Asset },
    Logs: { type: hz.PropTypes.Asset },
    Planks: { type: hz.PropTypes.Asset },
    IronOre: { type: hz.PropTypes.Asset },
    Tools: { type: hz.PropTypes.Asset },
    Coal: { type: hz.PropTypes.Asset },
    Steel: { type: hz.PropTypes.Asset },
    GoldNuggets: { type: hz.PropTypes.Asset },
    GoldBars: { type: hz.PropTypes.Asset },
  };

  private slotStatusBinding = new Binding<'locked' | 'available' | 'unlocked'>('unlocked');

  private isLocked = this.slotStatusBinding.derive(status => status === 'locked');
  private isAvailable = this.slotStatusBinding.derive(status => status === 'available');
  private isUnlocked = this.slotStatusBinding.derive(status => status === 'unlocked');

  private slotTypeBinding = new Binding<'rawProduce' | 'refinery' | 'storage'>('rawProduce');

  private isRawProduceBinding = this.slotTypeBinding.derive(type => type === 'rawProduce');
  private isRefineryBinding = this.slotTypeBinding.derive(type => type === 'refinery');
  private isRawProduceOrRefineryBinding = this.slotTypeBinding.derive(type => type === 'rawProduce' || type === 'refinery');

  private isStorageBinding = this.slotTypeBinding.derive(type => type === 'storage');
  private isNotStorageBinding = this.slotTypeBinding.derive(type => type !== 'storage');

  private nameBinding = new Binding<string>('Slot Name');
  private rawProducePreReqBinding = new Binding<string>('Uses Mining Camp');

  //private techNameBinding = new Binding<string>('Tech Name');
  private techStringBinding = new Binding<string>('Tech Description');

  private levelBinding = new Binding<string>('Level: 1/3');
  private upgradeLevelBinding = new Binding<string>('Upgrade Level: 1');

  private statsForFunBinding = new Binding<string>('#1# Tunnels extend #2# meters wide and #3# meters deep!');
  
  private workersBinding = new Binding<string>('Workers: 0/0');
  private maxPopBinding = 0;

  private storageBinding = new Binding<string>('Storage:');

  private productionBinding = new Binding<string>('Production:');
  private upkeepBinding = new Binding<string>('Upkeep:');

  private buyBinding = new Binding<string>('Buy for');

  private upgradeBinding = new Binding<string>('Upgrade for');
  private upgradeCostBinding = new Binding<string>('');

  private collectBinding = new Binding<string>('Collect');

  private resourcesWaitingBinding = new Binding<string>('Collect All');

  private buyButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#8B5E3C'));
  private upgradeButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#8B5E3C'));
  private collectButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#728f58'));
  private addWorkerButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#728f58'));
  private removeWorkerButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#aa544f'));
  
  private slotActionsButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#48505d'));
  
  private boxBorderColor = new Binding<hz.Color>(hz.Color.fromHex('#9e722b'));
  private boxBgColor = new Binding<hz.Color>(hz.Color.fromHex('#856640'));

  private workerBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#5e5e5e'));
  private storageBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#56788a'));
  private upkeepBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#994343'));
  private productionBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#728f58')); 
  private slotActionsBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#48505d'));
  // private upgradeBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#6e6259'));
  // private collectBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#c49a3a'));
  // private buyBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#3b94a6'));

  private slotNotificationBinding = new Binding<string>('');
  private currentSlotMessageId = 0;
  private nextSlotMessageId = 1;
  
  private areaId: number = -1;
  private slotId: number = -1;
  
  private upkeepResourcesWithBindings: ResourceWithBindings[] = Array.from(
    { length: 4 },
    () => ({
      iconBinding: new Binding<ImageSource>(new ImageSource()),
      nameBinding: new Binding<string>(''),
      amountBinding: new Binding<string>(''),
      showNameBinding: new Binding<boolean>(false)
    })
  );  

  private productionResourcesWithBindings: ResourceWithBindings[] = Array.from(
    { length: 4 },
    () => ({
      iconBinding: new Binding<ImageSource>(new ImageSource()),
      nameBinding: new Binding<string>(''),
      amountBinding: new Binding<string>(''),
      showNameBinding: new Binding<boolean>(false)
    })
  );
  
  private costResourcesWithBindings: ResourceWithBindings[] = Array.from(
    { length: 4 },
    () => ({
      iconBinding: new Binding<ImageSource>(new ImageSource()),
      nameBinding: new Binding<string>(''),
      amountBinding: new Binding<string>(''),
      showNameBinding: new Binding<boolean>(false)
    })
  );
  
  receiveOwnership(
    state: any,
    fromPlayer: hz.Player,
    toPlayer: hz.Player
  ): void {
    console.log(`UI_Slot: receiveOwnership from server to ${toPlayer?.name.get()}`);
  
    // Tell whoever that we're initialized and ready for binding updates
    this.sendNetworkBroadcastEvent(onUIReady, {
      player: toPlayer,
      uiName: 'Slot',
      uiEntity: this.entity,
    });
  }
  
  initializeUI(): UINode {
    // Start hidden; only visible when set via updateUIName event
    this.entity.visible.set(false)

    this.connectNetworkEvent(
      this.entity,
      updateSlot,
      (data) => this.handleUI(data)
    );

    return View({
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        justifyContent: 'center',
        alignItems: 'center',
        padding: 16
      },
      children: [ this.renderSlotDataScreen() ]
    });    
  }

  panelWidth = 815;
  panelHeight = 565;

  renderSlotDataScreen(): UINode {
    return View({
      style: {
        position: 'relative',
        overflow: 'hidden',
        padding: 0
      },
      children: [
        View({
          style: {
            ...panelStyle,
            width: 810,
            //height: 595,
            padding: 8,
            flexDirection: 'column',
            position: 'relative',
            overflow: 'hidden',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: slotBackgroundStyle,
            }),
  
            this.renderHeaderSection(),
            this.renderNotification(),
            this.renderDivider(),
  
            UINode.if(this.isLocked, [
              this.renderLockMessage()
            ]),
  
            UINode.if(this.isAvailable, [
              View({
                style: statRowContainerStyle,
                children: [
                  this.renderUpkeep(),
                  this.renderProduction()
                ]
              }),
              this.renderDivider(),
              View({
                style: {
                  flexDirection: 'row',
                  justifyContent: 'center',
                  marginTop: 6
                },
                children: [
                  this.renderBuyButton()
                ]
              })
            ]),            
  
            UINode.if(this.isUnlocked, [
              UINode.if(this.isRawProduceOrRefineryBinding, [
                this.renderStatsForFun(),
                this.renderDivider(),
                View({
                  style: statRowContainerStyle,
                  children: [
                    this.renderWorkers(),
                    this.renderStorage()
                  ]
                }),
                View({
                  style: statRowContainerStyle,
                  children: [
                    this.renderUpkeep(),
                    this.renderProduction()
                  ]
                }),
                this.renderDivider(),
              ]),
              UINode.if(this.isStorageBinding, [
                this.renderStorage(),
                this.renderDivider(),
              ]),
              View({
                style: {
                  flexDirection: 'row',
                  justifyContent: 'flex-start',
                  marginTop: 6
                },
                children: [
                  // this.renderUpgradeButton(),
                  // this.renderCollectButton()
                  this.renderUpgradeButton()
                ]
              })
              
            ])
          ]
        })
      ]
    });
  }  

  private renderNotification(): UINode {
    return UINode.if(this.slotNotificationBinding.derive(msg => msg !== ''), [
      View({
        style: {
          width: '100%',
          paddingVertical: 6,
          paddingHorizontal: 10,
          marginBottom: 8,
          backgroundColor: hz.Color.fromHex('#B07C4C'),
          borderRadius: 6,
          justifyContent: 'center',
          alignItems: 'center',
        },
        children: [
          Text({
            text: this.slotNotificationBinding,
            style: {
              ...textStyle,
              ...regularText,
              color: hz.Color.white,
              textAlign: 'center',
            }
          })
        ]
      })
    ]);
  }  

  private renderHeaderSection(): UINode {
    return View({
      style: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        marginBottom: 8
      },
      children: [
        View({
          style: {
            flex: 1,
            justifyContent: 'center',
          },
          children: [
            Text({ text: this.nameBinding, style: {...textStyle, ...extraLargeText, textAlign: 'left'} }),
            // UINode.if(this.isRefineryBinding, [
            //   Text({ text: this.rawProducePreReqBinding,
            //     style: {
            //       ...regularText,
            //       color: hz.Color.fromHex('#FFCCCB')
            //     }
            //   })
            // ])
          ]
        }),
  
        View({
          style: {
            ...topColumnStyle,
            alignItems: 'flex-end',
            justifyContent: 'center'
          },
          children: [
            UINode.if(this.isUnlocked, [
              Text({ text: this.levelBinding, style: { ...textStyle, ...largeText } }),
              Text({ text: this.upgradeLevelBinding, style: { ...textStyle, ...regularText } }),
              Text({ text: this.techStringBinding, style: { ...textStyle, ...regularText, color: hz.Color.fromHex('#d89d4a') } })
            ])
          ]
        })
      ]
    });
  }
  
  private renderDivider(): UINode {
    return View({
      style: {
        height: 2,
        width: '100%',
        backgroundColor: hz.Color.fromHex('#cca678'),
      }
    });
  }
  
  private renderStatsForFun(): UINode {
    return Text({
      text: this.statsForFunBinding,
      style: { ...textStyle, ...regularText, marginTop: 4, marginBottom: 4 } });
  }

  private renderWorkers(): UINode {
    return View({
      style: { ...statBoxContainerStyle, marginRight: 12 },
      children: [
        View({
          style: {
            ...statBoxHeaderStyle,
            backgroundColor: this.workerBoxColor,
            borderColor: this.boxBorderColor,
            position: 'relative',
            justifyContent: 'center',
            alignItems: 'center',
            overflow: 'hidden'
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: { ...slotBackgroundStyle, }
            }),
            Text({ text: 'Workers', style: { ...textStyle, ...largeText } }),
            View({
              style: {
                position: 'absolute',
                right: 5,
                flexDirection: 'row',
                alignItems: 'center'
              },
              children: [
                Pressable({
                  onPress: (player) => this.handleButtonClick(player, 'addWorker'),
                  onEnter: (player) => this.handleHoverStart(player, 'addWorker'),
                  onExit: (player) => this.handleHoverEnd(player, 'addWorker'),
                  children: [
                    View({
                      style: {
                        ...buttonStyle,
                        ...plusMinusButtonStyle,
                        marginRight: 4,
                        borderWidth: 0,
                        backgroundColor: this.addWorkerButtonColor,
                        overflow: 'hidden'
                      },
                      children: [
                        Image({
                          source: ImageSource.fromTextureAsset(this.props.Background),
                          style: buttonBgStyle
                        }),
                        Text({ text: '+', style: { ...textStyle, ...largeText } })
                      ]
                    })
                  ]
                }),
                Pressable({
                  onPress: (player) => this.handleButtonClick(player, 'removeWorker'),
                  onEnter: (player) => this.handleHoverStart(player, 'removeWorker'),
                  onExit: (player) => this.handleHoverEnd(player, 'removeWorker'),
                  children: [
                    View({
                      style: {
                        ...buttonStyle,
                        ...plusMinusButtonStyle,
                        borderWidth: 0,
                        backgroundColor: this.removeWorkerButtonColor,
                        overflow: 'hidden'
                      },
                      children: [
                        Image({
                          source: ImageSource.fromTextureAsset(this.props.Background),
                          style: buttonBgStyle
                        }),
                        Text({ text: '-', style: { ...textStyle, ...largeText } })
                      ]
                    })
                  ]
                })
              ]
            })
          ]
        }),
        View({
          style: {
            ...statBoxContentStyle,
            backgroundColor: this.boxBgColor,
            borderColor: this.boxBorderColor
          },
          children: [
            Text({ text: this.workersBinding, style: { ...textStyle, ...regularText } })
          ]
        })
      ]
    });
  }  
  
  private renderStorage(): UINode {
    return View({
      style: { ...statBoxContainerStyle },
      children: [
        View({
          style: {
            ...statBoxHeaderStyle,
            backgroundColor: this.storageBoxColor,
            borderColor: this.boxBorderColor,
            position: 'relative',
            justifyContent: 'center',
            alignItems: 'center',
            overflow: 'hidden'
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: slotBackgroundStyle
            }),
            Text({ text: 'Storage', style: { ...textStyle, ...largeText } }),
  
            View({
              style: {
                position: 'absolute',
                right: 5,
                flexDirection: 'row',
                alignItems: 'center'
              },
              children: [
                Pressable({
                  onPress: (player) => this.handleButtonClick(player, 'collect'),
                  onEnter: (player) => this.handleHoverStart(player, 'collect'),
                  onExit: (player) => this.handleHoverEnd(player, 'collect'),
                  children: [
                    View({
                      style: {
                        ...buttonStyle,
                        ...plusMinusButtonStyle,
                        height: 45,
                        width: 100,
                        borderWidth: 0,
                        backgroundColor: this.collectButtonColor,
                        overflow: 'hidden',
                        alignItems: 'center',
                        justifyContent: 'center',
                      },
                      children: [
                        Image({
                          source: ImageSource.fromTextureAsset(this.props.Background),
                          style: buttonBgStyle
                        }),
                        Text({
                          text: this.collectBinding,
                          style: { ...textStyle, ...regularText },
                        }),
                      ]
                    })
                  ]
                })
              ]
            })
          ]
        }),
        View({
          style: {
            ...statBoxContentStyle,
            backgroundColor: this.boxBgColor,
            borderColor: this.boxBorderColor
          },
          children: [
            Text({ text: this.storageBinding, style: { ...textStyle, ...regularText } })
          ]
        })
      ]
    });
  }  
  
  private renderProduction(): UINode {
    return View({
      style: { ...statBoxContainerStyle },
      children: [
        View({
          style: {
            ...statBoxHeaderStyle,
            position: 'relative',
            backgroundColor: this.productionBoxColor,
            borderColor: this.boxBorderColor,
            justifyContent: 'center',
            alignItems: 'center',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: slotBackgroundStyle
            }),
            Text({ text: 'Production', style: { ...textStyle, ...largeText } })
          ]
        }),
  
        View({
          style: {
            ...statBoxContentStyle,
            backgroundColor: this.boxBgColor,
            borderColor: this.boxBorderColor,
            flexDirection: 'row',
            flexWrap: 'wrap',
            alignItems: 'center',
            justifyContent: 'center',
            paddingTop: 4,
            paddingBottom: 4
          },
          children: this.productionResourcesWithBindings.flatMap(resource => [
            Image({
              source: resource.iconBinding,
              style: resourceIconStyle,
            }),
            UINode.if(resource.showNameBinding, Text({
              text: resource.nameBinding,
              style: { ...textStyle, ...regularText }
            })),
            Text({
              text: resource.amountBinding,
              style: { ...textStyle, ...regularText, marginRight: 6 }
            }),
          ])
        })
      ]
    });
  }  
  
  private renderUpkeep(): UINode {
    return View({
      style: { ...statBoxContainerStyle, marginRight: 12 },
      children: [
        View({
          style: {
            ...statBoxHeaderStyle,
            position: 'relative',
            backgroundColor: this.upkeepBoxColor,
            borderColor: this.boxBorderColor,
            justifyContent: 'center',
            alignItems: 'center',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: slotBackgroundStyle
            }),
            Text({ text: 'Upkeep', style: { ...textStyle, ...largeText } })
          ]
        }),
  
        View({
          style: {
            ...statBoxContentStyle,
            backgroundColor: this.boxBgColor,
            borderColor: this.boxBorderColor,
            flexDirection: 'row',
            flexWrap: 'wrap',
            alignItems: 'center',
            justifyContent: 'center',
            paddingTop: 4,
            paddingBottom: 4
          },
          children: this.upkeepResourcesWithBindings.flatMap(resource => [
            Image({
              source: resource.iconBinding,
              style: resourceIconStyle,
            }),
            UINode.if(resource.showNameBinding, Text({
              text: resource.nameBinding,
              style: { ...textStyle, ...regularText }
            })),
            Text({
              text: resource.amountBinding,
              style: { ...textStyle, ...regularText, marginRight: 6 }
            }),
          ])
        })
      ]
    });
  }  

  private renderLockMessage(): UINode {
    return Text({
      text: 'Locked',
      style: { ...textStyle, ...largeText }
    });
  }

  // private renderSlotActions(): UINode {
  //   return View({
  //     style: { flex: 1 },
  //     children: [
  //       View({
  //         style: {
  //           ...statBoxHeaderStyle,
  //           width: 790,
  //           backgroundColor: this.slotActionsBoxColor,
  //           borderColor: this.boxBorderColor,
  //           justifyContent: 'center',
  //         },
  //         children: [
  //           Image({
  //             source: ImageSource.fromTextureAsset(this.props.Background),
  //             style: { ...slotBackgroundStyle, opacity: .5 }
  //           }),
  //           Text({ text: 'Building Actions', style: { ...textStyle, ...largeText } }),
  //         ],
  //       }),
  
  //       View({
  //         style: {
  //           ...statBoxContentStyle,
  //           width: 790,
  //           backgroundColor: this.boxBgColor,
  //           borderColor: this.boxBorderColor,
  //           flexDirection: 'row',
  //           padding: 6,
  //         },
  //         children: [
  //           // Upgrade Side
  //           View({
  //             style: {
  //               flex: 1,
  //               flexDirection: 'column',
  //               justifyContent: 'space-between',
  //               alignItems: 'center',
  //               paddingVertical: 6,
  //             },
  //             children: [
  //               // Top
  //               View({
  //                 style: {
  //                   maxWidth: '85%',
  //                   alignItems: 'center',
  //                   marginBottom: 6,
  //                 },
  //                 children: [
  //                   Text({
  //                     text: 'To upgrade this building, you must have the following resources available',
  //                     style: { ...textStyle, ...smallText },
  //                   })
  //                 ]
  //               }),
  //               View({
  //                 style: {
  //                   minHeight: 50,
  //                   justifyContent: 'center',
  //                   alignItems: 'center',
  //                   flexDirection: 'row',
  //                   flexWrap: 'wrap',
  //                   paddingBottom: 4,
  //                 },
  //                 children: this.costResourcesWithBindings.flatMap(resource => [
  //                   Image({ source: resource.iconBinding, style: resourceIconStyle }),
  //                   UINode.if(resource.showNameBinding, Text({
  //                     text: resource.nameBinding,
  //                     style: { ...textStyle, ...regularText }
  //                   })),
  //                   Text({
  //                     text: resource.amountBinding,
  //                     style: { ...textStyle, ...regularText, marginRight: 6 }
  //                   }),
  //                 ]),
  //               }),
  //               // Bottom (button)
  //               Pressable({
  //                 onPress: (player) => this.handleButtonClick(player, 'upgrade'),
  //                 onEnter: (player) => this.handleHoverStart(player, 'upgrade'),
  //                 onExit: (player) => this.handleHoverEnd(player, 'upgrade'),
  //                 children: [
  //                   View({
  //                     style: {
  //                       ...slotButtonStyle,
  //                       backgroundColor: this.upgradeButtonColor,
  //                     },
  //                     children: [
  //                       Image({
  //                         source: ImageSource.fromTextureAsset(this.props.Background),
  //                         style: buttonBgStyle
  //                       }),
  //                       Text({ text: this.upgradeBinding, style: { ...textStyle, ...largeText } })
  //                     ]
  //                   })
  //                 ]
  //               })
  //             ]
  //           }),
  
  //           // Collect Side
  //           View({
  //             style: {
  //               flex: 1,
  //               flexDirection: 'column',
  //               justifyContent: 'space-between',
  //               alignItems: 'center',
  //               paddingVertical: 6,
  //             },
  //             children: [
  //               // Top
  //               View({
  //                 style: {
  //                   minHeight: 50,
  //                   justifyContent: 'center',
  //                   alignItems: 'center',
  //                 },
  //                 children: [
  //                   Text({
  //                     text: this.resourcesWaitingBinding,
  //                     style: { ...textStyle, ...smallText }
  //                   })
  //                 ]
  //               }),
  //               // Bottom (button)
  //               Pressable({
  //                 onPress: (player) => this.handleButtonClick(player, 'collect'),
  //                 onEnter: (player) => this.handleHoverStart(player, 'collect'),
  //                 onExit: (player) => this.handleHoverEnd(player, 'collect'),
  //                 children: [
  //                   View({
  //                     style: {
  //                       ...slotButtonStyle,
  //                       backgroundColor: this.collectButtonColor,
  //                     },
  //                     children: [
  //                       Image({
  //                         source: ImageSource.fromTextureAsset(this.props.Background),
  //                         style: buttonBgStyle
  //                       }),
  //                       Text({ text: this.collectBinding, style: { ...textStyle, ...largeText } })
  //                     ]
  //                   })
  //                 ]
  //               })
  //             ]
  //           })
  //         ]
  //       })
  //     ]
  //   });
  // }  

  private renderUpgradeButton(): UINode {
    return Pressable({
      onPress: (player) => this.handleButtonClick(player, 'upgrade'),
      onEnter: (player) => this.handleHoverStart(player, 'upgrade'),
      onExit: (player) => this.handleHoverEnd(player, 'upgrade'),
      children: [
        View({
          style: {
            ...slotButtonStyle,
            width: 790,
            backgroundColor: this.upgradeButtonColor,
            marginTop: 6,
            overflow: 'hidden',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: buttonBgStyle,
            }),
            View({
              style: {
                flexDirection: 'row',
                alignItems: 'center',
                justifyContent: 'center',
                flexWrap: 'wrap',
                paddingHorizontal: 6,
              },
              children: [
                Text({
                  text: this.upgradeBinding,
                  style: { ...textStyle, ...regularText },
                }),
                ...this.costResourcesWithBindings.flatMap(res => [
                  Image({ source: res.iconBinding, style: resourceIconStyle }),
                  Text({
                    text: res.amountBinding,
                    style: { ...textStyle, ...regularText }
                  })
                ])
              ]
            })
          ]
        })
      ]
    });
  }  
  
  // private renderCollectButton(): UINode {
  //   return View({
  //     style: { flex: 1 },
  //     children: [
  //       View({
  //         style: {
  //           ...statBoxHeaderStyle,
  //           backgroundColor: this.collectBoxColor,
  //           borderColor: this.boxBorderColor,
  //           justifyContent: 'center',
  //         },
  //         children: [
  //           Image({
  //             source: ImageSource.fromTextureAsset(this.props.Background),
  //             style: slotBackgroundStyle,
  //           }),
  //           Text({ text: 'Slot Actions', style: { ...textStyle, ...largeText } }),
  //         ],
  //       }),
  
  //       View({
  //         style: {
  //           ...statBoxContentStyle,
  //           backgroundColor: this.boxBgColor,
  //           borderColor: this.boxBorderColor,
  //           alignItems: 'center',
  //         },
  //         children: [
  //           Pressable({
  //             onPress: (player) => this.handleButtonClick(player, 'collect'),
  //             onEnter: (player) => this.handleHoverStart(player, 'collect'),
  //             onExit: (player) => this.handleHoverEnd(player, 'collect'),
  //             children: [
  //               View({
  //                 style: {
  //                   ...slotButtonStyle,
  //                   backgroundColor: this.collectButtonColor,
  //                   marginTop: 6,
  //                   overflow: 'hidden',
  //                   width: 370,
  //                 },
  //                 children: [
  //                   Image({
  //                     source: ImageSource.fromTextureAsset(this.props.Background),
  //                     style: buttonBgStyle,
  //                   }),
  //                   Text({ text: this.collectBinding, style: { ...textStyle, ...largeText } })
  //                 ]
  //               })
  //             ]
  //           })
  //         ]
  //       })
  //     ]
  //   });
  // }  

  private renderBuyButton(): UINode {
    return Pressable({
      onPress: (player) => this.handleButtonClick(player, 'buy'),
      onEnter: (player) => this.handleHoverStart(player, 'buy'),
      onExit: (player) => this.handleHoverEnd(player, 'buy'),
      children: [
        View({
          style: {
            ...slotButtonStyle,
            width: 790,
            backgroundColor: this.buyButtonColor,
            marginTop: 6,
            overflow: 'hidden',
            flexDirection: 'row',
            alignItems: 'center',
            justifyContent: 'center',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: buttonBgStyle,
            }),
            Text({
              text: this.buyBinding,
              style: { ...textStyle, ...regularText },
            }),
            ...this.costResourcesWithBindings.flatMap(res => [
              Image({ source: res.iconBinding, style: resourceIconStyle }),
              Text({
                text: res.amountBinding,
                style: { ...textStyle, ...regularText }
              })
            ])
          ]
        })
      ]
    });
  }

  private handleUI(data: SlotUIDataStruc): void {
    // Sent notification?
    if (data.slotMessage) {
      console.log(`Received slotMessage: ${data.slotMessage}`);
      const msg = data.slotMessage;
      const msgId = this.nextSlotMessageId++;
    
      this.currentSlotMessageId = msgId;
      this.slotNotificationBinding.set(msg);
    
      this.async.setTimeout(() => {
        if (this.currentSlotMessageId === msgId) {
          this.slotNotificationBinding.set('');
        }
      }, 5000);
    }

    if (data.areaId !== undefined) this.areaId = data.areaId;
    if (data.slotId !== undefined) this.slotId = data.slotId;
    
    if (data.visible !== undefined) {
      this.entity.visible.set(data.visible);
    }
    
    if (data.slotGameData) {
      this.nameBinding.set(data.slotGameData.name);
      this.techStringBinding.set(data.slotGameData.techString ?? '');
      this.statsForFunBinding.set(data.slotGameData.statsForFun ?? '');
    }
  
    if (data.slotSaveData) {
      const save = data.slotSaveData;

      // Change rendering
      if (save.level === -1) {
        this.slotStatusBinding.set('locked');
      } else if (save.level === 0) {
        this.slotStatusBinding.set('available');
      } else {
        this.slotStatusBinding.set('unlocked');
      }
  
      // Level and Upgrades
      this.levelBinding.set(`Level ${save.level}`);
      this.upgradeLevelBinding.set(`${save.upgrades} upgrades`);
  
      // Workers
      this.workersBinding.set(`${save.curWorkers + 1} / ${save.maxWorkers + 1}`);
  
      // Storage
      const currentStorageSum = save.currentStorageResources.reduce((sum, res) => sum + (res.amount ?? 0), 0);

      if (currentStorageSum > 0) {
        this.resourcesWaitingBinding.set('Resources awaiting collection..');
      } else {
        this.resourcesWaitingBinding.set('');
      }

      const maxStorageSum = save.maxStorageResources.reduce((sum, res) => sum + (res.amount ?? 0), 0);
      this.storageBinding.set(`${currentStorageSum.toFixed(0)} / ${maxStorageSum.toFixed(0)}`);
      
      // Production     
      this.updateResourceBindings(save.productionResources, this.productionResourcesWithBindings);

      // Upkeep  
      this.updateResourceBindings(save.upkeepResources, this.upkeepResourcesWithBindings);

      // Cost
      this.updateResourceBindings(save.costResources, this.costResourcesWithBindings);

      // Determine slot type from upkeepResources array
      const upkeepArray = save.upkeepResources;
      if (!upkeepArray || upkeepArray.length === 0) {
        this.slotTypeBinding.set('storage');
      } else if (upkeepArray.length === 1 && upkeepArray[0].resourceId === 1) {
        this.slotTypeBinding.set('rawProduce');
      } else {
        this.slotTypeBinding.set('refinery');
      }
    }
  }  

  private updateResourceBindings(
    data: { resourceId: number; amount: number }[],
    target: ResourceWithBindings[]
  ): void {
    for (let i = 0; i < target.length; i++) {
      if (i < data.length) {
        const res = data[i];
        const name = resourceNames[res.resourceId] ?? 'Unknown';
        const iconAsset = this.props[name as keyof typeof this.props] as hz.Asset | undefined;
        const iconSource = iconAsset ? ImageSource.fromTextureAsset(iconAsset) : new ImageSource();
  
        target[i].iconBinding.set(iconSource);
        target[i].nameBinding.set(name);
        target[i].amountBinding.set(this.formatCompactNumber(res.amount));
        target[i].showNameBinding.set(!iconAsset);
      } else {
        target[i].iconBinding.set(new ImageSource());
        target[i].nameBinding.set('');
        target[i].amountBinding.set('');
        target[i].showNameBinding.set(false);
      }
    }
  }
  
  private handleButtonClick(player: hz.Player, action: string): void {
    switch (action) {
      case 'buy':
        this.sendNetworkBroadcastEvent(tryBuySlot, {
          player,
          areaId: this.areaId,
          slotId: this.slotId
        });
        break;
      case 'upgrade':
        this.sendNetworkBroadcastEvent(tryBuySlot, {
          player,
          areaId: this.areaId,
          slotId: this.slotId
        });
        break;
      case 'collect':
        this.sendNetworkBroadcastEvent(takeFromSlotStorage, {
          player,
          areaId: this.areaId,
          slotId: this.slotId
        });
        break;
      case 'addWorker':
        this.sendNetworkBroadcastEvent(addWorkerToSlot, {
          player,
          areaId: this.areaId,
          slotId: this.slotId
        });
        break;
      case 'removeWorker':
        this.sendNetworkBroadcastEvent(removeWorkerFromSlot, {
          player,
          areaId: this.areaId,
          slotId: this.slotId
        });
        break;
    }
  }

  private handleHoverStart(player: hz.Player, action: string): void {
    switch (action) {
      case 'buy':
        this.buyButtonColor.set(hz.Color.fromHex('#A1744D'), [player]);
        break;
      case 'upgrade':
        this.upgradeButtonColor.set(hz.Color.fromHex('#A1744D'), [player]);
        break;
      case 'collect':
        this.collectButtonColor.set(hz.Color.fromHex('#89a76b'), [player]);
        break;
      case 'addWorker':
        this.addWorkerButtonColor.set(hz.Color.fromHex('#89a76b'), [player]);
        break;
      case 'removeWorker':
        this.removeWorkerButtonColor.set(hz.Color.fromHex('#cd706a'), [player]);
        break;
    }
  }  

  private handleHoverEnd(player: hz.Player, action: string): void {
    switch (action) {
      case 'buy':
        this.buyButtonColor.set(hz.Color.fromHex('#8B5E3C'), [player]);
        break;
      case 'upgrade':
        this.upgradeButtonColor.set(hz.Color.fromHex('#8B5E3C'), [player]);
        break;
      case 'collect':
        this.collectButtonColor.set(hz.Color.fromHex('#728f58'), [player]);
        break;
      case 'addWorker':
        this.addWorkerButtonColor.set(hz.Color.fromHex('#728f58'), [player]);
        break;
      case 'removeWorker':
        this.removeWorkerButtonColor.set(hz.Color.fromHex('#aa544f'), [player]);
        break;
    }
  }  

  private formatCompactNumber(value: number): string {
    if (value >= 1_000_000_000_000_000_000_000) {
      return (value / 1_000_000_000_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'S';
    } else if (value >= 1_000_000_000_000_000) {
      return (value / 1_000_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'Q';
    } else if (value >= 1_000_000_000_000) {
      return (value / 1_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'T';
    } else if (value >= 1_000_000_000) {
      return (value / 1_000_000_000).toFixed(1).replace(/\.0$/, '') + 'B';
    } else if (value >= 1_000_000) {
      return (value / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
    } else if (value >= 1_000) {
      return (value / 1_000).toFixed(1).replace(/\.0$/, '') + 'K';
    } else {
      return value.toString();
    }
  }
}

hz.Component.register(UI_Slot);
    }
  }
}

hz.Component.register(UI_Saloon);
import * as hz from 'horizon/core';


import {
  UIComponent,
  Binding,
  UINode,
  View,
  Text,
  ViewStyle,
  Pressable,
  Image,
  ImageSource
} from 'horizon/ui';


import {
  textStyle,
  extraLargeText,
  largeText,
  regularText,
  panelStyle,
  buttonStyle,
  defaultButtonColor,
  hoverButtonColor,
  pressedButtonColor,
  backgroundStyle,
  resourceIconStyle,
  smallText
} from './UI_CommonStyles';


import { onUIReady, updateSlot } from 'UIManager';
import { SlotUIDataStruc, tryBuySlot, takeFromSlotStorage, addWorkerToSlot, removeWorkerFromSlot } from 'PlayerManager';


const resourceNames: Record<number, string> = {
  1: 'Coins',
  2: 'Logs',
  3: 'Planks',
  4: 'IronOre',
  5: 'Tools',
  6: 'Coal',
  7: 'Steel',
  8: 'GoldNuggets',
  9: 'GoldBars',
};


const topColumnStyle: ViewStyle = {
  //width: 275,
  flex: 1
};


const buttonRowContainerStyle: ViewStyle = {
  flexDirection: 'row',
  justifyContent: 'flex-start',
  marginTop: 8
};


const statRowContainerStyle: ViewStyle = {
  flexDirection: 'row',
  justifyContent: 'flex-start',
  marginTop: 8,
  marginBottom: 8
};


const statBoxContainerStyle: ViewStyle = {
  flex: 1,
  flexDirection: 'column',
  alignSelf: 'center',
};


const statBoxStyle: ViewStyle = {
  width: 387,
  minHeight: 40,
  padding: 4,
  borderWidth: 2,
};


const statBoxHeaderStyle: ViewStyle = {
  ...statBoxStyle,
  borderTopLeftRadius: 8,
  borderTopRightRadius: 8,
  borderBottomWidth: 0,
  overflow: 'hidden'
};


const statBoxContentStyle: ViewStyle = {
  ...statBoxStyle,
  borderBottomLeftRadius: 8,
  borderBottomRightRadius: 8,
  borderTopWidth: 0,
};


const plusMinusButtonStyle: ViewStyle = {
  width: 44,
  //height: 34,
  alignItems: 'center',
  justifyContent: 'center',
  padding: 0
};


const slotBackgroundStyle: ViewStyle = {
  ...backgroundStyle,
  borderRadius: 6,
  borderBottomLeftRadius: 0,
  borderBottomRightRadius: 0,
  opacity: 0.9,
  position: 'absolute',
};


const slotButtonStyle: ViewStyle = {
  ...buttonStyle,
  width: 185,
  alignItems: 'center',
  justifyContent: 'center',
  //borderWidth: 0,
  //borderColor: hz.Color.fromHex('#5a6675'),
  overflow: 'hidden',
};


const buttonBgStyle: ViewStyle = {
  ...backgroundStyle,
  borderRadius: 6,
  opacity: 0.4,
};


type ResourceWithBindings = {
  iconBinding: Binding<ImageSource>;
  nameBinding: Binding<string>;
  amountBinding: Binding<string>;
  showNameBinding: Binding<boolean>;
};


class UI_Slot extends UIComponent {
  static propsDefinition = {
    Background: { type: hz.PropTypes.Asset },


    Coins: { type: hz.PropTypes.Asset },
    Logs: { type: hz.PropTypes.Asset },
    Planks: { type: hz.PropTypes.Asset },
    IronOre: { type: hz.PropTypes.Asset },
    Tools: { type: hz.PropTypes.Asset },
    Coal: { type: hz.PropTypes.Asset },
    Steel: { type: hz.PropTypes.Asset },
    GoldNuggets: { type: hz.PropTypes.Asset },
    GoldBars: { type: hz.PropTypes.Asset },
  };


  private slotStatusBinding = new Binding<'locked' | 'available' | 'unlocked'>('unlocked');


  private isLocked = this.slotStatusBinding.derive(status => status === 'locked');
  private isAvailable = this.slotStatusBinding.derive(status => status === 'available');
  private isUnlocked = this.slotStatusBinding.derive(status => status === 'unlocked');


  private slotTypeBinding = new Binding<'rawProduce' | 'refinery' | 'storage'>('rawProduce');


  private isRawProduceBinding = this.slotTypeBinding.derive(type => type === 'rawProduce');
  private isRefineryBinding = this.slotTypeBinding.derive(type => type === 'refinery');
  private isRawProduceOrRefineryBinding = this.slotTypeBinding.derive(type => type === 'rawProduce' || type === 'refinery');


  private isStorageBinding = this.slotTypeBinding.derive(type => type === 'storage');
  private isNotStorageBinding = this.slotTypeBinding.derive(type => type !== 'storage');


  private nameBinding = new Binding<string>('Slot Name');
  private rawProducePreReqBinding = new Binding<string>('Uses Mining Camp');


  //private techNameBinding = new Binding<string>('Tech Name');
  private techStringBinding = new Binding<string>('Tech Description');


  private levelBinding = new Binding<string>('Level: 1/3');
  private upgradeLevelBinding = new Binding<string>('Upgrade Level: 1');


  private statsForFunBinding = new Binding<string>('#1# Tunnels extend #2# meters wide and #3# meters deep!');
 
  private workersBinding = new Binding<string>('Workers: 0/0');
  private maxPopBinding = 0;


  private storageBinding = new Binding<string>('Storage:');


  private productionBinding = new Binding<string>('Production:');
  private upkeepBinding = new Binding<string>('Upkeep:');


  private buyBinding = new Binding<string>('Buy for');


  private upgradeBinding = new Binding<string>('Upgrade for');
  private upgradeCostBinding = new Binding<string>('');


  private collectBinding = new Binding<string>('Collect');


  private resourcesWaitingBinding = new Binding<string>('Collect All');


  private buyButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#8B5E3C'));
  private upgradeButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#8B5E3C'));
  private collectButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#728f58'));
  private addWorkerButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#728f58'));
  private removeWorkerButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#aa544f'));
 
  private slotActionsButtonColor = new Binding<hz.Color>(hz.Color.fromHex('#48505d'));
 
  private boxBorderColor = new Binding<hz.Color>(hz.Color.fromHex('#9e722b'));
  private boxBgColor = new Binding<hz.Color>(hz.Color.fromHex('#856640'));


  private workerBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#5e5e5e'));
  private storageBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#56788a'));
  private upkeepBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#994343'));
  private productionBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#728f58'));
  private slotActionsBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#48505d'));
  // private upgradeBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#6e6259'));
  // private collectBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#c49a3a'));
  // private buyBoxColor = new Binding<hz.Color>(hz.Color.fromHex('#3b94a6'));


  private slotNotificationBinding = new Binding<string>('');
  private currentSlotMessageId = 0;
  private nextSlotMessageId = 1;
 
  private areaId: number = -1;
  private slotId: number = -1;
 
  private upkeepResourcesWithBindings: ResourceWithBindings[] = Array.from(
    { length: 4 },
    () => ({
      iconBinding: new Binding<ImageSource>(new ImageSource()),
      nameBinding: new Binding<string>(''),
      amountBinding: new Binding<string>(''),
      showNameBinding: new Binding<boolean>(false)
    })
  );  


  private productionResourcesWithBindings: ResourceWithBindings[] = Array.from(
    { length: 4 },
    () => ({
      iconBinding: new Binding<ImageSource>(new ImageSource()),
      nameBinding: new Binding<string>(''),
      amountBinding: new Binding<string>(''),
      showNameBinding: new Binding<boolean>(false)
    })
  );
 
  private costResourcesWithBindings: ResourceWithBindings[] = Array.from(
    { length: 4 },
    () => ({
      iconBinding: new Binding<ImageSource>(new ImageSource()),
      nameBinding: new Binding<string>(''),
      amountBinding: new Binding<string>(''),
      showNameBinding: new Binding<boolean>(false)
    })
  );
 
  receiveOwnership(
    state: any,
    fromPlayer: hz.Player,
    toPlayer: hz.Player
  ): void {
    console.log(`UI_Slot: receiveOwnership from server to ${toPlayer?.name.get()}`);
 
    // Tell whoever that we're initialized and ready for binding updates
    this.sendNetworkBroadcastEvent(onUIReady, {
      player: toPlayer,
      uiName: 'Slot',
      uiEntity: this.entity,
    });
  }
 
  initializeUI(): UINode {
    // Start hidden; only visible when set via updateUIName event
    this.entity.visible.set(false)


    this.connectNetworkEvent(
      this.entity,
      updateSlot,
      (data) => this.handleUI(data)
    );


    return View({
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        justifyContent: 'center',
        alignItems: 'center',
        padding: 16
      },
      children: [ this.renderSlotDataScreen() ]
    });    
  }


  panelWidth = 815;
  panelHeight = 565;


  renderSlotDataScreen(): UINode {
    return View({
      style: {
        position: 'relative',
        overflow: 'hidden',
        padding: 0
      },
      children: [
        View({
          style: {
            ...panelStyle,
            width: 810,
            //height: 595,
            padding: 8,
            flexDirection: 'column',
            position: 'relative',
            overflow: 'hidden',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: slotBackgroundStyle,
            }),
 
            this.renderHeaderSection(),
            this.renderNotification(),
            this.renderDivider(),
 
            UINode.if(this.isLocked, [
              this.renderLockMessage()
            ]),
 
            UINode.if(this.isAvailable, [
              View({
                style: statRowContainerStyle,
                children: [
                  this.renderUpkeep(),
                  this.renderProduction()
                ]
              }),
              this.renderDivider(),
              View({
                style: {
                  flexDirection: 'row',
                  justifyContent: 'center',
                  marginTop: 6
                },
                children: [
                  this.renderBuyButton()
                ]
              })
            ]),            
 
            UINode.if(this.isUnlocked, [
              UINode.if(this.isRawProduceOrRefineryBinding, [
                this.renderStatsForFun(),
                this.renderDivider(),
                View({
                  style: statRowContainerStyle,
                  children: [
                    this.renderWorkers(),
                    this.renderStorage()
                  ]
                }),
                View({
                  style: statRowContainerStyle,
                  children: [
                    this.renderUpkeep(),
                    this.renderProduction()
                  ]
                }),
                this.renderDivider(),
              ]),
              UINode.if(this.isStorageBinding, [
                this.renderStorage(),
                this.renderDivider(),
              ]),
              View({
                style: {
                  flexDirection: 'row',
                  justifyContent: 'flex-start',
                  marginTop: 6
                },
                children: [
                  // this.renderUpgradeButton(),
                  // this.renderCollectButton()
                  this.renderUpgradeButton()
                ]
              })
             
            ])
          ]
        })
      ]
    });
  }  


  private renderNotification(): UINode {
    return UINode.if(this.slotNotificationBinding.derive(msg => msg !== ''), [
      View({
        style: {
          width: '100%',
          paddingVertical: 6,
          paddingHorizontal: 10,
          marginBottom: 8,
          backgroundColor: hz.Color.fromHex('#B07C4C'),
          borderRadius: 6,
          justifyContent: 'center',
          alignItems: 'center',
        },
        children: [
          Text({
            text: this.slotNotificationBinding,
            style: {
              ...textStyle,
              ...regularText,
              color: hz.Color.white,
              textAlign: 'center',
            }
          })
        ]
      })
    ]);
  }  


  private renderHeaderSection(): UINode {
    return View({
      style: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        marginBottom: 8
      },
      children: [
        View({
          style: {
            flex: 1,
            justifyContent: 'center',
          },
          children: [
            Text({ text: this.nameBinding, style: {...textStyle, ...extraLargeText, textAlign: 'left'} }),
            // UINode.if(this.isRefineryBinding, [
            //   Text({ text: this.rawProducePreReqBinding,
            //     style: {
            //       ...regularText,
            //       color: hz.Color.fromHex('#FFCCCB')
            //     }
            //   })
            // ])
          ]
        }),
 
        View({
          style: {
            ...topColumnStyle,
            alignItems: 'flex-end',
            justifyContent: 'center'
          },
          children: [
            UINode.if(this.isUnlocked, [
              Text({ text: this.levelBinding, style: { ...textStyle, ...largeText } }),
              Text({ text: this.upgradeLevelBinding, style: { ...textStyle, ...regularText } }),
              Text({ text: this.techStringBinding, style: { ...textStyle, ...regularText, color: hz.Color.fromHex('#d89d4a') } })
            ])
          ]
        })
      ]
    });
  }
 
  private renderDivider(): UINode {
    return View({
      style: {
        height: 2,
        width: '100%',
        backgroundColor: hz.Color.fromHex('#cca678'),
      }
    });
  }
 
  private renderStatsForFun(): UINode {
    return Text({
      text: this.statsForFunBinding,
      style: { ...textStyle, ...regularText, marginTop: 4, marginBottom: 4 } });
  }


  private renderWorkers(): UINode {
    return View({
      style: { ...statBoxContainerStyle, marginRight: 12 },
      children: [
        View({
          style: {
            ...statBoxHeaderStyle,
            backgroundColor: this.workerBoxColor,
            borderColor: this.boxBorderColor,
            position: 'relative',
            justifyContent: 'center',
            alignItems: 'center',
            overflow: 'hidden'
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: { ...slotBackgroundStyle, }
            }),
            Text({ text: 'Workers', style: { ...textStyle, ...largeText } }),
            View({
              style: {
                position: 'absolute',
                right: 5,
                flexDirection: 'row',
                alignItems: 'center'
              },
              children: [
                Pressable({
                  onPress: (player) => this.handleButtonClick(player, 'addWorker'),
                  onEnter: (player) => this.handleHoverStart(player, 'addWorker'),
                  onExit: (player) => this.handleHoverEnd(player, 'addWorker'),
                  children: [
                    View({
                      style: {
                        ...buttonStyle,
                        ...plusMinusButtonStyle,
                        marginRight: 4,
                        borderWidth: 0,
                        backgroundColor: this.addWorkerButtonColor,
                        overflow: 'hidden'
                      },
                      children: [
                        Image({
                          source: ImageSource.fromTextureAsset(this.props.Background),
                          style: buttonBgStyle
                        }),
                        Text({ text: '+', style: { ...textStyle, ...largeText } })
                      ]
                    })
                  ]
                }),
                Pressable({
                  onPress: (player) => this.handleButtonClick(player, 'removeWorker'),
                  onEnter: (player) => this.handleHoverStart(player, 'removeWorker'),
                  onExit: (player) => this.handleHoverEnd(player, 'removeWorker'),
                  children: [
                    View({
                      style: {
                        ...buttonStyle,
                        ...plusMinusButtonStyle,
                        borderWidth: 0,
                        backgroundColor: this.removeWorkerButtonColor,
                        overflow: 'hidden'
                      },
                      children: [
                        Image({
                          source: ImageSource.fromTextureAsset(this.props.Background),
                          style: buttonBgStyle
                        }),
                        Text({ text: '-', style: { ...textStyle, ...largeText } })
                      ]
                    })
                  ]
                })
              ]
            })
          ]
        }),
        View({
          style: {
            ...statBoxContentStyle,
            backgroundColor: this.boxBgColor,
            borderColor: this.boxBorderColor
          },
          children: [
            Text({ text: this.workersBinding, style: { ...textStyle, ...regularText } })
          ]
        })
      ]
    });
  }  
 
  private renderStorage(): UINode {
    return View({
      style: { ...statBoxContainerStyle },
      children: [
        View({
          style: {
            ...statBoxHeaderStyle,
            backgroundColor: this.storageBoxColor,
            borderColor: this.boxBorderColor,
            position: 'relative',
            justifyContent: 'center',
            alignItems: 'center',
            overflow: 'hidden'
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: slotBackgroundStyle
            }),
            Text({ text: 'Storage', style: { ...textStyle, ...largeText } }),
 
            View({
              style: {
                position: 'absolute',
                right: 5,
                flexDirection: 'row',
                alignItems: 'center'
              },
              children: [
                Pressable({
                  onPress: (player) => this.handleButtonClick(player, 'collect'),
                  onEnter: (player) => this.handleHoverStart(player, 'collect'),
                  onExit: (player) => this.handleHoverEnd(player, 'collect'),
                  children: [
                    View({
                      style: {
                        ...buttonStyle,
                        ...plusMinusButtonStyle,
                        height: 45,
                        width: 100,
                        borderWidth: 0,
                        backgroundColor: this.collectButtonColor,
                        overflow: 'hidden',
                        alignItems: 'center',
                        justifyContent: 'center',
                      },
                      children: [
                        Image({
                          source: ImageSource.fromTextureAsset(this.props.Background),
                          style: buttonBgStyle
                        }),
                        Text({
                          text: this.collectBinding,
                          style: { ...textStyle, ...regularText },
                        }),
                      ]
                    })
                  ]
                })
              ]
            })
          ]
        }),
        View({
          style: {
            ...statBoxContentStyle,
            backgroundColor: this.boxBgColor,
            borderColor: this.boxBorderColor
          },
          children: [
            Text({ text: this.storageBinding, style: { ...textStyle, ...regularText } })
          ]
        })
      ]
    });
  }  
 
  private renderProduction(): UINode {
    return View({
      style: { ...statBoxContainerStyle },
      children: [
        View({
          style: {
            ...statBoxHeaderStyle,
            position: 'relative',
            backgroundColor: this.productionBoxColor,
            borderColor: this.boxBorderColor,
            justifyContent: 'center',
            alignItems: 'center',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: slotBackgroundStyle
            }),
            Text({ text: 'Production', style: { ...textStyle, ...largeText } })
          ]
        }),
 
        View({
          style: {
            ...statBoxContentStyle,
            backgroundColor: this.boxBgColor,
            borderColor: this.boxBorderColor,
            flexDirection: 'row',
            flexWrap: 'wrap',
            alignItems: 'center',
            justifyContent: 'center',
            paddingTop: 4,
            paddingBottom: 4
          },
          children: this.productionResourcesWithBindings.flatMap(resource => [
            Image({
              source: resource.iconBinding,
              style: resourceIconStyle,
            }),
            UINode.if(resource.showNameBinding, Text({
              text: resource.nameBinding,
              style: { ...textStyle, ...regularText }
            })),
            Text({
              text: resource.amountBinding,
              style: { ...textStyle, ...regularText, marginRight: 6 }
            }),
          ])
        })
      ]
    });
  }  
 
  private renderUpkeep(): UINode {
    return View({
      style: { ...statBoxContainerStyle, marginRight: 12 },
      children: [
        View({
          style: {
            ...statBoxHeaderStyle,
            position: 'relative',
            backgroundColor: this.upkeepBoxColor,
            borderColor: this.boxBorderColor,
            justifyContent: 'center',
            alignItems: 'center',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: slotBackgroundStyle
            }),
            Text({ text: 'Upkeep', style: { ...textStyle, ...largeText } })
          ]
        }),
 
        View({
          style: {
            ...statBoxContentStyle,
            backgroundColor: this.boxBgColor,
            borderColor: this.boxBorderColor,
            flexDirection: 'row',
            flexWrap: 'wrap',
            alignItems: 'center',
            justifyContent: 'center',
            paddingTop: 4,
            paddingBottom: 4
          },
          children: this.upkeepResourcesWithBindings.flatMap(resource => [
            Image({
              source: resource.iconBinding,
              style: resourceIconStyle,
            }),
            UINode.if(resource.showNameBinding, Text({
              text: resource.nameBinding,
              style: { ...textStyle, ...regularText }
            })),
            Text({
              text: resource.amountBinding,
              style: { ...textStyle, ...regularText, marginRight: 6 }
            }),
          ])
        })
      ]
    });
  }  


  private renderLockMessage(): UINode {
    return Text({
      text: 'Locked',
      style: { ...textStyle, ...largeText }
    });
  }


  // private renderSlotActions(): UINode {
  //   return View({
  //     style: { flex: 1 },
  //     children: [
  //       View({
  //         style: {
  //           ...statBoxHeaderStyle,
  //           width: 790,
  //           backgroundColor: this.slotActionsBoxColor,
  //           borderColor: this.boxBorderColor,
  //           justifyContent: 'center',
  //         },
  //         children: [
  //           Image({
  //             source: ImageSource.fromTextureAsset(this.props.Background),
  //             style: { ...slotBackgroundStyle, opacity: .5 }
  //           }),
  //           Text({ text: 'Building Actions', style: { ...textStyle, ...largeText } }),
  //         ],
  //       }),
 
  //       View({
  //         style: {
  //           ...statBoxContentStyle,
  //           width: 790,
  //           backgroundColor: this.boxBgColor,
  //           borderColor: this.boxBorderColor,
  //           flexDirection: 'row',
  //           padding: 6,
  //         },
  //         children: [
  //           // Upgrade Side
  //           View({
  //             style: {
  //               flex: 1,
  //               flexDirection: 'column',
  //               justifyContent: 'space-between',
  //               alignItems: 'center',
  //               paddingVertical: 6,
  //             },
  //             children: [
  //               // Top
  //               View({
  //                 style: {
  //                   maxWidth: '85%',
  //                   alignItems: 'center',
  //                   marginBottom: 6,
  //                 },
  //                 children: [
  //                   Text({
  //                     text: 'To upgrade this building, you must have the following resources available',
  //                     style: { ...textStyle, ...smallText },
  //                   })
  //                 ]
  //               }),
  //               View({
  //                 style: {
  //                   minHeight: 50,
  //                   justifyContent: 'center',
  //                   alignItems: 'center',
  //                   flexDirection: 'row',
  //                   flexWrap: 'wrap',
  //                   paddingBottom: 4,
  //                 },
  //                 children: this.costResourcesWithBindings.flatMap(resource => [
  //                   Image({ source: resource.iconBinding, style: resourceIconStyle }),
  //                   UINode.if(resource.showNameBinding, Text({
  //                     text: resource.nameBinding,
  //                     style: { ...textStyle, ...regularText }
  //                   })),
  //                   Text({
  //                     text: resource.amountBinding,
  //                     style: { ...textStyle, ...regularText, marginRight: 6 }
  //                   }),
  //                 ]),
  //               }),
  //               // Bottom (button)
  //               Pressable({
  //                 onPress: (player) => this.handleButtonClick(player, 'upgrade'),
  //                 onEnter: (player) => this.handleHoverStart(player, 'upgrade'),
  //                 onExit: (player) => this.handleHoverEnd(player, 'upgrade'),
  //                 children: [
  //                   View({
  //                     style: {
  //                       ...slotButtonStyle,
  //                       backgroundColor: this.upgradeButtonColor,
  //                     },
  //                     children: [
  //                       Image({
  //                         source: ImageSource.fromTextureAsset(this.props.Background),
  //                         style: buttonBgStyle
  //                       }),
  //                       Text({ text: this.upgradeBinding, style: { ...textStyle, ...largeText } })
  //                     ]
  //                   })
  //                 ]
  //               })
  //             ]
  //           }),
 
  //           // Collect Side
  //           View({
  //             style: {
  //               flex: 1,
  //               flexDirection: 'column',
  //               justifyContent: 'space-between',
  //               alignItems: 'center',
  //               paddingVertical: 6,
  //             },
  //             children: [
  //               // Top
  //               View({
  //                 style: {
  //                   minHeight: 50,
  //                   justifyContent: 'center',
  //                   alignItems: 'center',
  //                 },
  //                 children: [
  //                   Text({
  //                     text: this.resourcesWaitingBinding,
  //                     style: { ...textStyle, ...smallText }
  //                   })
  //                 ]
  //               }),
  //               // Bottom (button)
  //               Pressable({
  //                 onPress: (player) => this.handleButtonClick(player, 'collect'),
  //                 onEnter: (player) => this.handleHoverStart(player, 'collect'),
  //                 onExit: (player) => this.handleHoverEnd(player, 'collect'),
  //                 children: [
  //                   View({
  //                     style: {
  //                       ...slotButtonStyle,
  //                       backgroundColor: this.collectButtonColor,
  //                     },
  //                     children: [
  //                       Image({
  //                         source: ImageSource.fromTextureAsset(this.props.Background),
  //                         style: buttonBgStyle
  //                       }),
  //                       Text({ text: this.collectBinding, style: { ...textStyle, ...largeText } })
  //                     ]
  //                   })
  //                 ]
  //               })
  //             ]
  //           })
  //         ]
  //       })
  //     ]
  //   });
  // }  


  private renderUpgradeButton(): UINode {
    return Pressable({
      onPress: (player) => this.handleButtonClick(player, 'upgrade'),
      onEnter: (player) => this.handleHoverStart(player, 'upgrade'),
      onExit: (player) => this.handleHoverEnd(player, 'upgrade'),
      children: [
        View({
          style: {
            ...slotButtonStyle,
            width: 790,
            backgroundColor: this.upgradeButtonColor,
            marginTop: 6,
            overflow: 'hidden',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: buttonBgStyle,
            }),
            View({
              style: {
                flexDirection: 'row',
                alignItems: 'center',
                justifyContent: 'center',
                flexWrap: 'wrap',
                paddingHorizontal: 6,
              },
              children: [
                Text({
                  text: this.upgradeBinding,
                  style: { ...textStyle, ...regularText },
                }),
                ...this.costResourcesWithBindings.flatMap(res => [
                  Image({ source: res.iconBinding, style: resourceIconStyle }),
                  Text({
                    text: res.amountBinding,
                    style: { ...textStyle, ...regularText }
                  })
                ])
              ]
            })
          ]
        })
      ]
    });
  }  
 
  // private renderCollectButton(): UINode {
  //   return View({
  //     style: { flex: 1 },
  //     children: [
  //       View({
  //         style: {
  //           ...statBoxHeaderStyle,
  //           backgroundColor: this.collectBoxColor,
  //           borderColor: this.boxBorderColor,
  //           justifyContent: 'center',
  //         },
  //         children: [
  //           Image({
  //             source: ImageSource.fromTextureAsset(this.props.Background),
  //             style: slotBackgroundStyle,
  //           }),
  //           Text({ text: 'Slot Actions', style: { ...textStyle, ...largeText } }),
  //         ],
  //       }),
 
  //       View({
  //         style: {
  //           ...statBoxContentStyle,
  //           backgroundColor: this.boxBgColor,
  //           borderColor: this.boxBorderColor,
  //           alignItems: 'center',
  //         },
  //         children: [
  //           Pressable({
  //             onPress: (player) => this.handleButtonClick(player, 'collect'),
  //             onEnter: (player) => this.handleHoverStart(player, 'collect'),
  //             onExit: (player) => this.handleHoverEnd(player, 'collect'),
  //             children: [
  //               View({
  //                 style: {
  //                   ...slotButtonStyle,
  //                   backgroundColor: this.collectButtonColor,
  //                   marginTop: 6,
  //                   overflow: 'hidden',
  //                   width: 370,
  //                 },
  //                 children: [
  //                   Image({
  //                     source: ImageSource.fromTextureAsset(this.props.Background),
  //                     style: buttonBgStyle,
  //                   }),
  //                   Text({ text: this.collectBinding, style: { ...textStyle, ...largeText } })
  //                 ]
  //               })
  //             ]
  //           })
  //         ]
  //       })
  //     ]
  //   });
  // }  


  private renderBuyButton(): UINode {
    return Pressable({
      onPress: (player) => this.handleButtonClick(player, 'buy'),
      onEnter: (player) => this.handleHoverStart(player, 'buy'),
      onExit: (player) => this.handleHoverEnd(player, 'buy'),
      children: [
        View({
          style: {
            ...slotButtonStyle,
            width: 790,
            backgroundColor: this.buyButtonColor,
            marginTop: 6,
            overflow: 'hidden',
            flexDirection: 'row',
            alignItems: 'center',
            justifyContent: 'center',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: buttonBgStyle,
            }),
            Text({
              text: this.buyBinding,
              style: { ...textStyle, ...regularText },
            }),
            ...this.costResourcesWithBindings.flatMap(res => [
              Image({ source: res.iconBinding, style: resourceIconStyle }),
              Text({
                text: res.amountBinding,
                style: { ...textStyle, ...regularText }
              })
            ])
          ]
        })
      ]
    });
  }


  private handleUI(data: SlotUIDataStruc): void {
    // Sent notification?
    if (data.slotMessage) {
      console.log(`Received slotMessage: ${data.slotMessage}`);
      const msg = data.slotMessage;
      const msgId = this.nextSlotMessageId++;
   
      this.currentSlotMessageId = msgId;
      this.slotNotificationBinding.set(msg);
   
      this.async.setTimeout(() => {
        if (this.currentSlotMessageId === msgId) {
          this.slotNotificationBinding.set('');
        }
      }, 5000);
    }


    if (data.areaId !== undefined) this.areaId = data.areaId;
    if (data.slotId !== undefined) this.slotId = data.slotId;
   
    if (data.visible !== undefined) {
      this.entity.visible.set(data.visible);
    }
   
    if (data.slotGameData) {
      this.nameBinding.set(data.slotGameData.name);
      this.techStringBinding.set(data.slotGameData.techString ?? '');
      this.statsForFunBinding.set(data.slotGameData.statsForFun ?? '');
    }
 
    if (data.slotSaveData) {
      const save = data.slotSaveData;


      // Change rendering
      if (save.level === -1) {
        this.slotStatusBinding.set('locked');
      } else if (save.level === 0) {
        this.slotStatusBinding.set('available');
      } else {
        this.slotStatusBinding.set('unlocked');
      }
 
      // Level and Upgrades
      this.levelBinding.set(`Level ${save.level}`);
      this.upgradeLevelBinding.set(`${save.upgrades} upgrades`);
 
      // Workers
      this.workersBinding.set(`${save.curWorkers + 1} / ${save.maxWorkers + 1}`);
 
      // Storage
      const currentStorageSum = save.currentStorageResources.reduce((sum, res) => sum + (res.amount ?? 0), 0);


      if (currentStorageSum > 0) {
        this.resourcesWaitingBinding.set('Resources awaiting collection..');
      } else {
        this.resourcesWaitingBinding.set('');
      }


      const maxStorageSum = save.maxStorageResources.reduce((sum, res) => sum + (res.amount ?? 0), 0);
      this.storageBinding.set(`${currentStorageSum.toFixed(0)} / ${maxStorageSum.toFixed(0)}`);
     
      // Production    
      this.updateResourceBindings(save.productionResources, this.productionResourcesWithBindings);


      // Upkeep  
      this.updateResourceBindings(save.upkeepResources, this.upkeepResourcesWithBindings);


      // Cost
      this.updateResourceBindings(save.costResources, this.costResourcesWithBindings);


      // Determine slot type from upkeepResources array
      const upkeepArray = save.upkeepResources;
      if (!upkeepArray || upkeepArray.length === 0) {
        this.slotTypeBinding.set('storage');
      } else if (upkeepArray.length === 1 && upkeepArray[0].resourceId === 1) {
        this.slotTypeBinding.set('rawProduce');
      } else {
        this.slotTypeBinding.set('refinery');
      }
    }
  }  


  private updateResourceBindings(
    data: { resourceId: number; amount: number }[],
    target: ResourceWithBindings[]
  ): void {
    for (let i = 0; i < target.length; i++) {
      if (i < data.length) {
        const res = data[i];
        const name = resourceNames[res.resourceId] ?? 'Unknown';
        const iconAsset = this.props[name as keyof typeof this.props] as hz.Asset | undefined;
        const iconSource = iconAsset ? ImageSource.fromTextureAsset(iconAsset) : new ImageSource();
 
        target[i].iconBinding.set(iconSource);
        target[i].nameBinding.set(name);
        target[i].amountBinding.set(this.formatCompactNumber(res.amount));
        target[i].showNameBinding.set(!iconAsset);
      } else {
        target[i].iconBinding.set(new ImageSource());
        target[i].nameBinding.set('');
        target[i].amountBinding.set('');
        target[i].showNameBinding.set(false);
      }
    }
  }
 
  private handleButtonClick(player: hz.Player, action: string): void {
    switch (action) {
      case 'buy':
        this.sendNetworkBroadcastEvent(tryBuySlot, {
          player,
          areaId: this.areaId,
          slotId: this.slotId
        });
        break;
      case 'upgrade':
        this.sendNetworkBroadcastEvent(tryBuySlot, {
          player,
          areaId: this.areaId,
          slotId: this.slotId
        });
        break;
      case 'collect':
        this.sendNetworkBroadcastEvent(takeFromSlotStorage, {
          player,
          areaId: this.areaId,
          slotId: this.slotId
        });
        break;
      case 'addWorker':
        this.sendNetworkBroadcastEvent(addWorkerToSlot, {
          player,
          areaId: this.areaId,
          slotId: this.slotId
        });
        break;
      case 'removeWorker':
        this.sendNetworkBroadcastEvent(removeWorkerFromSlot, {
          player,
          areaId: this.areaId,
          slotId: this.slotId
        });
        break;
    }
  }


  private handleHoverStart(player: hz.Player, action: string): void {
    switch (action) {
      case 'buy':
        this.buyButtonColor.set(hz.Color.fromHex('#A1744D'), [player]);
        break;
      case 'upgrade':
        this.upgradeButtonColor.set(hz.Color.fromHex('#A1744D'), [player]);
        break;
      case 'collect':
        this.collectButtonColor.set(hz.Color.fromHex('#89a76b'), [player]);
        break;
      case 'addWorker':
        this.addWorkerButtonColor.set(hz.Color.fromHex('#89a76b'), [player]);
        break;
      case 'removeWorker':
        this.removeWorkerButtonColor.set(hz.Color.fromHex('#cd706a'), [player]);
        break;
    }
  }  


  private handleHoverEnd(player: hz.Player, action: string): void {
    switch (action) {
      case 'buy':
        this.buyButtonColor.set(hz.Color.fromHex('#8B5E3C'), [player]);
        break;
      case 'upgrade':
        this.upgradeButtonColor.set(hz.Color.fromHex('#8B5E3C'), [player]);
        break;
      case 'collect':
        this.collectButtonColor.set(hz.Color.fromHex('#728f58'), [player]);
        break;
      case 'addWorker':
        this.addWorkerButtonColor.set(hz.Color.fromHex('#728f58'), [player]);
        break;
      case 'removeWorker':
        this.removeWorkerButtonColor.set(hz.Color.fromHex('#aa544f'), [player]);
        break;
    }
  }  


  private formatCompactNumber(value: number): string {
    if (value >= 1_000_000_000_000_000_000_000) {
      return (value / 1_000_000_000_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'S';
    } else if (value >= 1_000_000_000_000_000) {
      return (value / 1_000_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'Q';
    } else if (value >= 1_000_000_000_000) {
      return (value / 1_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'T';
    } else if (value >= 1_000_000_000) {
      return (value / 1_000_000_000).toFixed(1).replace(/\.0$/, '') + 'B';
    } else if (value >= 1_000_000) {
      return (value / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
    } else if (value >= 1_000) {
      return (value / 1_000).toFixed(1).replace(/\.0$/, '') + 'K';
    } else {
      return value.toString();
    }
  }
}


hz.Component.register(UI_Slot);

import * as hz from 'horizon/core';

import {
  View,
  Text,
  Image,
  Binding,
  UIComponent,
  UINode,
  ImageSource,
  ViewStyle,
  Pressable,
  ScrollView,
  AnimatedBinding,
  Animation
} from 'horizon/ui';

import { 
  textStyle,
  regularText, 
  panelStyle,
  fullscreenCenterStyle,
  buttonStyle,
  defaultButtonColor,
  hoverButtonColor,
  pressedButtonColor,
  resourceIconStyle,
  smallText,
  backgroundStyle,
} from 'UI_CommonStyles';

import { onUIReady, updateTrader } from 'UIManager';
import { registerResourceData, ResourceDataStruc } from './GameData';
import { TraderResourceStruc, TraderUIDataStruc, sellResource } from 'PlayerManager';

const emptyImageSource = new ImageSource();

const panelStyleWithColumn: ViewStyle = {
  ...panelStyle,
  //width: 450,
  width: 900,
  maxHeight: 600,
  padding: 16,
  flexDirection: 'column',
  justifyContent: 'flex-start',
  alignItems: 'stretch',
  //borderBottomWidth: 0,
  //borderBottomLeftRadius: 0,
  //borderBottomRightRadius: 0
};

const toggleRowStyle: ViewStyle = {
  flexDirection: 'row',
  justifyContent: 'center',
  alignItems: 'center',
  marginBottom: 12,
};

const resourceRowStyle: ViewStyle = {
  flexDirection: 'row',
  justifyContent: 'space-between',
  alignItems: 'center',
  paddingVertical: 8,
  //borderBottomWidth: 6,
  //borderColor: hz.Color.fromHex('#C2976B'),
};

const leftColumnStyle: ViewStyle = {
  flexDirection: 'column',
  alignItems: 'stretch',
  flex: 1,
};

const rightColumnStyle: ViewStyle = {
  flexDirection: 'column',
  alignItems: 'flex-end',
};

type SellMode = 'x1' | '5%' | '25%' | 'All';

type ResourceWithBindings = {
  resourceId: number;
  rawAmount: number;
  rawPrice: number;
  rawSellAmount: number;
  
  nameBinding: Binding<string>;
  colourBinding: Binding<hz.Color>;
  amountBinding: Binding<string>;
  iconBinding: Binding<ImageSource>;
  visibleBinding: Binding<boolean>;
  
  priceBinding: Binding<string>;
  priceColorBinding: Binding<hz.Color>;
  sellAmountBinding: Binding<string>;
  sellValueBinding: Binding<string>;
  sellButtonColorBinding: Binding<hz.Color>;
  canSellBinding: Binding<boolean>;

  unstableAnimBinding: AnimatedBinding;
  isBoldPriceBinding: Binding<boolean>;
  priceShadowColorBinding: Binding<hz.Color>;
};

class UI_Trader extends UIComponent {
  static propsDefinition = {
    Background: { type: hz.PropTypes.Asset },
    
    Coins: { type: hz.PropTypes.Asset },
    Logs: { type: hz.PropTypes.Asset },
    Planks: { type: hz.PropTypes.Asset },
    // Stone: { type: hz.PropTypes.Asset },
    // Concrete: { type: hz.PropTypes.Asset },
    IronOre: { type: hz.PropTypes.Asset },
    Tools: { type: hz.PropTypes.Asset },
    Coal: { type: hz.PropTypes.Asset },
    Steel: { type: hz.PropTypes.Asset },
    GoldNuggets: { type: hz.PropTypes.Asset },
    GoldBars: { type: hz.PropTypes.Asset },

    showResourceName: { type: hz.PropTypes.Boolean },
    showResourceIcon: { type: hz.PropTypes.Boolean },
  };

  private defaultToggleColor = hz.Color.fromHex('#4B2E1D');
  private hoverToggleColor = hz.Color.fromHex('#7A4B2C');
  private selectedToggleColor = hz.Color.fromHex('#C97D4A');

  private defaultSellButtonColor = hz.Color.fromHex('#8B5E3C');
  private hoverSellButtonColor = hz.Color.fromHex('#A1744D');

  
  private defaultCloseButtonColor = hz.Color.fromHex('#A33E2D');
  private hoverCloseButtonColor = hz.Color.fromHex('#C75033');
  private closeButtonColor = new Binding(this.defaultCloseButtonColor);

  private resourceCount = 9;
  private resources: ResourceWithBindings[] = Array.from(
    { length: this.resourceCount },
    (_, i) => i + 1
  )
  .filter(resourceId => resourceId !== 1) // Don't include coins
  .map(resourceId => ({
    resourceId,
    rawAmount: 0,
    rawPrice: 0,
    rawSellAmount: 0,
    
    nameBinding: new Binding(`Resource ${resourceId}`),
    colourBinding: new Binding(hz.Color.white),
    amountBinding: new Binding('0'),
    iconBinding: new Binding<ImageSource>(emptyImageSource),
  
    visibleBinding: new Binding<boolean>(true),
    
    priceBinding: new Binding('0'),
    priceColorBinding: new Binding<hz.Color>(hz.Color.white),
    sellAmountBinding: new Binding('0'),
    sellValueBinding: new Binding('0'),
    sellButtonColorBinding: new Binding(this.defaultSellButtonColor),
    canSellBinding: new Binding(false),

    unstableAnimBinding: new AnimatedBinding(0),
    isBoldPriceBinding: new Binding(false),
    priceShadowColorBinding: new Binding(hz.Color.fromHex('#000000')),
  }));
  

  private selectedSellMode: SellMode = 'x1';
  private toggleButtonColors: Record<SellMode, Binding<hz.Color>> = {
    'x1': new Binding(this.selectedSellMode === 'x1' ? this.selectedToggleColor : this.defaultToggleColor),
    '5%': new Binding(this.selectedSellMode === '5%' ? this.selectedToggleColor : this.defaultToggleColor),
    '25%': new Binding(this.selectedSellMode === '25%' ? this.selectedToggleColor : this.defaultToggleColor),
    'All': new Binding(this.selectedSellMode === 'All' ? this.selectedToggleColor : this.defaultToggleColor),
  };  

  receiveOwnership(
    state: any,
    fromPlayer: hz.Player,
    toPlayer: hz.Player
  ): void {
    console.log(`UI_Trader: receiveOwnership from server to ${toPlayer?.name.get()}`);

    this.sendNetworkBroadcastEvent(onUIReady, {
      player: toPlayer,
      uiName: 'Trader',
      uiEntity: this.entity
    });
  }  

  initializeUI(): UINode {
    this.entity.visible.set(false);

    const showResourceName = this.props.showResourceName !== false;
    const showResourceIcon = this.props.showResourceIcon !== false;

    this.connectNetworkEvent(
      this.entity,
      registerResourceData,
      (data: { resourceGameData: ResourceDataStruc[] }) => {
        this.handleUI({ resourceGameData: data.resourceGameData });
      }
    );

    this.connectNetworkEvent(
      this.entity,
      updateTrader,
      (data) => this.handleUI(data)
    );

    this.toggleButtonColors[this.selectedSellMode].set(this.selectedToggleColor);
    return this.renderUI(showResourceName, showResourceIcon);
  }

  private renderUI(showResourceName: boolean, showResourceIcon: boolean): UINode {
    // Toggle buttons
    const sellModes: SellMode[] = ['x1', '5%', '25%', 'All'];
    const toggleButtons: UINode[] = sellModes.map((mode, index, arr) =>
      Pressable({
        onPress: (player) => this.handleToggleClick(player, mode),
        onEnter: (player) => this.handleToggleHover(player, mode),
        onExit: (player) => this.handleToggleEnd(player, mode),
        children: [
          View({
            style: {
              ...buttonStyle,
              width: 70,
              padding: 6,
              borderRadius: 8,
              borderWidth: 2,
              borderColor: hz.Color.fromHex('#A5673E'),
              backgroundColor: this.toggleButtonColors[mode],
              marginRight: index < arr.length - 1 ? 8 : 0,
              overflow: 'hidden'
            },
            children: [
              Image({
                source: ImageSource.fromTextureAsset(this.props.Background),
                style: { ...backgroundStyle, opacity: 0.7, borderRadius: 6 }
              }),
              Text({
                text: mode,
                style: { ...textStyle, ...regularText },
              }),
            ],
          }),
        ],
      })
    );
    
    // Resources
    const leftResources = this.resources.filter((_, i) => i % 2 === 0);
    const rightResources = this.resources.filter((_, i) => i % 2 !== 0);

    const resourceViews: UINode = View({
      style: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'flex-start',
      },
      children: [
        View({
          style: {
            flex: 1,
            marginRight: 8,
          },
          children: leftResources.map(resource => this.renderResource(resource, showResourceName, showResourceIcon)),
        }),
        View({
          style: {
            flex: 1,
            marginLeft: 8,
          },
          children: rightResources.map(resource => this.renderResource(resource, showResourceName, showResourceIcon)),
        }),
      ],
    });

    // Close button
    const closeButton = Pressable({
      onPress: () => {
        this.closeButtonColor.set(this.defaultCloseButtonColor);
        this.entity.visible.set(false);
      },
      onEnter: (player) => this.closeButtonColor.set(this.hoverCloseButtonColor),
      onExit: (player) => this.closeButtonColor.set(this.defaultCloseButtonColor),
      children: [
        View({
          style: {
            ...buttonStyle,
            width: 70,
            //height: 40,
            padding: 6,
            borderRadius: 8,
            backgroundColor: this.closeButtonColor,
            alignItems: 'center',
            justifyContent: 'center',
            borderWidth: 2,
            borderColor: hz.Color.fromHex('#A5673E'),
            marginLeft: 12,
            position: 'absolute',
            //top: 0,
            right: 10,
            zIndex: 1,
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: { ...backgroundStyle, opacity: 0.7, borderRadius: 6 }
            }),
            Text({
              text: 'X',
              style: {
                ...textStyle,
                ...regularText,
              },
            }),
          ],
        }),
      ],
    });
    
    // Render view
    return View({
      style: { ...fullscreenCenterStyle },
      children: [
        View({
          style: {
            alignItems: 'center',
          },
          children: [
            View({
              style: panelStyleWithColumn,
              children: [
                Image({
                  source: ImageSource.fromTextureAsset(this.props.Background),
                  style: backgroundStyle
                }),
                closeButton,
                View({ style: toggleRowStyle, children: toggleButtons }),
                ScrollView({
                  style: {
                    height: 435, //435
                    paddingHorizontal: 10,
                    //paddingRight: 10,
                  },
                  children: resourceViews,
                }),
              ],
            }),
          ],
        }),
      ],
    });
  }

  private renderResource(resource: ResourceWithBindings, showResourceName: boolean, showResourceIcon: boolean): UINode {
    return UINode.if(resource.visibleBinding, View({
      style: {
        ...resourceRowStyle,
      },
      children: [
        View({
          style: { flexDirection: 'column', flex: 1 },
          children: [
            // Top row
            View({
              style: {
                flexDirection: 'row',
                justifyContent: 'space-between',
                alignItems: 'center',
              },
              children: [
                View({
                  style: {
                    flexDirection: 'row',
                    alignItems: 'center',
                  },
                  children: [
                    ...(showResourceIcon
                      ? [Image({
                          source: resource.iconBinding,
                          style: resourceIconStyle,
                        })]
                      : []),
                    ...(showResourceName
                      ? [Text({
                          text: resource.nameBinding,
                          style: {
                            ...textStyle,
                            ...regularText,
                            color: resource.colourBinding,
                            marginRight: 6,
                          },
                        })]
                      : []),
                    Text({
                      text: resource.amountBinding,
                      style: { ...textStyle, ...smallText, marginTop: 4 },
                    }),
                  ],
                }),
                View({
                  style: {
                    flexDirection: 'row',
                    alignItems: 'center',
                    marginTop: 3
                  },
                  children: [
                    Text({
                      text: resource.sellAmountBinding,
                      style: { ...textStyle, ...smallText },
                    }),
                    Text({
                      text: ' x ',
                      style: { ...textStyle, ...smallText, marginRight: 4 },
                    }),
                    // Text({
                    //   text: resource.priceBinding,
                    //   style: { ...textStyle, ...regularText, color: resource.priceColorBinding },
                    // }),
    
                    View({
                      style: {
                        transform: [{ translateX: resource.unstableAnimBinding }],
                      },
                      children: [
                        Text({
                          text: resource.priceBinding,
                          style: { 
                            ...textStyle, 
                            ...regularText, 
                            color: resource.priceColorBinding,
                            fontWeight: resource.isBoldPriceBinding.derive(bold => bold ? 'bold' : 'normal'),
                            textShadowColor: resource.priceShadowColorBinding,
                            textShadowOffset: [2, 2],
                            textShadowRadius: 0,
                          },
                        })
                      ]
                    })
    
                    // Image({
                    //   source: ImageSource.fromTextureAsset(this.props.Coins),
                    //   style: { ...resourceIconStyle, tintColor: resource.priceColorBinding}
                    // }),
                  ],
                }),
              ],
            }),
            // Sell button
            UINode.if(
              resource.canSellBinding,
              this.renderSellButton(resource, true),
              this.renderSellButton(resource, false)
            )              
          ],
        }),
      ],
    }));
  }  

  // Has it's own method so we don't duplicate code for our UINode.If
  private renderSellButton(resource: ResourceWithBindings, isEnabled: boolean): UINode {
    return Pressable({
      onPress: isEnabled ? (player) => this.handleSellClick(player, resource.resourceId) : undefined,
      onEnter: isEnabled ? (player) => resource.sellButtonColorBinding.set(this.hoverSellButtonColor) : undefined,
      onExit: isEnabled ? (player) => resource.sellButtonColorBinding.set(this.defaultSellButtonColor) : undefined,
      children: [
        View({
          style: {
            ...buttonStyle,
            alignSelf: 'stretch',
            alignItems: 'center',
            justifyContent: 'center',
            paddingVertical: 6,
            borderRadius: 6,
            marginTop: 4,
            backgroundColor: resource.sellButtonColorBinding,
            borderColor: hz.Color.fromHex('#9e722b'),
            borderWidth: 2,
            height: 40,
            overflow: 'hidden',
            opacity: isEnabled ? 1 : 0.5,
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: {
                ...backgroundStyle,
                opacity: 0.7
              }
            }),
            View({
              style: {
                flexDirection: 'row',
                alignItems: 'center',
              },
              children: [
                Text({
                  text: resource.sellValueBinding,
                  style: { ...textStyle, ...smallText },
                }),
                ...(isEnabled
                  ? [
                      Image({
                        source: ImageSource.fromTextureAsset(this.props.Coins),
                        style: { ...resourceIconStyle, marginRight: -5 }
                      }),
                    ]
                  : []),
              ],
            }),
          ],
        }),
      ],
    });
  }  
  
  private handleUI(data: TraderUIDataStruc): void {
    const { visible, resourceGameData, playerResourceData, currentPricesData } = data;
    if (resourceGameData) {
      resourceGameData.forEach((incoming) => {
        const match = this.resources.find(r => r.resourceId === incoming.resourceId);
        if (!match) return;
  
        match.nameBinding.set(incoming.name.replace(/([a-z])([A-Z])/g, '$1 $2'));
        match.colourBinding.set(incoming.colour);
  
        const asset = this.props[incoming.name];
        if (asset) {
          const source = ImageSource.fromTextureAsset(asset);
          match.iconBinding.set(source);
        }        
      });
    }
  
    let gotAmounts = false;
    let gotPrices = false;
    
    if (playerResourceData) {
      gotAmounts = true;
      playerResourceData.forEach((res) => {
        const resource = this.resources.find((r) => r.resourceId === res.resourceId);
        if (resource) {
          resource.rawAmount = res.amount;
          //resource.amountBinding.set(res.amount.toString());
          resource.amountBinding.set(this.formatCompactNumber(res.amount));
          resource.visibleBinding.set(res.amount >= 0);

          resource.isBoldPriceBinding.set(false);
        }
      });
    }
    
    if (currentPricesData) {
      gotPrices = true;
      currentPricesData.forEach((price) => {
        const resource = this.resources.find((r) => r.resourceId === price.resourceId);
        if (resource) {
          resource.rawPrice = price.currentPrice;
          resource.priceBinding.set(Math.floor(price.currentPrice).toString());
    
          let priceColor: hz.Color;
          let priceShadowColor: hz.Color;
    
          if (price.lastPriceChangePositive === true) {
            priceColor = hz.Color.fromHex('#7C9A55');
            priceShadowColor = hz.Color.fromHex('#456632');
          } else if (price.lastPriceChangePositive === false) {
            priceColor = hz.Color.fromHex('#C75033');
            priceShadowColor = hz.Color.fromHex('#4B1E14');
          } else {
            priceColor = hz.Color.fromHex('#ead2b0');
            priceShadowColor = hz.Color.fromHex('#000000');
          }
    
          resource.priceColorBinding.set(priceColor);
    
          if (price.lastEventUnstable) {
            this.shakePrice(resource);
            resource.isBoldPriceBinding.set(true);
            resource.priceShadowColorBinding.set(priceShadowColor);
          } else {
            resource.isBoldPriceBinding.set(false);
            resource.priceShadowColorBinding.set(hz.Color.fromHex('#5C4033'));
          }
        }
      });
    }
    
    
    if (gotAmounts || gotPrices) {
      this.updateSellAmounts();
    }    
  
    if (visible !== undefined) {
      this.entity.visible.set(visible);
    }
  }  

  private shakePrice(resource: ResourceWithBindings): void {
    resource.unstableAnimBinding.set(Animation.sequence(
      Animation.timing(10, { duration: 50 }),
      Animation.timing(-10, { duration: 50 }),
      Animation.timing(6, { duration: 50 }),
      Animation.timing(-6, { duration: 50 }),
      Animation.timing(3, { duration: 50 }),
      Animation.timing(0, { duration: 50 })
    ));
  }

  private handleToggleClick(player: hz.Player, mode: SellMode): void {
    this.selectedSellMode = mode;
    this.updateSelectedToggleButtonColor(player, mode);
    this.updateSellAmounts();
  }

  private handleToggleHover(player: hz.Player, mode: SellMode): void {
    if (mode === this.selectedSellMode) {
      return; // Don't apply hover color to selected toggle
    }
    
    this.toggleButtonColors[mode].set(this.hoverToggleColor);
  }

  private handleToggleEnd(player: hz.Player, mode: SellMode): void {
    if (mode === this.selectedSellMode) {
      this.toggleButtonColors[mode].set(this.selectedToggleColor);
    } else {
      this.toggleButtonColors[mode].set(this.defaultToggleColor);
    }
  }
  
  private updateSelectedToggleButtonColor(player: hz.Player, selectedMode: SellMode): void {
    for (const mode of ['x1', '5%', '25%', 'All'] as SellMode[]) {
      if (mode === selectedMode) {
        this.toggleButtonColors[mode].set(this.selectedToggleColor);
      } else {
        this.toggleButtonColors[mode].set(this.defaultToggleColor);
      }
    }
  }  

  private updateSellAmounts(): void {
    for (const resource of this.resources) {
      const amount = resource.rawAmount ?? 0;
      const price = resource.rawPrice ?? 0;
  
      let sellAmount = 0;
  
      if (amount <= 0) {
        // Skip calculation completely for 0
        resource.rawSellAmount = 0;
        resource.sellAmountBinding.set('0');
        resource.sellValueBinding.set('None to sell');
        resource.canSellBinding.set(false);
        continue;
      }
  
      switch (this.selectedSellMode) {
        case 'x1':
          sellAmount = 1;
          break;
        case '5%':
          sellAmount = Math.floor(amount * 0.05);
          break;
        case '25%':
          sellAmount = Math.floor(amount * 0.25);
          break;
        case 'All':
          sellAmount = amount;
          break;
      }
  
      sellAmount = Math.max(0, Math.floor(sellAmount));
  
      // Set data
      resource.rawSellAmount = sellAmount;
      //resource.sellAmountBinding.set(sellAmount.toString());
      resource.sellAmountBinding.set(this.formatCompactNumber(sellAmount));
  
      if (sellAmount > 0 && price > 0) {
        const sellValue = Math.floor(sellAmount * price);
        //resource.sellValueBinding.set(`Sell for ${sellValue}`);
        resource.sellValueBinding.set(`Sell for ${this.formatCompactNumber(sellValue)}`);
        resource.canSellBinding.set(true);
      } else {
        resource.sellValueBinding.set('None to sell');
        resource.canSellBinding.set(false);
      }      
    }
  }  
  
  private handleSellClick(player: hz.Player, resourceId: number): void {
    const resource = this.resources.find(r => r.resourceId === resourceId);
    if (!resource) {
      console.warn(`handleSellClick: No resource found for ID ${resourceId}`);
      return;
    }
  
    const sellAmount = resource.rawSellAmount ?? 0;
    //const sellValue = sellAmount * (resource.rawPrice ?? 0);
    const sellValue = resource.rawPrice ?? 0;
    
    console.log(`${player.name.get()} clicked sell for resourceId: ${resourceId}, mode: ${this.selectedSellMode}, sell amount: ${sellAmount}, price ea: ${sellValue}`);
    
    this.sendNetworkBroadcastEvent(sellResource, {
      player,
      resourceId,
      sellAmount,
      sellValue
    });
  }  

  private formatCompactNumber(value: number): string {
    if (value >= 1_000_000_000_000_000_000_000) {
      return (value / 1_000_000_000_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'S';
    } else if (value >= 1_000_000_000_000_000) {
      return (value / 1_000_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'Q';
    } else if (value >= 1_000_000_000_000) {
      return (value / 1_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'T';
    } else if (value >= 1_000_000_000) {
      return (value / 1_000_000_000).toFixed(1).replace(/\.0$/, '') + 'B';
    } else if (value >= 1_000_000) {
      return (value / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
    } else if (value >= 1_000) {
      return (value / 1_000).toFixed(1).replace(/\.0$/, '') + 'K';
    } else {
      return value.toString();
    }
  }
  
}

UIComponent.register(UI_Trader);
import * as hz from 'horizon/core';

import {
  View,
  Text,
  Pressable,
  UINode,
  UIComponent,
  Binding,
  Image,
  ImageSource
} from 'horizon/ui';

import { 
  textStyle,
  largeText, 
  regularText, 
  panelStyle,
  buttonStyle, 
  defaultButtonColor,
  hoverButtonColor,
  pressedButtonColor,
  backgroundStyle
} from './UI_CommonStyles';

import { onUIReady, updateWelcome } from 'UIManager';
import { onPlayerAcknowledgedWelcome, WelcomeUIDataStruc } from './PlayerManager';

class UI_Welcome extends UIComponent {
  static propsDefinition = {
    Background: { type: hz.PropTypes.Asset },
  };

  private welcomeTitleBinding: Binding<string> = new Binding("Welcome to the Frontier");
  private welcomeDescriptionBinding: Binding<string> = new Binding("You've just arrived in a land of dust, gold, and opportunity. Stake your claim, build your empire, and become the richest in the Wild West. Your journey starts now, partner!");
  private buttonColorBinding: Binding<hz.Color> = new Binding(defaultButtonColor);

  receiveOwnership(
    state: any,
    fromPlayer: hz.Player,
    toPlayer: hz.Player
  ): void {
    console.log(`UI_Welcome: receiveOwnership from server to ${toPlayer?.name.get()}`);
  
    // Tell UIManager we're initialized and ready for binding updates
    this.sendNetworkBroadcastEvent(onUIReady, {
      player: toPlayer,
      uiName: 'Welcome',
      uiEntity: this.entity
    });
  }  

  initializeUI(): UINode {
    // Start hidden; only visible when set via updateUIName event
    this.entity.visible.set(false)

    this.connectNetworkEvent(
      this.entity,
      updateWelcome,
      (data) => this.handleUI(data)
    );    

    return this.renderUI();
  }

  private renderUI(): UINode {
    return View({
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        justifyContent: 'center',
        alignItems: 'center',
      },
      children: [
        View({
          style: {
            ...panelStyle,
            width: 400,
            maxHeight: 500,
            padding: 20,
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center',
            position: 'relative',
            overflow: 'hidden',
          },
          children: [
            Image({
              source: ImageSource.fromTextureAsset(this.props.Background),
              style: backgroundStyle,
            }),
            Text({
              text: this.welcomeTitleBinding,
              style: { ...textStyle, ...largeText, marginBottom: 10 },
            }),
            Text({
              text: this.welcomeDescriptionBinding,
              style: { ...textStyle, ...regularText, marginBottom: 20 },
            }),
            Pressable({
              onPress: this.handleButtonClick.bind(this),
              onEnter: player => this.buttonColorBinding.set(hz.Color.fromHex('#bd6242')),
              onExit: player => this.buttonColorBinding.set(defaultButtonColor),
              children: [
                View({
                  style: {
                    ...buttonStyle,
                    backgroundColor: this.buttonColorBinding,
                    borderColor: hz.Color.fromHex('#9e722b'),
                    overflow: 'hidden',
                  },
                  children: [
                    Image({
                      source: ImageSource.fromTextureAsset(this.props.Background),
                      style: {
                        ...backgroundStyle,
                        borderRadius: 6,
                        opacity: 0.7,
                      }
                    }),
                    Text({
                      text: "Continue",
                      style: { ...textStyle, ...regularText },
                    }),
                  ]
                })
              ]
            }),
          ],
        }),
      ],
    });
  }  
  
  private handleUI(data: WelcomeUIDataStruc): void {
    const { visible, playerMetaData } = data;
    const player = this.entity.owner.get();
  
    // Initial setup (only happens once)
    if (playerMetaData && player) {
      if (playerMetaData.isNewPlayer) {
        this.welcomeTitleBinding.set("Welcome, " + player.name.get());
      } else {
        this.welcomeTitleBinding.set("Welcome back, " + player.name.get());
        this.welcomeDescriptionBinding.set("It's good to see you again!");
      }
  
      // Show UI after initial setup, can be overridden below
      this.entity.visible.set(true);
    }
  
    // UI changes
    if (visible !== undefined) {
      this.entity.visible.set(visible);
    }
  }
  

  private handleButtonClick(player: hz.Player): void {
    this.buttonColorBinding.set(pressedButtonColor);
    this.entity.visible.set(false)
    this.sendNetworkBroadcastEvent(onPlayerAcknowledgedWelcome, { player });
  }
}

UIComponent.register(UI_Welcome);
import * as hz from 'horizon/core';

import { onImagesReady } from './UI_ImagePreloader';
import { 
  SlotUIDataStruc,
  TraderUIDataStruc,
  ResourceBarUIDataStruc,
  WelcomeUIDataStruc,
  OfflineProgressUIDataStruc 
} from './PlayerManager';

export type OnUIReadyData = {
  player: hz.Player;
  uiName: string;
  uiEntity: hz.Entity;
};

export type SendUIUpdateData = {
  player: hz.Player;
  uiName: string;
  eventName: string;
  payload: hz.SerializableState;
};

// UI Creation and Termination
export const spawnUIForPlayer = new hz.NetworkEvent<{ player: hz.Player }>('spawnUIForPlayer');
export const cleanupUIForPlayer = new hz.NetworkEvent<{ player: hz.Player }>('cleanupUIForPlayer');

// UI Registration
export const onUIReady = new hz.NetworkEvent<OnUIReadyData>('onUIReady');
export const onUIReadyForRegistration = new hz.NetworkEvent<OnUIReadyData>('onUIReadyForRegistration');

// Cross-UI data dispatch
export const sendUIUpdate = new hz.NetworkEvent<SendUIUpdateData>('sendUIUpdate');

// UI-Specific updates
export const updateResourceBar = new hz.NetworkEvent<ResourceBarUIDataStruc>('updateResourceBar');
export const updateWelcome = new hz.NetworkEvent<WelcomeUIDataStruc>('updateWelcome');
export const updateOfflineProgress = new hz.NetworkEvent<OfflineProgressUIDataStruc>('updateOfflineProgress');
export const updateSlot = new hz.NetworkEvent<SlotUIDataStruc>('updateSlot');
export const updateTrader = new hz.NetworkEvent<TraderUIDataStruc>('updateTrader');
export const updateNotification = new hz.NetworkEvent<TraderUIDataStruc>('updateNotification');
export const updateSaloon = new hz.NetworkEvent<TraderUIDataStruc>('updateSaloon');

const eventMap: Record<string, hz.NetworkEvent<any>> = {
  updateResourceBar,
  updateWelcome,
  updateOfflineProgress,
  updateSlot,
  updateTrader,
  updateNotification,
  updateSaloon
};

export class UIManager extends hz.Component<typeof UIManager> {
  private imagesReady = false
  private pendingSpawnQueue: hz.Player[] = [];
  private pendingUpdatesQueue: Map<hz.Player, Map<string, { event: hz.NetworkEvent<any>; payload: any }[]>> = new Map();

  private eventMap: Record<string, hz.NetworkEvent<any>> = eventMap;

  private playerUIEntities: Map<hz.Player, Record<string, hz.Entity>> = new Map();

  static propsDefinition = {
    ResourceBarAsset: { type: hz.PropTypes.Asset },
    WelcomeAsset: { type: hz.PropTypes.Asset },
    OfflineProgressAsset: { type: hz.PropTypes.Asset },
    SlotAsset: { type: hz.PropTypes.Asset },
    TraderAsset: { type: hz.PropTypes.Asset },
    NotificationAsset: { type: hz.PropTypes.Asset },
    SaloonAsset: { type: hz.PropTypes.Asset },
  };

  start() {
    // UI Creation and Termination
    this.connectNetworkBroadcastEvent(
      spawnUIForPlayer, 
      ({ player }) => this.spawnUIForPlayer(player)
    );
    
    this.connectNetworkBroadcastEvent(
      cleanupUIForPlayer, 
      ({ player }) => this.cleanupUIForPlayer(player )
    );

    // UI Registration
    this.connectNetworkBroadcastEvent(
      onUIReadyForRegistration,
      ({ player, uiName, uiEntity }) => {
        this.registerUIEntity(player, uiName, uiEntity);
    
        const queued = this.pendingUpdatesQueue.get(player)?.get(uiName);
        if (queued && queued.length > 0) {
          for (const { event, payload } of queued) {
            this.sendNetworkEvent(uiEntity, event, payload);
            console.log(`Flushed queued event "${event.name}" to "${uiName}" for ${player.name.get()}`);
          }
    
          // Clean up the queue
          this.pendingUpdatesQueue.get(player)?.delete(uiName);
          if (this.pendingUpdatesQueue.get(player)?.size === 0) {
            this.pendingUpdatesQueue.delete(player);
          }
        }
      }
    );    
    
    // Cross-UI Data Dispatch
    this.connectNetworkBroadcastEvent(
      sendUIUpdate,
      ({ player, uiName, eventName, payload }) => {
        const event = this.eventMap[eventName];
        if (!event) {
          console.warn(`sendUIUpdate: Event "${eventName}" not found in eventMap`);
          return;
        }
    
        const entity = this.playerUIEntities.get(player)?.[uiName];
    
        if (entity) {
          // if (uiName === 'Trader' && eventName === 'updateTrader') {
          //   this.queueMoveUI(player, uiName, payload as TraderUIDataStruc);
          // }
          
          if (uiName === 'Slot' && eventName === 'updateSlot') {
            this.queueMoveUI(player, uiName, payload as SlotUIDataStruc);
          }
          
          this.sendNetworkEvent(entity, event, payload);
          //console.log(`sendUIUpdate: Dispatched "${eventName}" to "${uiName}" for ${player.name.get()}`);
        } else {
          console.warn(`sendUIUpdate: UI "${uiName}" not yet registered for ${player.name.get()}, queueing update`);
    
          if (!this.pendingUpdatesQueue.has(player)) {
            this.pendingUpdatesQueue.set(player, new Map());
          }
    
          const playerQueue = this.pendingUpdatesQueue.get(player)!;
    
          if (!playerQueue.has(uiName)) {
            playerQueue.set(uiName, []);
          }
    
          playerQueue.get(uiName)!.push({ event, payload });
        }
      }
    );    

    // Icons have been loaded server-side and can now be used client-side
    this.connectNetworkBroadcastEvent(
      onImagesReady, 
      () => {
        this.imagesReady = true;

        for (const player of this.pendingSpawnQueue) {
          this.spawnUIForPlayer(player);
        }

        this.pendingSpawnQueue = [];

        console.log('UIManager: Icons are ready. Spawning UI for pending players...');
    });    
  }  

  // Spawn all UI entities for a player
  private async spawnUIForPlayer(player: hz.Player): Promise<void> {
    // Local UI can't be spawned until the server has cached all images being used for UI
    if (!this.imagesReady) {
      console.warn(`spawnUIForPlayer: Icons not ready for local use, queueing UI spawn for ${player.name.get()}`);
      this.pendingSpawnQueue.push(player);
      return;
    }

    // If player already has UI entities, clean them up before spawning new ones
    await this.cleanupUIForPlayer(player);

    //console.log(`spawnUIForPlayer: Spawning UI asset for ${player.name.get()}`);
    const assetProps = [
      { asset: this.props.WelcomeAsset, uiName: 'Welcome' },
      { asset: this.props.OfflineProgressAsset, uiName: 'OfflineProgress' },
      { asset: this.props.ResourceBarAsset, uiName: 'ResourceBar' },
      { asset: this.props.SlotAsset, uiName: 'Slot' },
      { asset: this.props.TraderAsset, uiName: 'Trader' },
      { asset: this.props.NotificationAsset, uiName: 'Notification' },
      { asset: this.props.SaloonAsset, uiName: 'Saloon' },
    ];
  
    for (const { asset } of assetProps) {
      if (!asset) continue;
  
      const [uiEntity] = await this.world.spawnAsset(
        asset,
        new hz.Vec3(0, 0, 0),
        hz.Quaternion.one,
        new hz.Vec3(2.5, 2.5, 2.5)
      );
      
      if (uiEntity) {
        uiEntity.owner.set(player); // UI script restarts and sends onUIReady which PlayerManager listens to, to send all game/save data
      } else {
        console.warn(`spawnUIForPlayer: Failed to spawn asset for player ${player.name.get()}`);
      }
    }
  }

  // Dispose all UI entities for a player
  private async cleanupUIForPlayer(player: hz.Player): Promise<void> {
    const uiMap = this.playerUIEntities.get(player);
    if (!uiMap || Object.keys(uiMap).length === 0) {
      console.warn(`cleanupUIForPlayer: No UI entities found to clean up for ${player.name.get()}`);
      return;
    }
  
    for (const uiEntity of Object.values(uiMap)) {
      await this.world.deleteAsset(uiEntity, true);
    }
  
    this.playerUIEntities.delete(player);
  }
  
  // Register all UI entities so that they can be referenced and disposed of, when necessary
  private registerUIEntity(player: hz.Player, uiName: string, uiEntity: hz.Entity): void {
    const map = this.playerUIEntities.get(player) ?? {};
    map[uiName] = uiEntity;
    this.playerUIEntities.set(player, map);
  }  

  // Check if uiPos & uiRot is included in the payload before moving it
  private queueMoveUI<T extends { uiPos?: hz.Vec3; uiRot?: hz.Quaternion }>(
    player: hz.Player,
    uiName: string,
    data: T
  ): void {
    //console.log('queue moveUI: Queueing move, was a position and rotation passed in?')
    if (data.uiPos && data.uiRot) {
      //console.log('queue moveUI: Position and rotation is present, calling moveUI')
      this.moveUI(player, uiName, data.uiPos, data.uiRot);
    } else {
      //console.warn(`queueMoveUI: No position or rotation provided for UI_${uiName} for player ${player.name.get()}. This may be intended`);
    }
  }
  
  // Move UI entitiy in world space
  private moveUI(player: hz.Player, uiName: string, pos: hz.Vec3, rot: hz.Quaternion): void {
    console.log('moveUI: Getting UI entity for player');
    const ui = this.getUIEntity(player, uiName);
    if (!ui) {
      console.warn(`moveUI: No ${uiName} UI found for player ${player.name.get()}`);
      return;
    }
    
    // Check if we actually need to move the UI?
    const currentPos = ui.position.get();
    const currentRot = ui.rotation.get();
  
    const samePos = currentPos.equals(pos);
    const sameRot = currentRot.equals(rot);
  
    if (samePos && sameRot) {
      console.log(`moveUI: Skipping move, position and rotation passed in matches existing pos and rot for ${uiName}`);
      return;
    }
  
    console.log('moveUI: Moving UI to new position and rotation');
    ui.position.set(pos);
    ui.rotation.set(rot);
  }  
  
  private getUIEntity(player: hz.Player, uiName: string): hz.Entity | undefined {
    return this.playerUIEntities.get(player)?.[uiName];
  }
  
  // Send data to a player's specific UI instance
  private sendToUIEntity<T extends hz.SerializableState>(
    player: hz.Player,
    uiName: string,
    event: hz.NetworkEvent<T>,
    data: T
  ): void {
    const entity = this.playerUIEntities.get(player)?.[uiName];
    if (!entity) {
      console.warn(`sendToUIEntity: Entity "${uiName}" not found for player ${player.name.get()}`);
      return;
    }
    console.log(`sendToUIEntity: Sending event "${event.name}" to entity "${uiName}" for ${player.name.get()}`);
  
    this.sendNetworkEvent(entity, event, data);
  }
}

hz.Component.register(UIManager);


